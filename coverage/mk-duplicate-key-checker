---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
.../mk-duplicate-key-checker   13.1    2.0    5.7   35.1    n/a  100.0   10.7
Total                          13.1    2.0    5.7   35.1    n/a  100.0   10.7
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:21:48 2010
Finish:       Thu Jan 28 22:21:48 2010

Run:          ./101_basics.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:21:49 2010
Finish:       Thu Jan 28 22:21:51 2010

Run:          ./102_clustered_keys.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:21:54 2010
Finish:       Thu Jan 28 22:21:54 2010

Run:          ./103_standard_options.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:21:57 2010
Finish:       Thu Jan 28 22:21:57 2010

Run:          ./201_issue_298.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:22:00 2010
Finish:       Thu Jan 28 22:22:00 2010

Run:          ./202_issue_331.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:22:03 2010
Finish:       Thu Jan 28 22:22:04 2010

Run:          ./203_issue_663.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:22:07 2010
Finish:       Thu Jan 28 22:22:08 2010

/home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This is mk-duplicate-key-checker, a program to analyze MySQL tables for
4                                                     # duplicated or redundant indexes and foreign key constraints.
5                                                     # 
6                                                     # This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
7                                                     # Feedback and improvements are welcome.
8                                                     #
9                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
10                                                    # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
11                                                    # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
12                                                    #
13                                                    # This program is free software; you can redistribute it and/or modify it under
14                                                    # the terms of the GNU General Public License as published by the Free Software
15                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
16                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
17                                                    # licenses.
18                                                    #
19                                                    # You should have received a copy of the GNU General Public License along with
20                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
21                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
22                                                    
23             6                    6            38   use strict;
               6                                 14   
               6                                 48   
24             6                    6            41   use warnings FATAL => 'all';
               6                                 15   
               6                                 44   
25                                                    
26                                                    our $VERSION = '@VERSION@';
27                                                    our $DISTRIB = '@DISTRIB@';
28                                                    our $SVN_REV = sprintf("%d", (q$Revision: 5425 $ =~ m/(\d+)/g, 0));
29                                                    
30                                                    # ###########################################################################
31                                                    # VersionParser package 5266
32                                                    # ###########################################################################
33                                                    package VersionParser;
34                                                    
35             6                    6            41   use strict;
               6                                 15   
               6                                 28   
36             6                    6            36   use warnings FATAL => 'all';
               6                                 13   
               6                                 28   
37                                                    
38             6                    6            41   use English qw(-no_match_vars);
               6                                 15   
               6                                 39   
39                                                    
40    ***      6            50      6            41   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 19   
               6                                 97   
41                                                    
42                                                    sub new {
43    ***      0                    0             0      my ( $class ) = @_;
44    ***      0                                  0      bless {}, $class;
45                                                    }
46                                                    
47                                                    sub parse {
48    ***      0                    0             0      my ( $self, $str ) = @_;
49    ***      0                                  0      my $result = sprintf('%03d%03d%03d', $str =~ m/(\d+)/g);
50    ***      0                                  0      MKDEBUG && _d($str, 'parses to', $result);
51    ***      0                                  0      return $result;
52                                                    }
53                                                    
54                                                    sub version_ge {
55    ***      0                    0             0      my ( $self, $dbh, $target ) = @_;
56    ***      0      0                           0      if ( !$self->{$dbh} ) {
57    ***      0                                  0         $self->{$dbh} = $self->parse(
58                                                             $dbh->selectrow_array('SELECT VERSION()'));
59                                                       }
60    ***      0      0                           0      my $result = $self->{$dbh} ge $self->parse($target) ? 1 : 0;
61    ***      0                                  0      MKDEBUG && _d($self->{$dbh}, 'ge', $target, ':', $result);
62    ***      0                                  0      return $result;
63                                                    }
64                                                    
65                                                    sub _d {
66    ***      0                    0             0      my ($package, undef, $line) = caller 0;
67    ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
68    ***      0                                  0           map { defined $_ ? $_ : 'undef' }
69                                                            @_;
70    ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
71                                                    }
72                                                    
73                                                    1;
74                                                    
75                                                    # ###########################################################################
76                                                    # End VersionParser package
77                                                    # ###########################################################################
78                                                    
79                                                    # ###########################################################################
80                                                    # Quoter package 5266
81                                                    # ###########################################################################
82             6                    6            43   use strict;
               6                                 16   
               6                                 37   
83             6                    6            39   use warnings FATAL => 'all';
               6                                 28   
               6                                 30   
84                                                    
85                                                    package Quoter;
86                                                    
87             6                    6            36   use English qw(-no_match_vars);
               6                                 15   
               6                                 32   
88                                                    
89    ***      6            50      6            38   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 20   
               6                                 85   
90                                                    
91                                                    sub new {
92             6                    6           233      my ( $class ) = @_;
93             6                                 67      bless {}, $class;
94                                                    }
95                                                    
96                                                    sub quote {
97    ***      0                    0             0      my ( $self, @vals ) = @_;
98    ***      0                                  0      foreach my $val ( @vals ) {
99    ***      0                                  0         $val =~ s/`/``/g;
100                                                      }
101   ***      0                                  0      return join('.', map { '`' . $_ . '`' } @vals);
      ***      0                                  0   
102                                                   }
103                                                   
104                                                   sub quote_val {
105   ***      0                    0             0      my ( $self, $val, $is_numeric ) = @_;
106                                                   
107   ***      0      0                           0      return 'NULL' unless defined $val;  # undef = NULL
108   ***      0      0                           0      return "''" if $val eq '';          # blank string = ''
109                                                   
110   ***      0      0                           0      if ( !defined $is_numeric ) {
111   ***      0      0                           0         $is_numeric = $val =~ m/^0|\D/ ? 0 : 1;
112                                                      }
113                                                   
114   ***      0      0                           0      return $val if $is_numeric;
115                                                   
116   ***      0                                  0      $val =~ s/(['\\])/\\$1/g;
117   ***      0                                  0      return "'$val'";
118                                                   }
119                                                   
120                                                   sub split_unquote {
121   ***      0                    0             0      my ( $self, $db_tbl, $default_db ) = @_;
122   ***      0                                  0      $db_tbl =~ s/`//g;
123   ***      0                                  0      my ( $db, $tbl ) = split(/[.]/, $db_tbl);
124   ***      0      0                           0      if ( !$tbl ) {
125   ***      0                                  0         $tbl = $db;
126   ***      0                                  0         $db  = $default_db;
127                                                      }
128   ***      0                                  0      return ($db, $tbl);
129                                                   }
130                                                   
131                                                   sub literal_like {
132   ***      0                    0             0      my ( $self, $like ) = @_;
133   ***      0      0                           0      return unless $like;
134   ***      0                                  0      $like =~ s/([%_])/\\$1/g;
135   ***      0                                  0      return "'$like'";
136                                                   }
137                                                   
138                                                   1;
139                                                   
140                                                   # ###########################################################################
141                                                   # End Quoter package
142                                                   # ###########################################################################
143                                                   
144                                                   # ###########################################################################
145                                                   # TableParser package 5266
146                                                   # ###########################################################################
147                                                   package TableParser;
148                                                   
149            6                    6            48   use strict;
               6                                 14   
               6                                 30   
150            6                    6            37   use warnings FATAL => 'all';
               6                                 15   
               6                                 28   
151            6                    6            48   use English qw(-no_match_vars);
               6                                 14   
               6                                 34   
152            6                    6            44   use Data::Dumper;
               6                                 16   
               6                                 52   
153                                                   $Data::Dumper::Indent    = 1;
154                                                   $Data::Dumper::Sortkeys  = 1;
155                                                   $Data::Dumper::Quotekeys = 0;
156                                                   
157   ***      6            50      6            40   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 14   
               6                                 77   
158                                                   
159                                                   
160                                                   sub new {
161            6                    6            33      my ( $class, %args ) = @_;
162            6                                 30      my @required_args = qw(Quoter);
163            6                                 24      foreach my $arg ( @required_args ) {
164   ***      6     50                          36         die "I need a $arg argument" unless $args{$arg};
165                                                      }
166            6                                 31      my $self = { %args };
167            6                                 73      return bless $self, $class;
168                                                   }
169                                                   
170                                                   
171                                                   sub parse {
172   ***      0                    0             0      my ( $self, $ddl, $opts ) = @_;
173   ***      0      0                           0      return unless $ddl;
174   ***      0      0                           0      if ( ref $ddl eq 'ARRAY' ) {
175   ***      0      0                           0         if ( lc $ddl->[0] eq 'table' ) {
176   ***      0                                  0            $ddl = $ddl->[1];
177                                                         }
178                                                         else {
179                                                            return {
180   ***      0                                  0               engine => 'VIEW',
181                                                            };
182                                                         }
183                                                      }
184                                                   
185   ***      0      0                           0      if ( $ddl !~ m/CREATE (?:TEMPORARY )?TABLE `/ ) {
186   ***      0                                  0         die "Cannot parse table definition; is ANSI quoting "
187                                                            . "enabled or SQL_QUOTE_SHOW_CREATE disabled?";
188                                                      }
189                                                   
190   ***      0                                  0      my ($name)     = $ddl =~ m/CREATE (?:TEMPORARY )?TABLE\s+(`.+?`)/;
191   ***      0      0                           0      (undef, $name) = $self->{Quoter}->split_unquote($name) if $name;
192                                                   
193   ***      0                                  0      $ddl =~ s/(`[^`]+`)/\L$1/g;
194                                                   
195   ***      0                                  0      my $engine = $self->get_engine($ddl);
196                                                   
197   ***      0                                  0      my @defs   = $ddl =~ m/^(\s+`.*?),?$/gm;
198   ***      0                                  0      my @cols   = map { $_ =~ m/`([^`]+)`/ } @defs;
      ***      0                                  0   
199   ***      0                                  0      MKDEBUG && _d('Columns:', join(', ', @cols));
200                                                   
201   ***      0                                  0      my %def_for;
202   ***      0                                  0      @def_for{@cols} = @defs;
203                                                   
204   ***      0                                  0      my (@nums, @null);
205   ***      0                                  0      my (%type_for, %is_nullable, %is_numeric, %is_autoinc);
206   ***      0                                  0      foreach my $col ( @cols ) {
207   ***      0                                  0         my $def = $def_for{$col};
208   ***      0                                  0         my ( $type ) = $def =~ m/`[^`]+`\s([a-z]+)/;
209   ***      0      0                           0         die "Can't determine column type for $def" unless $type;
210   ***      0                                  0         $type_for{$col} = $type;
211   ***      0      0                           0         if ( $type =~ m/(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/ ) {
212   ***      0                                  0            push @nums, $col;
213   ***      0                                  0            $is_numeric{$col} = 1;
214                                                         }
215   ***      0      0                           0         if ( $def !~ m/NOT NULL/ ) {
216   ***      0                                  0            push @null, $col;
217   ***      0                                  0            $is_nullable{$col} = 1;
218                                                         }
219   ***      0      0                           0         $is_autoinc{$col} = $def =~ m/AUTO_INCREMENT/i ? 1 : 0;
220                                                      }
221                                                   
222   ***      0                                  0      my ($keys, $clustered_key) = $self->get_keys($ddl, $opts, \%is_nullable);
223                                                   
224                                                      return {
225   ***      0                                  0         name           => $name,
226                                                         cols           => \@cols,
227   ***      0                                  0         col_posn       => { map { $cols[$_] => $_ } 0..$#cols },
228   ***      0                                  0         is_col         => { map { $_ => 1 } @cols },
229                                                         null_cols      => \@null,
230                                                         is_nullable    => \%is_nullable,
231                                                         is_autoinc     => \%is_autoinc,
232                                                         clustered_key  => $clustered_key,
233                                                         keys           => $keys,
234                                                         defs           => \%def_for,
235                                                         numeric_cols   => \@nums,
236                                                         is_numeric     => \%is_numeric,
237                                                         engine         => $engine,
238                                                         type_for       => \%type_for,
239                                                      };
240                                                   }
241                                                   
242                                                   sub sort_indexes {
243   ***      0                    0             0      my ( $self, $tbl ) = @_;
244                                                   
245                                                      my @indexes
246   ***      0                                  0         = sort {
247   ***      0                                  0            (($a ne 'PRIMARY') <=> ($b ne 'PRIMARY'))
248                                                            || ( !$tbl->{keys}->{$a}->{is_unique} <=> !$tbl->{keys}->{$b}->{is_unique} )
249                                                            || ( $tbl->{keys}->{$a}->{is_nullable} <=> $tbl->{keys}->{$b}->{is_nullable} )
250   ***      0      0      0                    0            || ( scalar(@{$tbl->{keys}->{$a}->{cols}}) <=> scalar(@{$tbl->{keys}->{$b}->{cols}}) )
      ***      0             0                    0   
251                                                         }
252                                                         grep {
253   ***      0                                  0            $tbl->{keys}->{$_}->{type} eq 'BTREE'
254                                                         }
255   ***      0                                  0         sort keys %{$tbl->{keys}};
256                                                   
257   ***      0                                  0      MKDEBUG && _d('Indexes sorted best-first:', join(', ', @indexes));
258   ***      0                                  0      return @indexes;
259                                                   }
260                                                   
261                                                   sub find_best_index {
262   ***      0                    0             0      my ( $self, $tbl, $index ) = @_;
263   ***      0                                  0      my $best;
264   ***      0      0                           0      if ( $index ) {
265   ***      0                                  0         ($best) = grep { uc $_ eq uc $index } keys %{$tbl->{keys}};
      ***      0                                  0   
      ***      0                                  0   
266                                                      }
267   ***      0      0                           0      if ( !$best ) {
268   ***      0      0                           0         if ( $index ) {
269   ***      0                                  0            die "Index '$index' does not exist in table";
270                                                         }
271                                                         else {
272   ***      0                                  0            ($best) = $self->sort_indexes($tbl);
273                                                         }
274                                                      }
275   ***      0                                  0      MKDEBUG && _d('Best index found is', $best);
276   ***      0                                  0      return $best;
277                                                   }
278                                                   
279                                                   sub find_possible_keys {
280   ***      0                    0             0      my ( $self, $dbh, $database, $table, $quoter, $where ) = @_;
281   ***      0      0                           0      return () unless $where;
282   ***      0                                  0      my $sql = 'EXPLAIN SELECT * FROM ' . $quoter->quote($database, $table)
283                                                         . ' WHERE ' . $where;
284   ***      0                                  0      MKDEBUG && _d($sql);
285   ***      0                                  0      my $expl = $dbh->selectrow_hashref($sql);
286   ***      0                                  0      $expl = { map { lc($_) => $expl->{$_} } keys %$expl };
      ***      0                                  0   
287   ***      0      0                           0      if ( $expl->{possible_keys} ) {
288   ***      0                                  0         MKDEBUG && _d('possible_keys =', $expl->{possible_keys});
289   ***      0                                  0         my @candidates = split(',', $expl->{possible_keys});
290   ***      0                                  0         my %possible   = map { $_ => 1 } @candidates;
      ***      0                                  0   
291   ***      0      0                           0         if ( $expl->{key} ) {
292   ***      0                                  0            MKDEBUG && _d('MySQL chose', $expl->{key});
293   ***      0                                  0            unshift @candidates, grep { $possible{$_} } split(',', $expl->{key});
      ***      0                                  0   
294   ***      0                                  0            MKDEBUG && _d('Before deduping:', join(', ', @candidates));
295   ***      0                                  0            my %seen;
296   ***      0                                  0            @candidates = grep { !$seen{$_}++ } @candidates;
      ***      0                                  0   
297                                                         }
298   ***      0                                  0         MKDEBUG && _d('Final list:', join(', ', @candidates));
299   ***      0                                  0         return @candidates;
300                                                      }
301                                                      else {
302   ***      0                                  0         MKDEBUG && _d('No keys in possible_keys');
303   ***      0                                  0         return ();
304                                                      }
305                                                   }
306                                                   
307                                                   sub check_table {
308   ***      0                    0             0      my ( $self, %args ) = @_;
309   ***      0                                  0      my @required_args = qw(dbh db tbl);
310   ***      0                                  0      foreach my $arg ( @required_args ) {
311   ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
312                                                      }
313   ***      0                                  0      my ($dbh, $db, $tbl) = @args{@required_args};
314   ***      0                                  0      my $q      = $self->{Quoter};
315   ***      0                                  0      my $db_tbl = $q->quote($db, $tbl);
316   ***      0                                  0      MKDEBUG && _d('Checking', $db_tbl);
317                                                   
318   ***      0                                  0      my $sql = "SHOW TABLES FROM " . $q->quote($db)
319                                                              . ' LIKE ' . $q->literal_like($tbl);
320   ***      0                                  0      MKDEBUG && _d($sql);
321   ***      0                                  0      my $row;
322   ***      0                                  0      eval {
323   ***      0                                  0         $row = $dbh->selectrow_arrayref($sql);
324                                                      };
325   ***      0      0                           0      if ( $EVAL_ERROR ) {
326   ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
327   ***      0                                  0         return 0;
328                                                      }
329   ***      0      0      0                    0      if ( !$row->[0] || $row->[0] ne $tbl ) {
330   ***      0                                  0         MKDEBUG && _d('Table does not exist');
331   ***      0                                  0         return 0;
332                                                      }
333                                                   
334   ***      0                                  0      MKDEBUG && _d('Table exists; no privs to check');
335   ***      0      0                           0      return 1 unless $args{all_privs};
336                                                   
337   ***      0                                  0      $sql = "SHOW FULL COLUMNS FROM $db_tbl";
338   ***      0                                  0      MKDEBUG && _d($sql);
339   ***      0                                  0      eval {
340   ***      0                                  0         $row = $dbh->selectrow_hashref($sql);
341                                                      };
342   ***      0      0                           0      if ( $EVAL_ERROR ) {
343   ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
344   ***      0                                  0         return 0;
345                                                      }
346   ***      0      0                           0      if ( !scalar keys %$row ) {
347   ***      0                                  0         MKDEBUG && _d('Table has no columns:', Dumper($row));
348   ***      0                                  0         return 0;
349                                                      }
350   ***      0             0                    0      my $privs = $row->{privileges} || $row->{Privileges};
351                                                   
352   ***      0                                  0      $sql = "DELETE FROM $db_tbl LIMIT 0";
353   ***      0                                  0      MKDEBUG && _d($sql);
354   ***      0                                  0      eval {
355   ***      0                                  0         $dbh->do($sql);
356                                                      };
357   ***      0      0                           0      my $can_delete = $EVAL_ERROR ? 0 : 1;
358                                                   
359   ***      0                                  0      MKDEBUG && _d('User privs on', $db_tbl, ':', $privs,
360                                                         ($can_delete ? 'delete' : ''));
361                                                   
362   ***      0      0      0                    0      if ( !($privs =~ m/select/ && $privs =~ m/insert/ && $privs =~ m/update/
      ***                    0                        
      ***                    0                        
363                                                             && $can_delete) ) {
364   ***      0                                  0         MKDEBUG && _d('User does not have all privs');
365   ***      0                                  0         return 0;
366                                                      }
367                                                   
368   ***      0                                  0      MKDEBUG && _d('User has all privs');
369   ***      0                                  0      return 1;
370                                                   }
371                                                   
372                                                   sub get_engine {
373   ***      0                    0             0      my ( $self, $ddl, $opts ) = @_;
374   ***      0                                  0      my ( $engine ) = $ddl =~ m/\).*?(?:ENGINE|TYPE)=(\w+)/;
375   ***      0                                  0      MKDEBUG && _d('Storage engine:', $engine);
376   ***      0             0                    0      return $engine || undef;
377                                                   }
378                                                   
379                                                   sub get_keys {
380   ***      0                    0             0      my ( $self, $ddl, $opts, $is_nullable ) = @_;
381   ***      0                                  0      my $engine        = $self->get_engine($ddl);
382   ***      0                                  0      my $keys          = {};
383   ***      0                                  0      my $clustered_key = undef;
384                                                   
385                                                      KEY:
386   ***      0                                  0      foreach my $key ( $ddl =~ m/^  ((?:[A-Z]+ )?KEY .*)$/gm ) {
387                                                   
388   ***      0      0                           0         next KEY if $key =~ m/FOREIGN/;
389                                                   
390   ***      0                                  0         my $key_ddl = $key;
391   ***      0                                  0         MKDEBUG && _d('Parsed key:', $key_ddl);
392                                                   
393   ***      0      0                           0         if ( $engine !~ m/MEMORY|HEAP/ ) {
394   ***      0                                  0            $key =~ s/USING HASH/USING BTREE/;
395                                                         }
396                                                   
397   ***      0                                  0         my ( $type, $cols ) = $key =~ m/(?:USING (\w+))? \((.+)\)/;
398   ***      0                                  0         my ( $special ) = $key =~ m/(FULLTEXT|SPATIAL)/;
399   ***      0             0                    0         $type = $type || $special || 'BTREE';
      ***                    0                        
400   ***      0      0      0                    0         if ( $opts->{mysql_version} && $opts->{mysql_version} lt '004001000'
      ***                    0                        
401                                                            && $engine =~ m/HEAP|MEMORY/i )
402                                                         {
403   ***      0                                  0            $type = 'HASH'; # MySQL pre-4.1 supports only HASH indexes on HEAP
404                                                         }
405                                                   
406   ***      0                                  0         my ($name) = $key =~ m/(PRIMARY|`[^`]*`)/;
407   ***      0      0                           0         my $unique = $key =~ m/PRIMARY|UNIQUE/ ? 1 : 0;
408   ***      0                                  0         my @cols;
409   ***      0                                  0         my @col_prefixes;
410   ***      0                                  0         foreach my $col_def ( split(',', $cols) ) {
411   ***      0                                  0            my ($name, $prefix) = $col_def =~ m/`([^`]+)`(?:\((\d+)\))?/;
412   ***      0                                  0            push @cols, $name;
413   ***      0                                  0            push @col_prefixes, $prefix;
414                                                         }
415   ***      0                                  0         $name =~ s/`//g;
416                                                   
417   ***      0                                  0         MKDEBUG && _d('Key', $name, 'cols:', join(', ', @cols));
418                                                   
419   ***      0                                  0         $keys->{$name} = {
420                                                            name         => $name,
421                                                            type         => $type,
422                                                            colnames     => $cols,
423                                                            cols         => \@cols,
424                                                            col_prefixes => \@col_prefixes,
425                                                            is_unique    => $unique,
426   ***      0                                  0            is_nullable  => scalar(grep { $is_nullable->{$_} } @cols),
427   ***      0                                  0            is_col       => { map { $_ => 1 } @cols },
428                                                            ddl          => $key_ddl,
429                                                         };
430                                                   
431   ***      0      0      0                    0         if ( $engine =~ m/InnoDB/i && !$clustered_key ) {
432   ***      0                                  0            my $this_key = $keys->{$name};
433   ***      0      0      0                    0            if ( $this_key->{name} eq 'PRIMARY' ) {
      ***             0                               
434   ***      0                                  0               $clustered_key = 'PRIMARY';
435                                                            }
436                                                            elsif ( $this_key->{is_unique} && !$this_key->{is_nullable} ) {
437   ***      0                                  0               $clustered_key = $this_key->{name};
438                                                            }
439   ***      0                                  0            MKDEBUG && $clustered_key && _d('This key is the clustered key');
440                                                         }
441                                                      }
442                                                   
443   ***      0                                  0      return $keys, $clustered_key;
444                                                   }
445                                                   
446                                                   sub get_fks {
447   ***      0                    0             0      my ( $self, $ddl, $opts ) = @_;
448   ***      0                                  0      my $fks = {};
449                                                   
450   ***      0                                  0      foreach my $fk (
451                                                         $ddl =~ m/CONSTRAINT .* FOREIGN KEY .* REFERENCES [^\)]*\)/mg )
452                                                      {
453   ***      0                                  0         my ( $name ) = $fk =~ m/CONSTRAINT `(.*?)`/;
454   ***      0                                  0         my ( $cols ) = $fk =~ m/FOREIGN KEY \(([^\)]+)\)/;
455   ***      0                                  0         my ( $parent, $parent_cols ) = $fk =~ m/REFERENCES (\S+) \(([^\)]+)\)/;
456                                                   
457   ***      0      0      0                    0         if ( $parent !~ m/\./ && $opts->{database} ) {
458   ***      0                                  0            $parent = "`$opts->{database}`.$parent";
459                                                         }
460                                                   
461   ***      0                                  0         $fks->{$name} = {
462                                                            name           => $name,
463                                                            colnames       => $cols,
464   ***      0                                  0            cols           => [ map { s/[ `]+//g; $_; } split(',', $cols) ],
      ***      0                                  0   
465                                                            parent_tbl     => $parent,
466                                                            parent_colnames=> $parent_cols,
467   ***      0                                  0            parent_cols    => [ map { s/[ `]+//g; $_; } split(',', $parent_cols) ],
      ***      0                                  0   
468                                                            ddl            => $fk,
469                                                         };
470                                                      }
471                                                   
472   ***      0                                  0      return $fks;
473                                                   }
474                                                   
475                                                   sub remove_auto_increment {
476   ***      0                    0             0      my ( $self, $ddl ) = @_;
477   ***      0                                  0      $ddl =~ s/(^\).*?) AUTO_INCREMENT=\d+\b/$1/m;
478   ***      0                                  0      return $ddl;
479                                                   }
480                                                   
481                                                   sub remove_secondary_indexes {
482   ***      0                    0             0      my ( $self, $ddl ) = @_;
483   ***      0                                  0      my $sec_indexes_ddl;
484   ***      0                                  0      my $tbl_struct = $self->parse($ddl);
485                                                   
486   ***      0      0      0                    0      if ( ($tbl_struct->{engine} || '') =~ m/InnoDB/i ) {
487   ***      0                                  0         my $clustered_key = $tbl_struct->{clustered_key};
488   ***      0             0                    0         $clustered_key  ||= '';
489                                                   
490   ***      0                                  0         my @sec_indexes   = map {
491   ***      0                                  0            my $key_def = $_->{ddl};
492   ***      0                                  0            $key_def =~ s/([\(\)])/\\$1/g;
493   ***      0                                  0            $ddl =~ s/\s+$key_def//;
494   ***      0                                  0            "ADD $_->{ddl}";
495                                                         }
496   ***      0                                  0         grep { $_->{name} ne $clustered_key }
497   ***      0                                  0         values %{$tbl_struct->{keys}};
498   ***      0                                  0         MKDEBUG && _d('Secondary indexes:', Dumper(\@sec_indexes));
499                                                   
500   ***      0      0                           0         if ( @sec_indexes ) {
501   ***      0                                  0            $sec_indexes_ddl = join(' ', @sec_indexes);
502   ***      0                                  0            $sec_indexes_ddl =~ s/,$//;
503                                                         }
504                                                   
505   ***      0                                  0         $ddl =~ s/,(\n\) )/$1/s;
506                                                      }
507                                                      else {
508   ***      0                                  0         MKDEBUG && _d('Not removing secondary indexes from',
509                                                            $tbl_struct->{engine}, 'table');
510                                                      }
511                                                   
512   ***      0                                  0      return $ddl, $sec_indexes_ddl, $tbl_struct;
513                                                   }
514                                                   
515                                                   sub _d {
516   ***      0                    0             0      my ($package, undef, $line) = caller 0;
517   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
518   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
519                                                           @_;
520   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
521                                                   }
522                                                   
523                                                   1;
524                                                   
525                                                   # ###########################################################################
526                                                   # End TableParser package
527                                                   # ###########################################################################
528                                                   
529                                                   # ###########################################################################
530                                                   # MySQLDump package 5266
531                                                   # ###########################################################################
532                                                   package MySQLDump;
533                                                   
534            6                    6            52   use strict;
               6                                 19   
               6                                 36   
535            6                    6            38   use warnings FATAL => 'all';
               6                                 14   
               6                                 43   
536                                                   
537            6                    6            40   use English qw(-no_match_vars);
               6                                 14   
               6                                 30   
538                                                   
539   ***      6            50      6            39   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 16   
               6                                 85   
540                                                   
541                                                   ( our $before = <<'EOF') =~ s/^   //gm;
542                                                      /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
543                                                      /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
544                                                      /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
545                                                      /*!40101 SET NAMES utf8 */;
546                                                      /*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
547                                                      /*!40103 SET TIME_ZONE='+00:00' */;
548                                                      /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
549                                                      /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
550                                                      /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
551                                                      /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
552                                                   EOF
553                                                   
554                                                   ( our $after = <<'EOF') =~ s/^   //gm;
555                                                      /*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;
556                                                      /*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
557                                                      /*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
558                                                      /*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
559                                                      /*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
560                                                      /*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
561                                                      /*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
562                                                      /*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
563                                                   EOF
564                                                   
565                                                   sub new {
566   ***      0                    0             0      my ( $class, %args ) = @_;
567   ***      0      0                           0      $args{cache} = 1 unless defined $args{cache};
568   ***      0                                  0      my $self = bless \%args, $class;
569   ***      0                                  0      return $self;
570                                                   }
571                                                   
572                                                   sub dump {
573   ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl, $what ) = @_;
574                                                   
575   ***      0      0                           0      if ( $what eq 'table' ) {
      ***             0                               
      ***             0                               
576   ***      0                                  0         my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
577   ***      0      0                           0         return unless $ddl;
578   ***      0      0                           0         if ( $ddl->[0] eq 'table' ) {
579   ***      0                                  0            return $before
580                                                               . 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
581                                                               . $ddl->[1] . ";\n";
582                                                         }
583                                                         else {
584   ***      0                                  0            return 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
585                                                               . '/*!50001 DROP VIEW IF EXISTS '
586                                                               . $quoter->quote($tbl) . "*/;\n/*!50001 "
587                                                               . $self->get_tmp_table($dbh, $quoter, $db, $tbl) . "*/;\n";
588                                                         }
589                                                      }
590                                                      elsif ( $what eq 'triggers' ) {
591   ***      0                                  0         my $trgs = $self->get_triggers($dbh, $quoter, $db, $tbl);
592   ***      0      0      0                    0         if ( $trgs && @$trgs ) {
593   ***      0                                  0            my $result = $before . "\nDELIMITER ;;\n";
594   ***      0                                  0            foreach my $trg ( @$trgs ) {
595   ***      0      0                           0               if ( $trg->{sql_mode} ) {
596   ***      0                                  0                  $result .= qq{/*!50003 SET SESSION SQL_MODE='$trg->{sql_mode}' */;;\n};
597                                                               }
598   ***      0                                  0               $result .= "/*!50003 CREATE */ ";
599   ***      0      0                           0               if ( $trg->{definer} ) {
600   ***      0                                  0                  my ( $user, $host )
601   ***      0                                  0                     = map { s/'/''/g; "'$_'"; }
      ***      0                                  0   
602                                                                       split('@', $trg->{definer}, 2);
603   ***      0                                  0                  $result .= "/*!50017 DEFINER=$user\@$host */ ";
604                                                               }
605   ***      0                                  0               $result .= sprintf("/*!50003 TRIGGER %s %s %s ON %s\nFOR EACH ROW %s */;;\n\n",
606                                                                  $quoter->quote($trg->{trigger}),
607   ***      0                                  0                  @{$trg}{qw(timing event)},
608                                                                  $quoter->quote($trg->{table}),
609                                                                  $trg->{statement});
610                                                            }
611   ***      0                                  0            $result .= "DELIMITER ;\n\n/*!50003 SET SESSION SQL_MODE=\@OLD_SQL_MODE */;\n\n";
612   ***      0                                  0            return $result;
613                                                         }
614                                                         else {
615   ***      0                                  0            return undef;
616                                                         }
617                                                      }
618                                                      elsif ( $what eq 'view' ) {
619   ***      0                                  0         my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
620   ***      0                                  0         return '/*!50001 DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
621                                                            . '/*!50001 DROP VIEW IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
622                                                            . '/*!50001 ' . $ddl->[1] . "*/;\n";
623                                                      }
624                                                      else {
625   ***      0                                  0         die "You didn't say what to dump.";
626                                                      }
627                                                   }
628                                                   
629                                                   sub _use_db {
630   ***      0                    0             0      my ( $self, $dbh, $quoter, $new ) = @_;
631   ***      0      0                           0      if ( !$new ) {
632   ***      0                                  0         MKDEBUG && _d('No new DB to use');
633   ***      0                                  0         return;
634                                                      }
635   ***      0                                  0      my $sql = 'SELECT DATABASE()';
636   ***      0                                  0      MKDEBUG && _d($sql);
637   ***      0                                  0      my $curr = $dbh->selectrow_array($sql);
638   ***      0      0      0                    0      if ( $curr && $new && $curr eq $new ) {
      ***                    0                        
639   ***      0                                  0         MKDEBUG && _d('Current and new DB are the same');
640   ***      0                                  0         return $curr;
641                                                      }
642   ***      0                                  0      $sql = 'USE ' . $quoter->quote($new);
643   ***      0                                  0      MKDEBUG && _d($sql);
644   ***      0                                  0      $dbh->do($sql);
645   ***      0                                  0      return $curr;
646                                                   }
647                                                   
648                                                   sub get_create_table {
649   ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
650   ***      0      0      0                    0      if ( !$self->{cache} || !$self->{tables}->{$db}->{$tbl} ) {
651   ***      0                                  0         my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
652                                                            . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
653                                                            . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
654                                                            . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
655   ***      0                                  0         MKDEBUG && _d($sql);
656   ***      0                                  0         eval { $dbh->do($sql); };
      ***      0                                  0   
657   ***      0                                  0         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
658   ***      0                                  0         my $curr_db = $self->_use_db($dbh, $quoter, $db);
659   ***      0                                  0         $sql = "SHOW CREATE TABLE " . $quoter->quote($db, $tbl);
660   ***      0                                  0         MKDEBUG && _d($sql);
661   ***      0                                  0         my $href;
662   ***      0                                  0         eval { $href = $dbh->selectrow_hashref($sql); };
      ***      0                                  0   
663   ***      0      0                           0         if ( $EVAL_ERROR ) {
664   ***      0                                  0            warn "Failed to $sql.  The table may be damaged.\nError: $EVAL_ERROR";
665   ***      0                                  0            return;
666                                                         }
667   ***      0                                  0         $self->_use_db($dbh, $quoter, $curr_db);
668   ***      0                                  0         $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
669                                                            . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
670   ***      0                                  0         MKDEBUG && _d($sql);
671   ***      0                                  0         $dbh->do($sql);
672   ***      0                                  0         my ($key) = grep { m/create table/i } keys %$href;
      ***      0                                  0   
673   ***      0      0                           0         if ( $key ) {
674   ***      0                                  0            MKDEBUG && _d('This table is a base table');
675   ***      0                                  0            $self->{tables}->{$db}->{$tbl} = [ 'table', $href->{$key} ];
676                                                         }
677                                                         else {
678   ***      0                                  0            MKDEBUG && _d('This table is a view');
679   ***      0                                  0            ($key) = grep { m/create view/i } keys %$href;
      ***      0                                  0   
680   ***      0                                  0            $self->{tables}->{$db}->{$tbl} = [ 'view', $href->{$key} ];
681                                                         }
682                                                      }
683   ***      0                                  0      return $self->{tables}->{$db}->{$tbl};
684                                                   }
685                                                   
686                                                   sub get_columns {
687   ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
688   ***      0                                  0      MKDEBUG && _d('Get columns for', $db, $tbl);
689   ***      0      0      0                    0      if ( !$self->{cache} || !$self->{columns}->{$db}->{$tbl} ) {
690   ***      0                                  0         my $curr_db = $self->_use_db($dbh, $quoter, $db);
691   ***      0                                  0         my $sql = "SHOW COLUMNS FROM " . $quoter->quote($db, $tbl);
692   ***      0                                  0         MKDEBUG && _d($sql);
693   ***      0                                  0         my $cols = $dbh->selectall_arrayref($sql, { Slice => {} });
694   ***      0                                  0         $self->_use_db($dbh, $quoter, $curr_db);
695   ***      0                                  0         $self->{columns}->{$db}->{$tbl} = [
696                                                            map {
697   ***      0                                  0               my %row;
698   ***      0                                  0               @row{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
699   ***      0                                  0               \%row;
700                                                            } @$cols
701                                                         ];
702                                                      }
703   ***      0                                  0      return $self->{columns}->{$db}->{$tbl};
704                                                   }
705                                                   
706                                                   sub get_tmp_table {
707   ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
708   ***      0                                  0      my $result = 'CREATE TABLE ' . $quoter->quote($tbl) . " (\n";
709   ***      0                                  0      $result .= join(",\n",
710   ***      0                                  0         map { '  ' . $quoter->quote($_->{field}) . ' ' . $_->{type} }
711   ***      0                                  0         @{$self->get_columns($dbh, $quoter, $db, $tbl)});
712   ***      0                                  0      $result .= "\n)";
713   ***      0                                  0      MKDEBUG && _d($result);
714   ***      0                                  0      return $result;
715                                                   }
716                                                   
717                                                   sub get_triggers {
718   ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
719   ***      0      0      0                    0      if ( !$self->{cache} || !$self->{triggers}->{$db} ) {
720   ***      0                                  0         $self->{triggers}->{$db} = {};
721   ***      0                                  0         my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
722                                                            . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
723                                                            . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
724                                                            . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
725   ***      0                                  0         MKDEBUG && _d($sql);
726   ***      0                                  0         eval { $dbh->do($sql); };
      ***      0                                  0   
727   ***      0                                  0         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
728   ***      0                                  0         $sql = "SHOW TRIGGERS FROM " . $quoter->quote($db);
729   ***      0                                  0         MKDEBUG && _d($sql);
730   ***      0                                  0         my $sth = $dbh->prepare($sql);
731   ***      0                                  0         $sth->execute();
732   ***      0      0                           0         if ( $sth->rows ) {
733   ***      0                                  0            my $trgs = $sth->fetchall_arrayref({});
734   ***      0                                  0            foreach my $trg (@$trgs) {
735   ***      0                                  0               my %trg;
736   ***      0                                  0               @trg{ map { lc $_ } keys %$trg } = values %$trg;
      ***      0                                  0   
737   ***      0                                  0               push @{ $self->{triggers}->{$db}->{ $trg{table} } }, \%trg;
      ***      0                                  0   
738                                                            }
739                                                         }
740   ***      0                                  0         $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
741                                                            . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
742   ***      0                                  0         MKDEBUG && _d($sql);
743   ***      0                                  0         $dbh->do($sql);
744                                                      }
745   ***      0      0                           0      if ( $tbl ) {
746   ***      0                                  0         return $self->{triggers}->{$db}->{$tbl};
747                                                      }
748   ***      0                                  0      return values %{$self->{triggers}->{$db}};
      ***      0                                  0   
749                                                   }
750                                                   
751                                                   sub get_databases {
752   ***      0                    0             0      my ( $self, $dbh, $quoter, $like ) = @_;
753   ***      0      0      0                    0      if ( !$self->{cache} || !$self->{databases} || $like ) {
      ***                    0                        
754   ***      0                                  0         my $sql = 'SHOW DATABASES';
755   ***      0                                  0         my @params;
756   ***      0      0                           0         if ( $like ) {
757   ***      0                                  0            $sql .= ' LIKE ?';
758   ***      0                                  0            push @params, $like;
759                                                         }
760   ***      0                                  0         my $sth = $dbh->prepare($sql);
761   ***      0                                  0         MKDEBUG && _d($sql, @params);
762   ***      0                                  0         $sth->execute( @params );
763   ***      0                                  0         my @dbs = map { $_->[0] } @{$sth->fetchall_arrayref()};
      ***      0                                  0   
      ***      0                                  0   
764   ***      0      0                           0         $self->{databases} = \@dbs unless $like;
765   ***      0                                  0         return @dbs;
766                                                      }
767   ***      0                                  0      return @{$self->{databases}};
      ***      0                                  0   
768                                                   }
769                                                   
770                                                   sub get_table_status {
771   ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $like ) = @_;
772   ***      0      0      0                    0      if ( !$self->{cache} || !$self->{table_status}->{$db} || $like ) {
      ***                    0                        
773   ***      0                                  0         my $sql = "SHOW TABLE STATUS FROM " . $quoter->quote($db);
774   ***      0                                  0         my @params;
775   ***      0      0                           0         if ( $like ) {
776   ***      0                                  0            $sql .= ' LIKE ?';
777   ***      0                                  0            push @params, $like;
778                                                         }
779   ***      0                                  0         MKDEBUG && _d($sql, @params);
780   ***      0                                  0         my $sth = $dbh->prepare($sql);
781   ***      0                                  0         $sth->execute(@params);
782   ***      0                                  0         my @tables = @{$sth->fetchall_arrayref({})};
      ***      0                                  0   
783   ***      0                                  0         @tables = map {
784   ***      0                                  0            my %tbl; # Make a copy with lowercased keys
785   ***      0                                  0            @tbl{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
786   ***      0             0                    0            $tbl{engine} ||= $tbl{type} || $tbl{comment};
      ***                    0                        
787   ***      0                                  0            delete $tbl{type};
788   ***      0                                  0            \%tbl;
789                                                         } @tables;
790   ***      0      0                           0         $self->{table_status}->{$db} = \@tables unless $like;
791   ***      0                                  0         return @tables;
792                                                      }
793   ***      0                                  0      return @{$self->{table_status}->{$db}};
      ***      0                                  0   
794                                                   }
795                                                   
796                                                   sub get_table_list {
797   ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $like ) = @_;
798   ***      0      0      0                    0      if ( !$self->{cache} || !$self->{table_list}->{$db} || $like ) {
      ***                    0                        
799   ***      0                                  0         my $sql = "SHOW /*!50002 FULL*/ TABLES FROM " . $quoter->quote($db);
800   ***      0                                  0         my @params;
801   ***      0      0                           0         if ( $like ) {
802   ***      0                                  0            $sql .= ' LIKE ?';
803   ***      0                                  0            push @params, $like;
804                                                         }
805   ***      0                                  0         MKDEBUG && _d($sql, @params);
806   ***      0                                  0         my $sth = $dbh->prepare($sql);
807   ***      0                                  0         $sth->execute(@params);
808   ***      0                                  0         my @tables = @{$sth->fetchall_arrayref()};
      ***      0                                  0   
809   ***      0      0      0                    0         @tables = map {
810   ***      0                                  0            my %tbl = (
811                                                               name   => $_->[0],
812                                                               engine => ($_->[1] || '') eq 'VIEW' ? 'VIEW' : '',
813                                                            );
814   ***      0                                  0            \%tbl;
815                                                         } @tables;
816   ***      0      0                           0         $self->{table_list}->{$db} = \@tables unless $like;
817   ***      0                                  0         return @tables;
818                                                      }
819   ***      0                                  0      return @{$self->{table_list}->{$db}};
      ***      0                                  0   
820                                                   }
821                                                   
822                                                   sub _d {
823   ***      0                    0             0      my ($package, undef, $line) = caller 0;
824   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
825   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
826                                                           @_;
827   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
828                                                   }
829                                                   
830                                                   1;
831                                                   
832                                                   # ###########################################################################
833                                                   # End MySQLDump package
834                                                   # ###########################################################################
835                                                   
836                                                   # ###########################################################################
837                                                   # MySQLFind package 5266
838                                                   # ###########################################################################
839                                                   package MySQLFind;
840                                                   
841            6                    6            48   use strict;
               6                                 16   
               6                                 59   
842            6                    6            37   use warnings FATAL => 'all';
               6                                 14   
               6                                 31   
843                                                   
844            6                    6            36   use English qw(-no_match_vars);
               6                                 19   
               6                                 31   
845            6                    6            42   use Data::Dumper;
               6                                 20   
               6                                 34   
846                                                   $Data::Dumper::Indent    = 0;
847                                                   $Data::Dumper::Quotekeys = 0;
848                                                   
849   ***      6            50      6            54   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 16   
               6                                133   
850                                                   
851                                                   
852                                                   sub new {
853   ***      0                    0             0      my ( $class, %args ) = @_;
854   ***      0                                  0      foreach my $arg ( qw(dumper quoter) ) {
855   ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
856                                                      }
857   ***      0      0                           0      die "Do not pass me a dbh argument" if $args{dbh};
858   ***      0                                  0      my $self = bless \%args, $class;
859   ***      0      0      0                    0      $self->{need_engine}
      ***                    0                        
860                                                         = (   $self->{engines}->{permit}
861                                                            || $self->{engines}->{reject}
862                                                            || $self->{engines}->{regexp} ? 1 : 0);
863   ***      0      0      0                    0      die "I need a parser argument"
864                                                         if $self->{need_engine} && !defined $args{parser};
865   ***      0                                  0      MKDEBUG && _d('Need engine:', $self->{need_engine} ? 'yes' : 'no');
866   ***      0      0                           0      $self->{engines}->{views} = 1  unless defined $self->{engines}->{views};
867   ***      0      0                           0      $self->{tables}->{status} = [] unless defined $self->{tables}->{status};
868   ***      0      0                           0      if ( $args{useddl} ) {
869   ***      0                                  0         MKDEBUG && _d('Will prefer DDL');
870                                                      }
871   ***      0                                  0      return $self;
872                                                   }
873                                                   
874                                                   sub init_timestamp {
875   ***      0                    0             0      my ( $self, $dbh ) = @_;
876   ***      0      0                           0      return if $self->{timestamp}->{$dbh}->{now};
877   ***      0                                  0      my $sql = 'SELECT CURRENT_TIMESTAMP';
878   ***      0                                  0      MKDEBUG && _d($sql);
879   ***      0                                  0      ($self->{timestamp}->{$dbh}->{now}) = $dbh->selectrow_array($sql);
880   ***      0                                  0      MKDEBUG && _d('Current timestamp:', $self->{timestamp}->{$dbh}->{now});
881                                                   }
882                                                   
883                                                   sub find_databases {
884   ***      0                    0             0      my ( $self, $dbh ) = @_;
885   ***      0                                  0      return grep {
886                                                         $_ !~ m/^(information_schema|lost\+found)$/i
887   ***      0                    0             0      }  $self->_filter('databases', sub { $_[0] },
888   ***      0                                  0            $self->{dumper}->get_databases(
889                                                               $dbh,
890                                                               $self->{quoter},
891                                                               $self->{databases}->{like}));
892                                                   }
893                                                   
894                                                   sub find_tables {
895   ***      0                    0             0      my ( $self, $dbh, %args ) = @_; 
896                                                   
897                                                      my @tables
898   ***      0                    0             0         = $self->_filter('tables', sub { $_[0]->{name} },
899   ***      0                                  0            $self->_fetch_tbl_list($dbh, %args));
900                                                   
901   ***      0                                  0      my %broken_table;
902                                                   
903   ***      0      0                           0      if ( $self->{need_engine} ) {
904   ***      0                                  0         foreach my $tbl ( @tables ) {
905   ***      0      0                           0            next if $tbl->{engine};
906   ***      0                                  0            my ( $tbl_name ) = $tbl->{name} =~ m/\.(.+)$/;
907   ***      0                                  0            my $struct = $self->{parser}->parse(
908                                                               $self->{dumper}->get_create_table(
909                                                                  $dbh, $self->{quoter}, $args{database}, $tbl_name));
910   ***      0      0                           0            $broken_table{$tbl_name} = 1 unless $struct;
911   ***      0                                  0            $tbl->{engine} = $struct->{engine};
912                                                         }
913   ***      0                    0             0         @tables = $self->_filter('engines', sub { $_[0]->{engine} }, @tables);
      ***      0                                  0   
914                                                      }
915                                                   
916   ***      0                                  0      for my $i ( 0..$#tables ) {
917   ***      0                                  0         $tables[$i]->{name} =~ s/^[^.]*\.//;
918                                                         
919   ***      0      0                           0         if ( $broken_table{$tables[$i]->{name}} ) {
920   ***      0                                  0            MKDEBUG && _d('Removing broken table:', $tables[$i]->{name});
921   ***      0                                  0            delete $tables[$i];
922                                                         }
923                                                      }
924                                                   
925   ***      0                                  0      foreach my $crit ( @{$self->{tables}->{status}} ) {
      ***      0                                  0   
926   ***      0                                  0         my ($key, $test) = %$crit;
927                                                         @tables
928   ***      0                                  0            = grep {
929   ***      0                                  0               $self->_test_date($_, $key, $test, $dbh)
930                                                            } @tables;
931                                                      }
932                                                   
933   ***      0                                  0      return map { $_->{name} } @tables;
      ***      0                                  0   
934                                                   }
935                                                   
936                                                   sub find_views {
937   ***      0                    0             0      my ( $self, $dbh, %args ) = @_;
938   ***      0                                  0      my @tables = $self->_fetch_tbl_list($dbh, %args);
939   ***      0                                  0      @tables = grep { $_->{engine} eq 'VIEW' } @tables;
      ***      0                                  0   
940   ***      0                                  0      map { $_->{name} =~ s/^[^.]*\.// } @tables; # <database>.<table> => <table> 
      ***      0                                  0   
941   ***      0                                  0      return map { $_->{name} } @tables;
      ***      0                                  0   
942                                                   }
943                                                   
944                                                   sub _use_db {
945   ***      0                    0             0      my ( $self, $dbh, $new ) = @_;
946   ***      0      0                           0      if ( !$new ) {
947   ***      0                                  0         MKDEBUG && _d('No new DB to use');
948   ***      0                                  0         return;
949                                                      }
950   ***      0                                  0      my $sql = 'SELECT DATABASE()';
951   ***      0                                  0      MKDEBUG && _d($sql);
952   ***      0                                  0      my $curr = $dbh->selectrow_array($sql);
953   ***      0      0      0                    0      if ( $curr && $new && $curr eq $new ) {
      ***                    0                        
954   ***      0                                  0         MKDEBUG && _d('Current and new DB are the same');
955   ***      0                                  0         return $curr;
956                                                      }
957   ***      0                                  0      $sql = 'USE ' . $self->{quoter}->quote($new);
958   ***      0                                  0      MKDEBUG && _d($sql);
959   ***      0                                  0      $dbh->do($sql);
960   ***      0                                  0      return $curr;
961                                                   }
962                                                   
963                                                   sub _fetch_tbl_list {
964   ***      0                    0             0      my ( $self, $dbh, %args ) = @_;
965   ***      0      0                           0      die "database is required" unless $args{database};
966                                                   
967   ***      0                                  0      my $curr_db = $self->_use_db($dbh, $args{database});
968                                                   
969   ***      0                                  0      my @tables;
970   ***      0      0                           0      if ( scalar @{$self->{tables}->{status}} ) {
      ***      0                                  0   
971   ***      0                                  0         @tables = $self->{dumper}->get_table_status(
972                                                            $dbh,
973                                                            $self->{quoter},
974                                                            $args{database},
975                                                            $self->{tables}->{like});
976                                                      }
977                                                      else {
978   ***      0                                  0         @tables = $self->{dumper}->get_table_list(
979                                                            $dbh,
980                                                            $self->{quoter},
981                                                            $args{database},
982                                                            $self->{tables}->{like});
983                                                      }
984                                                   
985   ***      0                                  0      @tables = map {
986   ***      0      0                           0         my %hash = %$_;
987   ***      0                                  0         $hash{name} = join('.', $args{database}, $hash{name});
988   ***      0                                  0         \%hash;
989                                                      }
990                                                      grep {
991   ***      0                                  0         ( $self->{engines}->{views} || ($_->{engine} ne 'VIEW') )
992                                                      } @tables;
993                                                   
994   ***      0                                  0      $self->_use_db($dbh, $curr_db);
995                                                   
996   ***      0                                  0      return @tables;
997                                                   }
998                                                   
999                                                   sub _filter {
1000  ***      0                    0             0      my ( $self, $thing, $sub, @vals ) = @_;
1001  ***      0                                  0      MKDEBUG && _d('Filtering', $thing, 'list on', Dumper($self->{$thing}));
1002  ***      0                                  0      my $permit = $self->{$thing}->{permit};
1003  ***      0                                  0      my $reject = $self->{$thing}->{reject};
1004  ***      0                                  0      my $regexp = $self->{$thing}->{regexp};
1005  ***      0                                  0      return grep {
1006  ***      0                                  0         my $val = $sub->($_);
1007  ***      0      0                           0         $val = '' unless defined $val;
1008  ***      0      0                           0         if ( $thing eq 'tables' ) {
1009  ***      0                                  0            (my $tbl = $val) =~ s/^.*\.//;
1010  ***      0      0      0                    0            ( !$reject || (!$reject->{$val} && !$reject->{$tbl}) )
      ***                    0                        
      ***                    0                        
      ***                    0                        
      ***                    0                        
      ***                    0                        
1011                                                              && ( !$permit || $permit->{$val} || $permit->{$tbl} )
1012                                                              && ( !$regexp || $val =~ m/$regexp/ )
1013                                                        }
1014                                                        else {
1015  ***      0      0      0                    0            ( !$reject || !$reject->{$val} )
      ***                    0                        
      ***                    0                        
      ***                    0                        
1016                                                              && ( !$permit || $permit->{$val} )
1017                                                              && ( !$regexp || $val =~ m/$regexp/ )
1018                                                        }
1019                                                     } @vals;
1020                                                  }
1021                                                  
1022                                                  sub _test_date {
1023  ***      0                    0             0      my ( $self, $table, $prop, $test, $dbh ) = @_;
1024  ***      0                                  0      $prop = lc $prop;
1025  ***      0      0                           0      if ( !defined $table->{$prop} ) {
1026  ***      0                                  0         MKDEBUG && _d($prop, 'is not defined');
1027  ***      0                                  0         return $self->{nullpass};
1028                                                     }
1029  ***      0                                  0      my ( $equality, $num ) = $test =~ m/^([+-])?(\d+)$/;
1030  ***      0      0                           0      die "Invalid date test $test for $prop" unless defined $num;
1031  ***      0                                  0      $self->init_timestamp($dbh);
1032  ***      0                                  0      my $sql = "SELECT DATE_SUB('$self->{timestamp}->{$dbh}->{now}', "
1033                                                             . "INTERVAL $num SECOND)";
1034  ***      0                                  0      MKDEBUG && _d($sql);
1035  ***      0             0                    0      ($self->{timestamp}->{$dbh}->{$num}) ||= $dbh->selectrow_array($sql);
1036  ***      0                                  0      my $time = $self->{timestamp}->{$dbh}->{$num};
1037  ***      0      0                           0      if ( $equality ) {
1038  ***      0             0                    0         return ($equality eq '-' && $table->{$prop} gt $time)
      ***                    0                        
      ***                    0                        
1039                                                            || ($equality eq '+' && $table->{$prop} lt $time);
1040                                                     }
1041  ***      0                                  0      return $table->{$prop} eq $time;
1042                                                  }
1043                                                  
1044                                                  sub _d {
1045  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1046  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1047  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1048                                                          @_;
1049  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1050                                                  }
1051                                                  
1052                                                  1;
1053                                                  
1054                                                  # ###########################################################################
1055                                                  # End MySQLFind package
1056                                                  # ###########################################################################
1057                                                  
1058                                                  # ###########################################################################
1059                                                  # DSNParser package 5266
1060                                                  # ###########################################################################
1061                                                  package DSNParser;
1062                                                  
1063           6                    6            46   use strict;
               6                                 16   
               6                                 32   
1064           6                    6            40   use warnings FATAL => 'all';
               6                                 15   
               6                                 30   
1065           6                    6            34   use English qw(-no_match_vars);
               6                                 18   
               6                                 32   
1066           6                    6            43   use Data::Dumper;
               6                                 13   
               6                                 32   
1067                                                  $Data::Dumper::Indent    = 0;
1068                                                  $Data::Dumper::Quotekeys = 0;
1069                                                  
1070                                                  eval {
1071                                                     require DBI;
1072                                                  };
1073                                                  my $have_dbi = $EVAL_ERROR ? 0 : 1;
1074                                                  
1075  ***      6            50      6            40   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 13   
               6                                 86   
1076                                                  
1077                                                  sub new {
1078           5                    5            28      my ( $class, @opts ) = @_;
1079           5                               2660      my $self = {
1080                                                        opts => {
1081                                                           A => {
1082                                                              desc => 'Default character set',
1083                                                              dsn  => 'charset',
1084                                                              copy => 1,
1085                                                           },
1086                                                           D => {
1087                                                              desc => 'Database to use',
1088                                                              dsn  => 'database',
1089                                                              copy => 1,
1090                                                           },
1091                                                           F => {
1092                                                              desc => 'Only read default options from the given file',
1093                                                              dsn  => 'mysql_read_default_file',
1094                                                              copy => 1,
1095                                                           },
1096                                                           h => {
1097                                                              desc => 'Connect to host',
1098                                                              dsn  => 'host',
1099                                                              copy => 1,
1100                                                           },
1101                                                           p => {
1102                                                              desc => 'Password to use when connecting',
1103                                                              dsn  => 'password',
1104                                                              copy => 1,
1105                                                           },
1106                                                           P => {
1107                                                              desc => 'Port number to use for connection',
1108                                                              dsn  => 'port',
1109                                                              copy => 1,
1110                                                           },
1111                                                           S => {
1112                                                              desc => 'Socket file to use for connection',
1113                                                              dsn  => 'mysql_socket',
1114                                                              copy => 1,
1115                                                           },
1116                                                           u => {
1117                                                              desc => 'User for login if not current user',
1118                                                              dsn  => 'user',
1119                                                              copy => 1,
1120                                                           },
1121                                                        },
1122                                                     };
1123           5                                 29      foreach my $opt ( @opts ) {
1124  ***      0                                  0         MKDEBUG && _d('Adding extra property', $opt->{key});
1125  ***      0                                  0         $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
1126                                                     }
1127           5                                 72      return bless $self, $class;
1128                                                  }
1129                                                  
1130                                                  sub prop {
1131          15                   15            73      my ( $self, $prop, $value ) = @_;
1132  ***     15     50                          82      if ( @_ > 2 ) {
1133  ***      0                                  0         MKDEBUG && _d('Setting', $prop, 'property');
1134  ***      0                                  0         $self->{$prop} = $value;
1135                                                     }
1136          15                                120      return $self->{$prop};
1137                                                  }
1138                                                  
1139                                                  sub parse {
1140           5                    5           216      my ( $self, $dsn, $prev, $defaults ) = @_;
1141  ***      5     50                          30      if ( !$dsn ) {
1142  ***      0                                  0         MKDEBUG && _d('No DSN to parse');
1143  ***      0                                  0         return;
1144                                                     }
1145           5                                 13      MKDEBUG && _d('Parsing', $dsn);
1146  ***      5            50                   27      $prev     ||= {};
1147  ***      5            50                   22      $defaults ||= {};
1148           5                                 15      my %given_props;
1149           5                                 13      my %final_props;
1150           5                                 14      my %opts = %{$self->{opts}};
               5                                 47   
1151                                                  
1152           5                                 44      foreach my $dsn_part ( split(/,/, $dsn) ) {
1153  ***     20     50                         184         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
1154          20                                 91            $given_props{$prop_key} = $prop_val;
1155                                                        }
1156                                                        else {
1157  ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
1158  ***      0                                  0            $given_props{h} = $dsn_part;
1159                                                        }
1160                                                     }
1161                                                  
1162           5                                 29      foreach my $key ( keys %opts ) {
1163          40                                 85         MKDEBUG && _d('Finding value for', $key);
1164          40                                135         $final_props{$key} = $given_props{$key};
1165  ***     40     50     66                  318         if (   !defined $final_props{$key}
      ***                   33                        
1166                                                             && defined $prev->{$key} && $opts{$key}->{copy} )
1167                                                        {
1168  ***      0                                  0            $final_props{$key} = $prev->{$key};
1169  ***      0                                  0            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
1170                                                        }
1171          40    100                         172         if ( !defined $final_props{$key} ) {
1172          20                                 63            $final_props{$key} = $defaults->{$key};
1173          20                                 54            MKDEBUG && _d('Copying value for', $key, 'from defaults');
1174                                                        }
1175                                                     }
1176                                                  
1177           5                                 27      foreach my $key ( keys %given_props ) {
1178  ***     20     50                          91         die "Unrecognized DSN part '$key' in '$dsn'\n"
1179                                                           unless exists $opts{$key};
1180                                                     }
1181  ***      5     50                          28      if ( (my $required = $self->prop('required')) ) {
1182  ***      0                                  0         foreach my $key ( keys %$required ) {
1183  ***      0      0                           0            die "Missing DSN part '$key' in '$dsn'\n" unless $final_props{$key};
1184                                                        }
1185                                                     }
1186                                                  
1187           5                                 35      return \%final_props;
1188                                                  }
1189                                                  
1190                                                  sub parse_options {
1191  ***      0                    0             0      my ( $self, $o ) = @_;
1192  ***      0      0                           0      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
1193  ***      0                                  0      my $dsn_string
1194                                                        = join(',',
1195  ***      0      0                           0             map  { "$_=".$o->get($_); }
1196  ***      0                                  0             grep { $o->has($_) && $o->get($_) }
1197  ***      0                                  0             keys %{$self->{opts}}
1198                                                          );
1199  ***      0                                  0      MKDEBUG && _d('DSN string made from options:', $dsn_string);
1200  ***      0                                  0      return $self->parse($dsn_string);
1201                                                  }
1202                                                  
1203                                                  sub as_string {
1204  ***      0                    0             0      my ( $self, $dsn ) = @_;
1205  ***      0      0                           0      return $dsn unless ref $dsn;
1206  ***      0      0                           0      return join(',',
1207  ***      0      0                           0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
1208  ***      0                                  0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
1209                                                        sort keys %$dsn );
1210                                                  }
1211                                                  
1212                                                  sub usage {
1213  ***      0                    0             0      my ( $self ) = @_;
1214  ***      0                                  0      my $usage
1215                                                        = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
1216                                                        . "  KEY  COPY  MEANING\n"
1217                                                        . "  ===  ====  =============================================\n";
1218  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1219  ***      0                                  0      foreach my $key ( sort keys %opts ) {
1220  ***      0      0      0                    0         $usage .= "  $key    "
1221                                                               .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
1222                                                               .  ($opts{$key}->{desc} || '[No description]')
1223                                                               . "\n";
1224                                                     }
1225  ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
1226  ***      0                                  0      return $usage;
1227                                                  }
1228                                                  
1229                                                  sub get_cxn_params {
1230           5                    5            69      my ( $self, $info ) = @_;
1231           5                                 14      my $dsn;
1232           5                                 16      my %opts = %{$self->{opts}};
               5                                 42   
1233  ***      5            50                   25      my $driver = $self->prop('dbidriver') || '';
1234  ***      5     50                          26      if ( $driver eq 'Pg' ) {
1235  ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
1236  ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1237  ***      0             0                    0                        grep { defined $info->{$_} }
1238                                                                       qw(h P));
1239                                                     }
1240                                                     else {
1241          10                                 73         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
1242          25                                 96            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1243  ***      5            50                   68                        grep { defined $info->{$_} }
1244                                                                       qw(F h P S A))
1245                                                           . ';mysql_read_default_group=client';
1246                                                     }
1247           5                                 17      MKDEBUG && _d($dsn);
1248           5                                 43      return ($dsn, $info->{u}, $info->{p});
1249                                                  }
1250                                                  
1251                                                  sub fill_in_dsn {
1252  ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
1253  ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
1254  ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
1255  ***      0                                  0      $user =~ s/@.*//;
1256  ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
1257  ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
1258  ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
1259  ***      0             0                    0      $dsn->{u} ||= $user;
1260  ***      0             0                    0      $dsn->{D} ||= $db;
1261                                                  }
1262                                                  
1263                                                  sub get_dbh {
1264           5                    5            31      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
1265  ***      5            50                   26      $opts ||= {};
1266  ***      5     50                          48      my $defaults = {
1267                                                        AutoCommit         => 0,
1268                                                        RaiseError         => 1,
1269                                                        PrintError         => 0,
1270                                                        ShowErrorStatement => 1,
1271                                                        mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
1272                                                     };
1273           5                                 25      @{$defaults}{ keys %$opts } = values %$opts;
               5                                 22   
1274                                                  
1275  ***      5     50                          23      if ( !$have_dbi ) {
1276  ***      0                                  0         die "Cannot connect to MySQL because the Perl DBI module is not "
1277                                                           . "installed or not found.  Run 'perl -MDBI' to see the directories "
1278                                                           . "that Perl searches for DBI.  If DBI is not installed, try:\n"
1279                                                           . "  Debian/Ubuntu  apt-get install libdbi-perl\n"
1280                                                           . "  RHEL/CentOS    yum install perl-DBI\n"
1281                                                           . "  OpenSolaris    pgk install pkg:/SUNWpmdbi\n";
1282                                                  
1283                                                     }
1284                                                  
1285           5                                 15      my $dbh;
1286           5                                 16      my $tries = 2;
1287  ***      5            66                   55      while ( !$dbh && $tries-- ) {
1288                                                        MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
1289           5                                 10            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
1290                                                  
1291           5                                 16         eval {
1292           5                                 33            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
1293                                                  
1294  ***      5     50                          57            if ( $cxn_string =~ m/mysql/i ) {
1295           5                                 17               my $sql;
1296                                                  
1297           5                                 19               $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
1298                                                                   . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
1299           5                                 12               MKDEBUG && _d($dbh, ':', $sql);
1300           5                                633               $dbh->do($sql);
1301                                                  
1302  ***      5     50                          42               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
1303  ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
1304  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1305  ***      0                                  0                  $dbh->do($sql);
1306  ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
1307  ***      0      0                           0                  if ( $charset eq 'utf8' ) {
1308  ***      0      0                           0                     binmode(STDOUT, ':utf8')
1309                                                                       or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
1310                                                                 }
1311                                                                 else {
1312  ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
1313                                                                 }
1314                                                              }
1315                                                  
1316  ***      5     50                          34               if ( $self->prop('set-vars') ) {
1317  ***      0                                  0                  $sql = "SET " . $self->prop('set-vars');
1318  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1319  ***      0                                  0                  $dbh->do($sql);
1320                                                              }
1321                                                           }
1322                                                        };
1323  ***      5     50     33                   72         if ( !$dbh && $EVAL_ERROR ) {
1324  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
1325  ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
      ***             0                               
1326  ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
1327  ***      0                                  0               delete $defaults->{mysql_enable_utf8};
1328                                                           }
1329                                                           elsif ( $EVAL_ERROR =~ m/locate DBD\/mysql/i ) {
1330  ***      0                                  0               die "Cannot connect to MySQL because the Perl DBD::mysql module is "
1331                                                                 . "not installed or not found.  Run 'perl -MDBD::mysql' to see "
1332                                                                 . "the directories that Perl searches for DBD::mysql.  If "
1333                                                                 . "DBD::mysql is not installed, try:\n"
1334                                                                 . "  Debian/Ubuntu  apt-get install libdbd-mysql-perl\n"
1335                                                                 . "  RHEL/CentOS    yum install perl-DBD-MySQL\n"
1336                                                                 . "  OpenSolaris    pgk install pkg:/SUNWapu13dbd-mysql\n";
1337                                                           }
1338  ***      0      0                           0            if ( !$tries ) {
1339  ***      0                                  0               die $EVAL_ERROR;
1340                                                           }
1341                                                        }
1342                                                     }
1343                                                  
1344           5                                 13      MKDEBUG && _d('DBH info: ',
1345                                                        $dbh,
1346                                                        Dumper($dbh->selectrow_hashref(
1347                                                           'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
1348                                                        'Connection info:',      $dbh->{mysql_hostinfo},
1349                                                        'Character set info:',   Dumper($dbh->selectall_arrayref(
1350                                                                       'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
1351                                                        '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
1352                                                        '$DBI::VERSION:',        $DBI::VERSION,
1353                                                     );
1354                                                  
1355           5                                 40      return $dbh;
1356                                                  }
1357                                                  
1358                                                  sub get_hostname {
1359  ***      0                    0                    my ( $self, $dbh ) = @_;
1360  ***      0      0      0                           if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
1361  ***      0                                            return $host;
1362                                                     }
1363  ***      0                                         my ( $hostname, $one ) = $dbh->selectrow_array(
1364                                                        'SELECT /*!50038 @@hostname, */ 1');
1365  ***      0                                         return $hostname;
1366                                                  }
1367                                                  
1368                                                  sub disconnect {
1369  ***      0                    0                    my ( $self, $dbh ) = @_;
1370  ***      0                                         MKDEBUG && $self->print_active_handles($dbh);
1371  ***      0                                         $dbh->disconnect;
1372                                                  }
1373                                                  
1374                                                  sub print_active_handles {
1375  ***      0                    0                    my ( $self, $thing, $level ) = @_;
1376  ***      0             0                           $level ||= 0;
1377  ***      0      0      0                           printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
1378                                                        $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
1379                                                        or die "Cannot print: $OS_ERROR";
1380  ***      0                                         foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                      
      ***      0                                      
1381  ***      0                                            $self->print_active_handles( $handle, $level + 1 );
1382                                                     }
1383                                                  }
1384                                                  
1385                                                  sub copy {
1386  ***      0                    0                    my ( $self, $dsn_1, $dsn_2, %args ) = @_;
1387  ***      0      0                                  die 'I need a dsn_1 argument' unless $dsn_1;
1388  ***      0      0                                  die 'I need a dsn_2 argument' unless $dsn_2;
1389  ***      0                                         my %new_dsn = map {
1390  ***      0                                            my $key = $_;
1391  ***      0                                            my $val;
1392  ***      0      0                                     if ( $args{overwrite} ) {
1393  ***      0      0                                        $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
1394                                                        }
1395                                                        else {
1396  ***      0      0                                        $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
1397                                                        }
1398  ***      0                                            $key => $val;
1399  ***      0                                         } keys %{$self->{opts}};
1400  ***      0                                         return \%new_dsn;
1401                                                  }
1402                                                  
1403                                                  sub _d {
1404  ***      0                    0                    my ($package, undef, $line) = caller 0;
1405  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
1406  ***      0                                              map { defined $_ ? $_ : 'undef' }
1407                                                          @_;
1408  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1409                                                  }
1410                                                  
1411                                                  1;
1412                                                  
1413                                                  # ###########################################################################
1414                                                  # End DSNParser package
1415                                                  # ###########################################################################
1416                                                  
1417                                                  # ###########################################################################
1418                                                  # OptionParser package 5266
1419                                                  # ###########################################################################
1420                                                  package OptionParser;
1421                                                  
1422           6                    6            48   use strict;
               6                                 16   
               6                                 37   
1423           6                    6            43   use warnings FATAL => 'all';
               6                                 17   
               6                                 34   
1424                                                  
1425           6                    6            71   use Getopt::Long;
               6                                 20   
               6                                 40   
1426           6                    6            44   use List::Util qw(max);
               6                                 13   
               6                                 72   
1427           6                    6            36   use English qw(-no_match_vars);
               6                                 14   
               6                                 37   
1428                                                  
1429  ***      6            50      6            79   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 16   
               6                                 90   
1430                                                  
1431                                                  my $POD_link_re = '[LC]<"?([^">]+)"?>';
1432                                                  
1433                                                  my %attributes = (
1434                                                     'type'       => 1,
1435                                                     'short form' => 1,
1436                                                     'group'      => 1,
1437                                                     'default'    => 1,
1438                                                     'cumulative' => 1,
1439                                                     'negatable'  => 1,
1440                                                  );
1441                                                  
1442                                                  sub new {
1443  ***      0                    0                    my ( $class, %args ) = @_;
1444  ***      0                                         foreach my $arg ( qw(description) ) {
1445  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
1446                                                     }
1447  ***      0                                         my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
1448  ***      0             0                           $program_name ||= $PROGRAM_NAME;
1449  ***      0             0                           my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                    0                        
      ***                    0                        
1450                                                  
1451  ***      0      0      0                           my $self = {
      ***                    0                        
1452                                                        description    => $args{description},
1453                                                        prompt         => $args{prompt} || '<options>',
1454                                                        strict         => (exists $args{strict} ? $args{strict} : 1),
1455                                                        dp             => $args{dp}     || undef,
1456                                                        program_name   => $program_name,
1457                                                        opts           => {},
1458                                                        got_opts       => 0,
1459                                                        short_opts     => {},
1460                                                        defaults       => {},
1461                                                        groups         => {},
1462                                                        allowed_groups => {},
1463                                                        errors         => [],
1464                                                        rules          => [],  # desc of rules for --help
1465                                                        mutex          => [],  # rule: opts are mutually exclusive
1466                                                        atleast1       => [],  # rule: at least one opt is required
1467                                                        disables       => {},  # rule: opt disables other opts 
1468                                                        defaults_to    => {},  # rule: opt defaults to value of other opt
1469                                                        default_files  => [
1470                                                           "/etc/maatkit/maatkit.conf",
1471                                                           "/etc/maatkit/$program_name.conf",
1472                                                           "$home/.maatkit.conf",
1473                                                           "$home/.$program_name.conf",
1474                                                        ],
1475                                                     };
1476  ***      0                                         return bless $self, $class;
1477                                                  }
1478                                                  
1479                                                  sub get_specs {
1480  ***      0                    0                    my ( $self, $file ) = @_;
1481  ***      0                                         my @specs = $self->_pod_to_specs($file);
1482  ***      0                                         $self->_parse_specs(@specs);
1483  ***      0                                         return;
1484                                                  }
1485                                                  
1486                                                  sub get_defaults_files {
1487  ***      0                    0                    my ( $self ) = @_;
1488  ***      0                                         return @{$self->{default_files}};
      ***      0                                      
1489                                                  }
1490                                                  
1491                                                  sub _pod_to_specs {
1492  ***      0                    0                    my ( $self, $file ) = @_;
1493  ***      0             0                           $file ||= __FILE__;
1494  ***      0      0                                  open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
1495                                                  
1496  ***      0                                         my %types = (
1497                                                        string => 's', # standard Getopt type
1498                                                        'int'  => 'i', # standard Getopt type
1499                                                        float  => 'f', # standard Getopt type
1500                                                        Hash   => 'H', # hash, formed from a comma-separated list
1501                                                        hash   => 'h', # hash as above, but only if a value is given
1502                                                        Array  => 'A', # array, similar to Hash
1503                                                        array  => 'a', # array, similar to hash
1504                                                        DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
1505                                                        size   => 'z', # size with kMG suffix (powers of 2^10)
1506                                                        'time' => 'm', # time, with an optional suffix of s/h/m/d
1507                                                     );
1508  ***      0                                         my @specs = ();
1509  ***      0                                         my @rules = ();
1510  ***      0                                         my $para;
1511                                                  
1512  ***      0                                         local $INPUT_RECORD_SEPARATOR = '';
1513  ***      0                                         while ( $para = <$fh> ) {
1514  ***      0      0                                     next unless $para =~ m/^=head1 OPTIONS/;
1515  ***      0                                            last;
1516                                                     }
1517                                                  
1518  ***      0                                         while ( $para = <$fh> ) {
1519  ***      0      0                                     last if $para =~ m/^=over/;
1520  ***      0                                            chomp $para;
1521  ***      0                                            $para =~ s/\s+/ /g;
1522  ***      0                                            $para =~ s/$POD_link_re/$1/go;
1523  ***      0                                            MKDEBUG && _d('Option rule:', $para);
1524  ***      0                                            push @rules, $para;
1525                                                     }
1526                                                  
1527  ***      0      0                                  die 'POD has no OPTIONS section' unless $para;
1528                                                  
1529  ***      0                                         do {
1530  ***      0      0                                     if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
1531  ***      0                                               chomp $para;
1532  ***      0                                               MKDEBUG && _d($para);
1533  ***      0                                               my %attribs;
1534                                                  
1535  ***      0                                               $para = <$fh>; # read next paragraph, possibly attributes
1536                                                  
1537  ***      0      0                                        if ( $para =~ m/: / ) { # attributes
1538  ***      0                                                  $para =~ s/\s+\Z//g;
1539  ***      0                                                  %attribs = map {
1540  ***      0                                                        my ( $attrib, $val) = split(/: /, $_);
1541  ***      0      0                                                 die "Unrecognized attribute for --$option: $attrib"
1542                                                                       unless $attributes{$attrib};
1543  ***      0                                                        ($attrib, $val);
1544                                                                 } split(/; /, $para);
1545  ***      0      0                                           if ( $attribs{'short form'} ) {
1546  ***      0                                                     $attribs{'short form'} =~ s/-//;
1547                                                              }
1548  ***      0                                                  $para = <$fh>; # read next paragraph, probably short help desc
1549                                                           }
1550                                                           else {
1551  ***      0                                                  MKDEBUG && _d('Option has no attributes');
1552                                                           }
1553                                                  
1554  ***      0                                               $para =~ s/\s+\Z//g;
1555  ***      0                                               $para =~ s/\s+/ /g;
1556  ***      0                                               $para =~ s/$POD_link_re/$1/go;
1557                                                  
1558  ***      0                                               $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
1559  ***      0                                               MKDEBUG && _d('Short help:', $para);
1560                                                  
1561  ***      0      0                                        die "No description after option spec $option" if $para =~ m/^=item/;
1562                                                  
1563  ***      0      0                                        if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
1564  ***      0                                                  $option = $base_option;
1565  ***      0                                                  $attribs{'negatable'} = 1;
1566                                                           }
1567                                                  
1568  ***      0      0                                        push @specs, {
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
1569                                                              spec  => $option
1570                                                                 . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
1571                                                                 . ($attribs{'negatable'}  ? '!'                          : '' )
1572                                                                 . ($attribs{'cumulative'} ? '+'                          : '' )
1573                                                                 . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
1574                                                              desc  => $para
1575                                                                 . ($attribs{default} ? " (default $attribs{default})" : ''),
1576                                                              group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
1577                                                           };
1578                                                        }
1579  ***      0                                            while ( $para = <$fh> ) {
1580  ***      0      0                                        last unless $para;
1581                                                  
1582                                                  
1583  ***      0      0                                        if ( $para =~ m/^=head1/ ) {
1584  ***      0                                                  $para = undef; # Can't 'last' out of a do {} block.
1585  ***      0                                                  last;
1586                                                           }
1587  ***      0      0                                        last if $para =~ m/^=item --/;
1588                                                        }
1589                                                     } while ( $para );
1590                                                  
1591  ***      0      0                                  die 'No valid specs in POD OPTIONS' unless @specs;
1592                                                  
1593  ***      0                                         close $fh;
1594  ***      0                                         return @specs, @rules;
1595                                                  }
1596                                                  
1597                                                  sub _parse_specs {
1598  ***      0                    0                    my ( $self, @specs ) = @_;
1599  ***      0                                         my %disables; # special rule that requires deferred checking
1600                                                  
1601  ***      0                                         foreach my $opt ( @specs ) {
1602  ***      0      0                                     if ( ref $opt ) { # It's an option spec, not a rule.
1603                                                           MKDEBUG && _d('Parsing opt spec:',
1604  ***      0                                                  map { ($_, '=>', $opt->{$_}) } keys %$opt);
1605                                                  
1606  ***      0                                               my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
1607  ***      0      0                                        if ( !$long ) {
1608  ***      0                                                  die "Cannot parse long option from spec $opt->{spec}";
1609                                                           }
1610  ***      0                                               $opt->{long} = $long;
1611                                                  
1612  ***      0      0                                        die "Duplicate long option --$long" if exists $self->{opts}->{$long};
1613  ***      0                                               $self->{opts}->{$long} = $opt;
1614                                                  
1615  ***      0      0                                        if ( length $long == 1 ) {
1616  ***      0                                                  MKDEBUG && _d('Long opt', $long, 'looks like short opt');
1617  ***      0                                                  $self->{short_opts}->{$long} = $long;
1618                                                           }
1619                                                  
1620  ***      0      0                                        if ( $short ) {
1621  ***      0      0                                           die "Duplicate short option -$short"
1622                                                                 if exists $self->{short_opts}->{$short};
1623  ***      0                                                  $self->{short_opts}->{$short} = $long;
1624  ***      0                                                  $opt->{short} = $short;
1625                                                           }
1626                                                           else {
1627  ***      0                                                  $opt->{short} = undef;
1628                                                           }
1629                                                  
1630  ***      0      0                                        $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
1631  ***      0      0                                        $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
1632  ***      0      0                                        $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
1633                                                  
1634  ***      0             0                                 $opt->{group} ||= 'default';
1635  ***      0                                               $self->{groups}->{ $opt->{group} }->{$long} = 1;
1636                                                  
1637  ***      0                                               $opt->{value} = undef;
1638  ***      0                                               $opt->{got}   = 0;
1639                                                  
1640  ***      0                                               my ( $type ) = $opt->{spec} =~ m/=(.)/;
1641  ***      0                                               $opt->{type} = $type;
1642  ***      0                                               MKDEBUG && _d($long, 'type:', $type);
1643                                                  
1644  ***      0      0      0                                 if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                    0                        
1645  ***      0                                                  die "$opt->{long} is type DSN (d) but no dp argument "
1646                                                                 . "was given when this OptionParser object was created";
1647                                                           }
1648                                                  
1649  ***      0      0      0                                 $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
1650                                                  
1651  ***      0      0                                        if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
1652  ***      0      0                                           $self->{defaults}->{$long} = defined $def ? $def : 1;
1653  ***      0                                                  MKDEBUG && _d($long, 'default:', $def);
1654                                                           }
1655                                                  
1656  ***      0      0                                        if ( $long eq 'config' ) {
1657  ***      0                                                  $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
1658                                                           }
1659                                                  
1660  ***      0      0                                        if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
1661  ***      0                                                  $disables{$long} = $dis;
1662  ***      0                                                  MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
1663                                                           }
1664                                                  
1665  ***      0                                               $self->{opts}->{$long} = $opt;
1666                                                        }
1667                                                        else { # It's an option rule, not a spec.
1668  ***      0                                               MKDEBUG && _d('Parsing rule:', $opt); 
1669  ***      0                                               push @{$self->{rules}}, $opt;
      ***      0                                      
1670  ***      0                                               my @participants = $self->_get_participants($opt);
1671  ***      0                                               my $rule_ok = 0;
1672                                                  
1673  ***      0      0                                        if ( $opt =~ m/mutually exclusive|one and only one/ ) {
1674  ***      0                                                  $rule_ok = 1;
1675  ***      0                                                  push @{$self->{mutex}}, \@participants;
      ***      0                                      
1676  ***      0                                                  MKDEBUG && _d(@participants, 'are mutually exclusive');
1677                                                           }
1678  ***      0      0                                        if ( $opt =~ m/at least one|one and only one/ ) {
1679  ***      0                                                  $rule_ok = 1;
1680  ***      0                                                  push @{$self->{atleast1}}, \@participants;
      ***      0                                      
1681  ***      0                                                  MKDEBUG && _d(@participants, 'require at least one');
1682                                                           }
1683  ***      0      0                                        if ( $opt =~ m/default to/ ) {
1684  ***      0                                                  $rule_ok = 1;
1685  ***      0                                                  $self->{defaults_to}->{$participants[0]} = $participants[1];
1686  ***      0                                                  MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
1687                                                           }
1688  ***      0      0                                        if ( $opt =~ m/restricted to option groups/ ) {
1689  ***      0                                                  $rule_ok = 1;
1690  ***      0                                                  my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
1691  ***      0                                                  my @groups = split(',', $groups);
1692  ***      0                                                  %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                      
1693  ***      0                                                     s/\s+//;
1694  ***      0                                                     $_ => 1;
1695                                                              } @groups;
1696                                                           }
1697                                                  
1698  ***      0      0                                        die "Unrecognized option rule: $opt" unless $rule_ok;
1699                                                        }
1700                                                     }
1701                                                  
1702  ***      0                                         foreach my $long ( keys %disables ) {
1703  ***      0                                            my @participants = $self->_get_participants($disables{$long});
1704  ***      0                                            $self->{disables}->{$long} = \@participants;
1705  ***      0                                            MKDEBUG && _d('Option', $long, 'disables', @participants);
1706                                                     }
1707                                                  
1708  ***      0                                         return; 
1709                                                  }
1710                                                  
1711                                                  sub _get_participants {
1712  ***      0                    0                    my ( $self, $str ) = @_;
1713  ***      0                                         my @participants;
1714  ***      0                                         foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
1715  ***      0      0                                     die "Option --$long does not exist while processing rule $str"
1716                                                           unless exists $self->{opts}->{$long};
1717  ***      0                                            push @participants, $long;
1718                                                     }
1719  ***      0                                         MKDEBUG && _d('Participants for', $str, ':', @participants);
1720  ***      0                                         return @participants;
1721                                                  }
1722                                                  
1723                                                  sub opts {
1724  ***      0                    0                    my ( $self ) = @_;
1725  ***      0                                         my %opts = %{$self->{opts}};
      ***      0                                      
1726  ***      0                                         return %opts;
1727                                                  }
1728                                                  
1729                                                  sub short_opts {
1730  ***      0                    0                    my ( $self ) = @_;
1731  ***      0                                         my %short_opts = %{$self->{short_opts}};
      ***      0                                      
1732  ***      0                                         return %short_opts;
1733                                                  }
1734                                                  
1735                                                  sub set_defaults {
1736  ***      0                    0                    my ( $self, %defaults ) = @_;
1737  ***      0                                         $self->{defaults} = {};
1738  ***      0                                         foreach my $long ( keys %defaults ) {
1739  ***      0      0                                     die "Cannot set default for nonexistent option $long"
1740                                                           unless exists $self->{opts}->{$long};
1741  ***      0                                            $self->{defaults}->{$long} = $defaults{$long};
1742  ***      0                                            MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
1743                                                     }
1744  ***      0                                         return;
1745                                                  }
1746                                                  
1747                                                  sub get_defaults {
1748  ***      0                    0                    my ( $self ) = @_;
1749  ***      0                                         return $self->{defaults};
1750                                                  }
1751                                                  
1752                                                  sub get_groups {
1753  ***      0                    0                    my ( $self ) = @_;
1754  ***      0                                         return $self->{groups};
1755                                                  }
1756                                                  
1757                                                  sub _set_option {
1758  ***      0                    0                    my ( $self, $opt, $val ) = @_;
1759  ***      0      0                                  my $long = exists $self->{opts}->{$opt}       ? $opt
      ***             0                               
1760                                                              : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
1761                                                              : die "Getopt::Long gave a nonexistent option: $opt";
1762                                                  
1763  ***      0                                         $opt = $self->{opts}->{$long};
1764  ***      0      0                                  if ( $opt->{is_cumulative} ) {
1765  ***      0                                            $opt->{value}++;
1766                                                     }
1767                                                     else {
1768  ***      0                                            $opt->{value} = $val;
1769                                                     }
1770  ***      0                                         $opt->{got} = 1;
1771  ***      0                                         MKDEBUG && _d('Got option', $long, '=', $val);
1772                                                  }
1773                                                  
1774                                                  sub get_opts {
1775  ***      0                    0                    my ( $self ) = @_; 
1776                                                  
1777  ***      0                                         foreach my $long ( keys %{$self->{opts}} ) {
      ***      0                                      
1778  ***      0                                            $self->{opts}->{$long}->{got} = 0;
1779  ***      0      0                                     $self->{opts}->{$long}->{value}
      ***             0                               
1780                                                           = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
1781                                                           : $self->{opts}->{$long}->{is_cumulative} ? 0
1782                                                           : undef;
1783                                                     }
1784  ***      0                                         $self->{got_opts} = 0;
1785                                                  
1786  ***      0                                         $self->{errors} = [];
1787                                                  
1788  ***      0      0      0                           if ( @ARGV && $ARGV[0] eq "--config" ) {
1789  ***      0                                            shift @ARGV;
1790  ***      0                                            $self->_set_option('config', shift @ARGV);
1791                                                     }
1792  ***      0      0                                  if ( $self->has('config') ) {
1793  ***      0                                            my @extra_args;
1794  ***      0                                            foreach my $filename ( split(',', $self->get('config')) ) {
1795  ***      0                                               eval {
1796  ***      0                                                  push @extra_args, $self->_read_config_file($filename);
1797                                                           };
1798  ***      0      0                                        if ( $EVAL_ERROR ) {
1799  ***      0      0                                           if ( $self->got('config') ) {
1800  ***      0                                                     die $EVAL_ERROR;
1801                                                              }
1802                                                              elsif ( MKDEBUG ) {
1803                                                                 _d($EVAL_ERROR);
1804                                                              }
1805                                                           }
1806                                                        }
1807  ***      0                                            unshift @ARGV, @extra_args;
1808                                                     }
1809                                                  
1810  ***      0                                         Getopt::Long::Configure('no_ignore_case', 'bundling');
1811                                                     GetOptions(
1812  ***      0                    0                       map    { $_->{spec} => sub { $self->_set_option(@_); } }
      ***      0                                      
      ***      0                                      
1813  ***      0                                            grep   { $_->{long} ne 'config' } # --config is handled specially above.
1814  ***      0      0                                     values %{$self->{opts}}
1815                                                     ) or $self->save_error('Error parsing options');
1816                                                  
1817  ***      0      0      0                           if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
1818  ***      0      0                                     printf("%s  Ver %s Distrib %s Changeset %s\n",
1819                                                           $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
1820                                                              or die "Cannot print: $OS_ERROR";
1821  ***      0                                            exit 0;
1822                                                     }
1823                                                  
1824  ***      0      0      0                           if ( @ARGV && $self->{strict} ) {
1825  ***      0                                            $self->save_error("Unrecognized command-line options @ARGV");
1826                                                     }
1827                                                  
1828  ***      0                                         foreach my $mutex ( @{$self->{mutex}} ) {
      ***      0                                      
1829  ***      0                                            my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                      
1830  ***      0      0                                     if ( @set > 1 ) {
1831  ***      0                                               my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                      
1832  ***      0                                                            @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
1833                                                                   . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
1834                                                                   . ' are mutually exclusive.';
1835  ***      0                                               $self->save_error($err);
1836                                                        }
1837                                                     }
1838                                                  
1839  ***      0                                         foreach my $required ( @{$self->{atleast1}} ) {
      ***      0                                      
1840  ***      0                                            my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                      
1841  ***      0      0                                     if ( @set == 0 ) {
1842  ***      0                                               my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                      
1843  ***      0                                                            @{$required}[ 0 .. scalar(@$required) - 2] )
1844                                                                   .' or --'.$self->{opts}->{$required->[-1]}->{long};
1845  ***      0                                               $self->save_error("Specify at least one of $err");
1846                                                        }
1847                                                     }
1848                                                  
1849  ***      0                                         foreach my $long ( keys %{$self->{opts}} ) {
      ***      0                                      
1850  ***      0                                            my $opt = $self->{opts}->{$long};
1851  ***      0      0                                     if ( $opt->{got} ) {
      ***             0                               
1852  ***      0      0                                        if ( exists $self->{disables}->{$long} ) {
1853  ***      0                                                  my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                      
1854  ***      0                                                  map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                      
1855  ***      0                                                  MKDEBUG && _d('Unset options', @disable_opts,
1856                                                                 'because', $long,'disables them');
1857                                                           }
1858                                                  
1859  ***      0      0                                        if ( exists $self->{allowed_groups}->{$long} ) {
1860                                                  
1861  ***      0                                                  my @restricted_groups = grep {
1862  ***      0                                                     !exists $self->{allowed_groups}->{$long}->{$_}
1863  ***      0                                                  } keys %{$self->{groups}};
1864                                                  
1865  ***      0                                                  my @restricted_opts;
1866  ***      0                                                  foreach my $restricted_group ( @restricted_groups ) {
1867  ***      0                                                     RESTRICTED_OPT:
1868  ***      0                                                     foreach my $restricted_opt (
1869                                                                    keys %{$self->{groups}->{$restricted_group}} )
1870                                                                 {
1871  ***      0      0                                                 next RESTRICTED_OPT if $restricted_opt eq $long;
1872  ***      0      0                                                 push @restricted_opts, $restricted_opt
1873                                                                       if $self->{opts}->{$restricted_opt}->{got};
1874                                                                 }
1875                                                              }
1876                                                  
1877  ***      0      0                                           if ( @restricted_opts ) {
1878  ***      0                                                     my $err;
1879  ***      0      0                                              if ( @restricted_opts == 1 ) {
1880  ***      0                                                        $err = "--$restricted_opts[0]";
1881                                                                 }
1882                                                                 else {
1883  ***      0                                                        $err = join(', ',
1884  ***      0                                                                  map { "--$self->{opts}->{$_}->{long}" }
1885  ***      0                                                                  grep { $_ } 
1886                                                                              @restricted_opts[0..scalar(@restricted_opts) - 2]
1887                                                                           )
1888                                                                         . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
1889                                                                 }
1890  ***      0                                                     $self->save_error("--$long is not allowed with $err");
1891                                                              }
1892                                                           }
1893                                                  
1894                                                        }
1895                                                        elsif ( $opt->{is_required} ) { 
1896  ***      0                                               $self->save_error("Required option --$long must be specified");
1897                                                        }
1898                                                  
1899  ***      0                                            $self->_validate_type($opt);
1900                                                     }
1901                                                  
1902  ***      0                                         $self->{got_opts} = 1;
1903  ***      0                                         return;
1904                                                  }
1905                                                  
1906                                                  sub _validate_type {
1907  ***      0                    0                    my ( $self, $opt ) = @_;
1908  ***      0      0      0                           return unless $opt && $opt->{type};
1909  ***      0                                         my $val = $opt->{value};
1910                                                  
1911  ***      0      0      0                           if ( $val && $opt->{type} eq 'm' ) {  # type time
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***                    0                        
      ***                    0                        
1912  ***      0                                            MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
1913  ***      0                                            my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
1914  ***      0      0                                     if ( !$suffix ) {
1915  ***      0                                               my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
1916  ***      0             0                                 $suffix = $s || 's';
1917  ***      0                                               MKDEBUG && _d('No suffix given; using', $suffix, 'for',
1918                                                              $opt->{long}, '(value:', $val, ')');
1919                                                        }
1920  ***      0      0                                     if ( $suffix =~ m/[smhd]/ ) {
1921  ***      0      0                                        $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***             0                               
1922                                                                : $suffix eq 'm' ? $num * 60       # Minutes
1923                                                                : $suffix eq 'h' ? $num * 3600     # Hours
1924                                                                :                  $num * 86400;   # Days
1925  ***      0             0                                 $opt->{value} = ($prefix || '') . $val;
1926  ***      0                                               MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
1927                                                        }
1928                                                        else {
1929  ***      0                                               $self->save_error("Invalid time suffix for --$opt->{long}");
1930                                                        }
1931                                                     }
1932                                                     elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
1933  ***      0                                            MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
1934  ***      0                                            my $prev = {};
1935  ***      0                                            my $from_key = $self->{defaults_to}->{ $opt->{long} };
1936  ***      0      0                                     if ( $from_key ) {
1937  ***      0                                               MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
1938  ***      0                                               $prev = $self->{opts}->{$from_key}->{value};
1939                                                        }
1940  ***      0                                            my $defaults = $self->{dp}->parse_options($self);
1941  ***      0                                            $opt->{value} = $self->{dp}->parse($val, $prev, $defaults);
1942                                                     }
1943                                                     elsif ( $val && $opt->{type} eq 'z' ) {  # type size
1944  ***      0                                            MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
1945  ***      0                                            my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
1946  ***      0                                            my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
1947  ***      0      0                                     if ( defined $num ) {
1948  ***      0      0                                        if ( $factor ) {
1949  ***      0                                                  $num *= $factor_for{$factor};
1950  ***      0                                                  MKDEBUG && _d('Setting option', $opt->{y},
1951                                                                 'to num', $num, '* factor', $factor);
1952                                                           }
1953  ***      0             0                                 $opt->{value} = ($pre || '') . $num;
1954                                                        }
1955                                                        else {
1956  ***      0                                               $self->save_error("Invalid size for --$opt->{long}");
1957                                                        }
1958                                                     }
1959                                                     elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
1960  ***      0             0                              $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
      ***      0                                      
1961                                                     }
1962                                                     elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
1963  ***      0             0                              $opt->{value} = [ split(/(?<!\\),/, ($val || '')) ];
1964                                                     }
1965                                                     else {
1966  ***      0                                            MKDEBUG && _d('Nothing to validate for option',
1967                                                           $opt->{long}, 'type', $opt->{type}, 'value', $val);
1968                                                     }
1969                                                  
1970  ***      0                                         return;
1971                                                  }
1972                                                  
1973                                                  sub get {
1974  ***      0                    0                    my ( $self, $opt ) = @_;
1975  ***      0      0                                  my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1976  ***      0      0      0                           die "Option $opt does not exist"
1977                                                        unless $long && exists $self->{opts}->{$long};
1978  ***      0                                         return $self->{opts}->{$long}->{value};
1979                                                  }
1980                                                  
1981                                                  sub got {
1982  ***      0                    0                    my ( $self, $opt ) = @_;
1983  ***      0      0                                  my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1984  ***      0      0      0                           die "Option $opt does not exist"
1985                                                        unless $long && exists $self->{opts}->{$long};
1986  ***      0                                         return $self->{opts}->{$long}->{got};
1987                                                  }
1988                                                  
1989                                                  sub has {
1990  ***      0                    0                    my ( $self, $opt ) = @_;
1991  ***      0      0                                  my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1992  ***      0      0                                  return defined $long ? exists $self->{opts}->{$long} : 0;
1993                                                  }
1994                                                  
1995                                                  sub set {
1996  ***      0                    0                    my ( $self, $opt, $val ) = @_;
1997  ***      0      0                                  my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1998  ***      0      0      0                           die "Option $opt does not exist"
1999                                                        unless $long && exists $self->{opts}->{$long};
2000  ***      0                                         $self->{opts}->{$long}->{value} = $val;
2001  ***      0                                         return;
2002                                                  }
2003                                                  
2004                                                  sub save_error {
2005  ***      0                    0                    my ( $self, $error ) = @_;
2006  ***      0                                         push @{$self->{errors}}, $error;
      ***      0                                      
2007                                                  }
2008                                                  
2009                                                  sub errors {
2010  ***      0                    0                    my ( $self ) = @_;
2011  ***      0                                         return $self->{errors};
2012                                                  }
2013                                                  
2014                                                  sub prompt {
2015  ***      0                    0                    my ( $self ) = @_;
2016  ***      0                                         return "Usage: $PROGRAM_NAME $self->{prompt}\n";
2017                                                  }
2018                                                  
2019                                                  sub descr {
2020  ***      0                    0                    my ( $self ) = @_;
2021  ***      0             0                           my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
2022                                                                . "  For more details, please use the --help option, "
2023                                                                . "or try 'perldoc $PROGRAM_NAME' "
2024                                                                . "for complete documentation.";
2025  ***      0                                         $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g);
2026  ***      0                                         $descr =~ s/ +$//mg;
2027  ***      0                                         return $descr;
2028                                                  }
2029                                                  
2030                                                  sub usage_or_errors {
2031  ***      0                    0                    my ( $self ) = @_;
2032  ***      0      0                                  if ( $self->{opts}->{help}->{got} ) {
      ***      0      0                               
2033  ***      0      0                                     print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
2034  ***      0                                            exit 0;
2035                                                     }
2036                                                     elsif ( scalar @{$self->{errors}} ) {
2037  ***      0      0                                     print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
2038  ***      0                                            exit 0;
2039                                                     }
2040  ***      0                                         return;
2041                                                  }
2042                                                  
2043                                                  sub print_errors {
2044  ***      0                    0                    my ( $self ) = @_;
2045  ***      0                                         my $usage = $self->prompt() . "\n";
2046  ***      0      0                                  if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                      
2047  ***      0                                            $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
2048                                                                . "\n";
2049                                                     }
2050  ***      0                                         return $usage . "\n" . $self->descr();
2051                                                  }
2052                                                  
2053                                                  sub print_usage {
2054  ***      0                    0                    my ( $self ) = @_;
2055  ***      0      0                                  die "Run get_opts() before print_usage()" unless $self->{got_opts};
2056  ***      0                                         my @opts = values %{$self->{opts}};
      ***      0                                      
2057                                                  
2058  ***      0      0                                  my $maxl = max(
2059  ***      0                                            map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
2060                                                        @opts);
2061                                                  
2062  ***      0      0                                  my $maxs = max(0,
2063  ***      0                                            map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
2064  ***      0                                            values %{$self->{short_opts}});
2065                                                  
2066  ***      0                                         my $lcol = max($maxl, ($maxs + 3));
2067  ***      0                                         my $rcol = 80 - $lcol - 6;
2068  ***      0                                         my $rpad = ' ' x ( 80 - $rcol );
2069                                                  
2070  ***      0                                         $maxs = max($lcol - 3, $maxs);
2071                                                  
2072  ***      0                                         my $usage = $self->descr() . "\n" . $self->prompt();
2073                                                  
2074  ***      0                                         my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                      
      ***      0                                      
2075  ***      0                                         push @groups, 'default';
2076                                                  
2077  ***      0                                         foreach my $group ( reverse @groups ) {
2078  ***      0      0                                     $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
2079  ***      0                                            foreach my $opt (
      ***      0                                      
2080  ***      0                                               sort { $a->{long} cmp $b->{long} }
2081                                                           grep { $_->{group} eq $group }
2082                                                           @opts )
2083                                                        {
2084  ***      0      0                                        my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
2085  ***      0                                               my $short = $opt->{short};
2086  ***      0                                               my $desc  = $opt->{desc};
2087  ***      0      0      0                                 if ( $opt->{type} && $opt->{type} eq 'm' ) {
2088  ***      0                                                  my ($s) = $desc =~ m/\(suffix (.)\)/;
2089  ***      0             0                                    $s    ||= 's';
2090  ***      0                                                  $desc =~ s/\s+\(suffix .\)//;
2091  ***      0                                                  $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
2092                                                                     . "d=days; if no suffix, $s is used.";
2093                                                           }
2094  ***      0                                               $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                      
2095  ***      0                                               $desc =~ s/ +$//mg;
2096  ***      0      0                                        if ( $short ) {
2097  ***      0                                                  $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
2098                                                           }
2099                                                           else {
2100  ***      0                                                  $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
2101                                                           }
2102                                                        }
2103                                                     }
2104                                                  
2105  ***      0      0                                  if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                      
2106  ***      0                                            $usage .= "\nRules:\n\n";
2107  ***      0                                            $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                      
2108                                                     }
2109  ***      0      0                                  if ( $self->{dp} ) {
2110  ***      0                                            $usage .= "\n" . $self->{dp}->usage();
2111                                                     }
2112  ***      0                                         $usage .= "\nOptions and values after processing arguments:\n\n";
2113  ***      0                                         foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                      
2114  ***      0                                            my $val   = $opt->{value};
2115  ***      0             0                              my $type  = $opt->{type} || '';
2116  ***      0                                            my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
2117  ***      0      0                                     $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
2118                                                                  : !defined $val             ? '(No value)'
2119                                                                  : $type eq 'd'              ? $self->{dp}->as_string($val)
2120                                                                  : $type =~ m/H|h/           ? join(',', sort keys %$val)
2121                                                                  : $type =~ m/A|a/           ? join(',', @$val)
2122                                                                  :                             $val;
2123  ***      0                                            $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
2124                                                     }
2125  ***      0                                         return $usage;
2126                                                  }
2127                                                  
2128                                                  sub prompt_noecho {
2129  ***      0      0             0                    shift @_ if ref $_[0] eq __PACKAGE__;
2130  ***      0                                         my ( $prompt ) = @_;
2131  ***      0                                         local $OUTPUT_AUTOFLUSH = 1;
2132  ***      0      0                                  print $prompt
2133                                                        or die "Cannot print: $OS_ERROR";
2134  ***      0                                         my $response;
2135  ***      0                                         eval {
2136  ***      0                                            require Term::ReadKey;
2137  ***      0                                            Term::ReadKey::ReadMode('noecho');
2138  ***      0                                            chomp($response = <STDIN>);
2139  ***      0                                            Term::ReadKey::ReadMode('normal');
2140  ***      0      0                                     print "\n"
2141                                                           or die "Cannot print: $OS_ERROR";
2142                                                     };
2143  ***      0      0                                  if ( $EVAL_ERROR ) {
2144  ***      0                                            die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
2145                                                     }
2146  ***      0                                         return $response;
2147                                                  }
2148                                                  
2149                                                  if ( MKDEBUG ) {
2150                                                     print '# ', $^X, ' ', $], "\n";
2151                                                     my $uname = `uname -a`;
2152                                                     if ( $uname ) {
2153                                                        $uname =~ s/\s+/ /g;
2154                                                        print "# $uname\n";
2155                                                     }
2156                                                     printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
2157                                                        $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
2158                                                        ($main::SVN_REV || ''), __LINE__);
2159                                                     print('# Arguments: ',
2160                                                        join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
2161                                                  }
2162                                                  
2163                                                  sub _read_config_file {
2164  ***      0                    0                    my ( $self, $filename ) = @_;
2165  ***      0      0                                  open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
2166  ***      0                                         my @args;
2167  ***      0                                         my $prefix = '--';
2168  ***      0                                         my $parse  = 1;
2169                                                  
2170                                                     LINE:
2171  ***      0                                         while ( my $line = <$fh> ) {
2172  ***      0                                            chomp $line;
2173  ***      0      0                                     next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
2174  ***      0                                            $line =~ s/\s+#.*$//g;
2175  ***      0                                            $line =~ s/^\s+|\s+$//g;
2176  ***      0      0                                     if ( $line eq '--' ) {
2177  ***      0                                               $prefix = '';
2178  ***      0                                               $parse  = 0;
2179  ***      0                                               next LINE;
2180                                                        }
2181  ***      0      0      0                              if ( $parse
      ***             0                               
2182                                                           && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
2183                                                        ) {
2184  ***      0                                               push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                      
2185                                                        }
2186                                                        elsif ( $line =~ m/./ ) {
2187  ***      0                                               push @args, $line;
2188                                                        }
2189                                                        else {
2190  ***      0                                               die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
2191                                                        }
2192                                                     }
2193  ***      0                                         close $fh;
2194  ***      0                                         return @args;
2195                                                  }
2196                                                  
2197                                                  sub read_para_after {
2198  ***      0                    0                    my ( $self, $file, $regex ) = @_;
2199  ***      0      0                                  open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
2200  ***      0                                         local $INPUT_RECORD_SEPARATOR = '';
2201  ***      0                                         my $para;
2202  ***      0                                         while ( $para = <$fh> ) {
2203  ***      0      0                                     next unless $para =~ m/^=pod$/m;
2204  ***      0                                            last;
2205                                                     }
2206  ***      0                                         while ( $para = <$fh> ) {
2207  ***      0      0                                     next unless $para =~ m/$regex/;
2208  ***      0                                            last;
2209                                                     }
2210  ***      0                                         $para = <$fh>;
2211  ***      0                                         chomp($para);
2212  ***      0      0                                  close $fh or die "Can't close $file: $OS_ERROR";
2213  ***      0                                         return $para;
2214                                                  }
2215                                                  
2216                                                  sub clone {
2217  ***      0                    0                    my ( $self ) = @_;
2218                                                  
2219  ***      0                                         my %clone = map {
2220  ***      0                                            my $hashref  = $self->{$_};
2221  ***      0                                            my $val_copy = {};
2222  ***      0                                            foreach my $key ( keys %$hashref ) {
2223  ***      0                                               my $ref = ref $hashref->{$key};
2224  ***      0                                               $val_copy->{$key} = !$ref           ? $hashref->{$key}
2225  ***      0                                                                 : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
2226  ***      0      0                                                          : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
2227                                                                             : $hashref->{$key};
2228                                                        }
2229  ***      0                                            $_ => $val_copy;
2230                                                     } qw(opts short_opts defaults);
2231                                                  
2232  ***      0                                         foreach my $scalar ( qw(got_opts) ) {
2233  ***      0                                            $clone{$scalar} = $self->{$scalar};
2234                                                     }
2235                                                  
2236  ***      0                                         return bless \%clone;     
2237                                                  }
2238                                                  
2239                                                  sub _d {
2240  ***      0                    0                    my ($package, undef, $line) = caller 0;
2241  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
2242  ***      0                                              map { defined $_ ? $_ : 'undef' }
2243                                                          @_;
2244  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2245                                                  }
2246                                                  
2247                                                  1;
2248                                                  
2249                                                  # ###########################################################################
2250                                                  # End OptionParser package
2251                                                  # ###########################################################################
2252                                                  
2253                                                  # ###########################################################################
2254                                                  # KeySize package 5266
2255                                                  # ###########################################################################
2256                                                  package KeySize;
2257                                                  
2258           6                    6            63   use strict;
               6                                 18   
               6                                 47   
2259           6                    6            35   use warnings FATAL => 'all';
               6                                 16   
               6                                 47   
2260           6                    6            36   use English qw(-no_match_vars);
               6                                 15   
               6                                 36   
2261                                                  
2262  ***      6            50      6            41   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 20   
               6                                 88   
2263                                                  
2264                                                  sub new {
2265  ***      0                    0                    my ( $class, %args ) = @_;
2266  ***      0                                         my $self = { %args };
2267  ***      0                                         return bless $self, $class;
2268                                                  }
2269                                                  
2270                                                  sub get_key_size {
2271  ***      0                    0                    my ( $self, %args ) = @_;
2272  ***      0                                         foreach my $arg ( qw(name cols tbl_name tbl_struct dbh) ) {
2273  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
2274                                                     }
2275  ***      0                                         my $name = $args{name};
2276  ***      0                                         my @cols = @{$args{cols}};
      ***      0                                      
2277  ***      0                                         my $dbh  = $args{dbh};
2278                                                  
2279  ***      0                                         $self->{explain} = '';
2280  ***      0                                         $self->{query}   = '';
2281  ***      0                                         $self->{error}   = '';
2282                                                  
2283  ***      0      0                                  if ( @cols == 0 ) {
2284  ***      0                                            $self->{error} = "No columns for key $name";
2285  ***      0                                            return;
2286                                                     }
2287                                                  
2288  ***      0                                         my $key_exists = $self->_key_exists(%args);
2289  ***      0                                         MKDEBUG && _d('Key', $name, 'exists in', $args{tbl_name}, ':',
2290                                                        $key_exists ? 'yes': 'no');
2291                                                  
2292  ***      0      0                                  my $sql = 'EXPLAIN SELECT ' . join(', ', @cols)
2293                                                             . ' FROM ' . $args{tbl_name}
2294                                                             . ($key_exists ? " FORCE INDEX (`$name`)" : '')
2295                                                             . ' WHERE ';
2296  ***      0                                         my @where_cols;
2297  ***      0                                         foreach my $col ( @cols ) {
2298  ***      0                                            push @where_cols, "$col=1";
2299                                                     }
2300  ***      0      0                                  if ( scalar @cols == 1 ) {
2301  ***      0                                            push @where_cols, "$cols[0]<>1";
2302                                                     }
2303  ***      0                                         $sql .= join(' OR ', @where_cols);
2304  ***      0                                         $self->{query} = $sql;
2305  ***      0                                         MKDEBUG && _d('sql:', $sql);
2306                                                  
2307  ***      0                                         my $explain;
2308  ***      0                                         my $sth = $dbh->prepare($sql);
2309  ***      0                                         eval { $sth->execute(); };
      ***      0                                      
2310  ***      0      0                                  if ( $EVAL_ERROR ) {
2311  ***      0                                            chomp $EVAL_ERROR;
2312  ***      0                                            $self->{error} = "Cannot get size of $name key: $EVAL_ERROR";
2313  ***      0                                            return;
2314                                                     }
2315  ***      0                                         $explain = $sth->fetchrow_hashref();
2316                                                  
2317  ***      0                                         $self->{explain} = $explain;
2318  ***      0                                         my $key_len      = $explain->{key_len};
2319  ***      0                                         my $rows         = $explain->{rows};
2320  ***      0                                         my $chosen_key   = $explain->{key};  # May differ from $name
2321  ***      0                                         MKDEBUG && _d('MySQL chose key:', $chosen_key, 'len:', $key_len,
2322                                                        'rows:', $rows);
2323                                                  
2324  ***      0                                         my $key_size = 0;
2325  ***      0      0      0                           if ( $key_len && $rows ) {
2326  ***      0      0      0                              if ( $chosen_key =~ m/,/ && $key_len =~ m/,/ ) {
2327  ***      0                                               $self->{error} = "MySQL chose multiple keys: $chosen_key";
2328  ***      0                                               return;
2329                                                        }
2330  ***      0                                            $key_size = $key_len * $rows;
2331                                                     }
2332                                                     else {
2333  ***      0                                            $self->{error} = "key_len or rows NULL in EXPLAIN:\n"
2334                                                                       . _explain_to_text($explain);
2335  ***      0                                            return;
2336                                                     }
2337                                                  
2338  ***      0      0                                  return wantarray ? ($key_size, $chosen_key) : $key_size;
2339                                                  }
2340                                                  
2341                                                  sub query {
2342  ***      0                    0                    my ( $self ) = @_;
2343  ***      0                                         return $self->{query};
2344                                                  }
2345                                                  
2346                                                  sub explain {
2347  ***      0                    0                    my ( $self ) = @_;
2348  ***      0                                         return _explain_to_text($self->{explain});
2349                                                  }
2350                                                  
2351                                                  sub error {
2352  ***      0                    0                    my ( $self ) = @_;
2353  ***      0                                         return $self->{error};
2354                                                  }
2355                                                  
2356                                                  sub _key_exists {
2357  ***      0                    0                    my ( $self, %args ) = @_;
2358  ***      0      0                                  return exists $args{tbl_struct}->{keys}->{ lc $args{name} } ? 1 : 0;
2359                                                  }
2360                                                  
2361                                                  sub _explain_to_text {
2362  ***      0                    0                    my ( $explain ) = @_;
2363  ***      0      0                                  return join("\n",
2364  ***      0                                            map { "$_: ".($explain->{$_} ? $explain->{$_} : 'NULL') }
2365                                                        sort keys %$explain
2366                                                     );
2367                                                  }
2368                                                  
2369                                                  sub _d {
2370  ***      0                    0                    my ($package, undef, $line) = caller 0;
2371  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
2372  ***      0                                              map { defined $_ ? $_ : 'undef' }
2373                                                          @_;
2374  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2375                                                  }
2376                                                  
2377                                                  1;
2378                                                  
2379                                                  # ###########################################################################
2380                                                  # End KeySize package
2381                                                  # ###########################################################################
2382                                                  
2383                                                  # ###########################################################################
2384                                                  # DuplicateKeyFinder package 5266
2385                                                  # ###########################################################################
2386                                                  package DuplicateKeyFinder;
2387                                                  
2388           6                    6            43   use strict;
               6                                 16   
               6                                 31   
2389           6                    6            35   use warnings FATAL => 'all';
               6                                 18   
               6                                 31   
2390           6                    6            35   use English qw(-no_match_vars);
               6                                 15   
               6                                 34   
2391                                                  
2392           6                    6            41   use List::Util qw(min);
               6                                 14   
               6                                 37   
2393                                                  
2394  ***      6            50      6            39   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 15   
               6                                 79   
2395                                                  
2396                                                  sub new {
2397  ***      0                    0                    my ( $class, %args ) = @_;
2398  ***      0                                         my $self = {};
2399  ***      0                                         return bless $self, $class;
2400                                                  }
2401                                                  
2402                                                  sub get_duplicate_keys {
2403  ***      0                    0                    my ( $self, $keys,  %args ) = @_;
2404  ***      0      0                                  die "I need a keys argument" unless $keys;
2405  ***      0                                         my %keys = %$keys;  # Copy keys because we remove non-duplicates.
2406  ***      0                                         my $primary_key;
2407  ***      0                                         my @unique_keys;
2408  ***      0                                         my @normal_keys;
2409  ***      0                                         my @fulltext_keys;
2410  ***      0                                         my @dupes;
2411                                                  
2412                                                     KEY:
2413  ***      0                                         foreach my $key ( values %keys ) {
2414  ***      0                                            $key->{real_cols} = [ @{$key->{cols}} ];
      ***      0                                      
2415                                                  
2416  ***      0                                            $key->{len_cols}  = length $key->{colnames};
2417                                                  
2418  ***      0      0      0                              if ( $key->{name} eq 'PRIMARY'
      ***                    0                        
2419                                                             || ($args{clustered_key} && $key->{name} eq $args{clustered_key}) ) {
2420  ***      0                                               $primary_key = $key;
2421  ***      0                                               MKDEBUG && _d('primary key:', $key->{name});
2422  ***      0                                               next KEY;
2423                                                        }
2424                                                  
2425  ***      0      0                                     my $is_fulltext = $key->{type} eq 'FULLTEXT' ? 1 : 0;
2426  ***      0      0      0                              if ( $args{ignore_order} || $is_fulltext  ) {
2427  ***      0                                               my $ordered_cols = join(',', sort(split(/,/, $key->{colnames})));
2428  ***      0                                               MKDEBUG && _d('Reordered', $key->{name}, 'cols from',
2429                                                              $key->{colnames}, 'to', $ordered_cols); 
2430  ***      0                                               $key->{colnames} = $ordered_cols;
2431                                                        }
2432                                                  
2433  ***      0      0                                     my $push_to = $key->{is_unique} ? \@unique_keys : \@normal_keys;
2434  ***      0      0                                     if ( !$args{ignore_structure} ) {
2435  ***      0      0                                        $push_to = \@fulltext_keys if $is_fulltext;
2436                                                        }
2437  ***      0                                            push @$push_to, $key; 
2438                                                     }
2439                                                  
2440  ***      0                                         push @normal_keys, $self->unconstrain_keys($primary_key, \@unique_keys);
2441                                                  
2442  ***      0      0                                  if ( $primary_key ) {
2443  ***      0                                            MKDEBUG && _d('Comparing PRIMARY KEY to UNIQUE keys');
2444  ***      0                                            push @dupes,
2445                                                           $self->remove_prefix_duplicates([$primary_key], \@unique_keys, %args);
2446                                                  
2447  ***      0                                            MKDEBUG && _d('Comparing PRIMARY KEY to normal keys');
2448  ***      0                                            push @dupes,
2449                                                           $self->remove_prefix_duplicates([$primary_key], \@normal_keys, %args);
2450                                                     }
2451                                                  
2452  ***      0                                         MKDEBUG && _d('Comparing UNIQUE keys to normal keys');
2453  ***      0                                         push @dupes,
2454                                                        $self->remove_prefix_duplicates(\@unique_keys, \@normal_keys, %args);
2455                                                  
2456  ***      0                                         MKDEBUG && _d('Comparing normal keys');
2457  ***      0                                         push @dupes,
2458                                                        $self->remove_prefix_duplicates(\@normal_keys, \@normal_keys, %args);
2459                                                  
2460  ***      0                                         MKDEBUG && _d('Comparing FULLTEXT keys');
2461  ***      0                                         push @dupes,
2462                                                        $self->remove_prefix_duplicates(\@fulltext_keys, \@fulltext_keys, %args, exact_duplicates => 1);
2463                                                  
2464                                                  
2465  ***      0      0                                  my $clustered_key = $args{clustered_key} ? $keys{$args{clustered_key}}
2466                                                                       : undef;
2467  ***      0                                         MKDEBUG && _d('clustered key:', $clustered_key->{name});
2468  ***      0      0      0                           if ( $clustered_key
      ***                    0                        
      ***                    0                        
2469                                                          && $args{clustered}
2470                                                          && $args{tbl_info}->{engine}
2471                                                          && $args{tbl_info}->{engine} =~ m/InnoDB/i )
2472                                                     {
2473  ***      0                                            MKDEBUG && _d('Removing UNIQUE dupes of clustered key');
2474  ***      0                                            push @dupes,
2475                                                           $self->remove_clustered_duplicates($clustered_key, \@unique_keys, %args);
2476                                                  
2477  ***      0                                            MKDEBUG && _d('Removing ordinary dupes of clustered key');
2478  ***      0                                            push @dupes,
2479                                                           $self->remove_clustered_duplicates($clustered_key, \@normal_keys, %args);
2480                                                     }
2481                                                  
2482  ***      0                                         return \@dupes;
2483                                                  }
2484                                                  
2485                                                  sub get_duplicate_fks {
2486  ***      0                    0                    my ( $self, $fks, %args ) = @_;
2487  ***      0      0                                  die "I need a fks argument" unless $fks;
2488  ***      0                                         my @fks = values %$fks;
2489  ***      0                                         my @dupes;
2490                                                  
2491  ***      0                                         foreach my $i ( 0..$#fks - 1 ) {
2492  ***      0      0                                     next unless $fks[$i];
2493  ***      0                                            foreach my $j ( $i+1..$#fks ) {
2494  ***      0      0                                        next unless $fks[$j];
2495                                                  
2496  ***      0                                               my $i_cols  = join(',', sort @{$fks[$i]->{cols}} );
      ***      0                                      
2497  ***      0                                               my $j_cols  = join(',', sort @{$fks[$j]->{cols}} );
      ***      0                                      
2498  ***      0                                               my $i_pcols = join(',', sort @{$fks[$i]->{parent_cols}} );
      ***      0                                      
2499  ***      0                                               my $j_pcols = join(',', sort @{$fks[$j]->{parent_cols}} );
      ***      0                                      
2500                                                  
2501  ***      0      0      0                                 if ( $fks[$i]->{parent_tbl} eq $fks[$j]->{parent_tbl}
      ***                    0                        
2502                                                                && $i_cols  eq $j_cols
2503                                                                && $i_pcols eq $j_pcols ) {
2504  ***      0                                                  my $dupe = {
2505                                                                 key               => $fks[$j]->{name},
2506  ***      0                                                     cols              => [ @{$fks[$j]->{cols}} ],
2507                                                                 ddl               => $fks[$j]->{ddl},
2508                                                                 duplicate_of      => $fks[$i]->{name},
2509  ***      0                                                     duplicate_of_cols => [ @{$fks[$i]->{cols}} ],
2510                                                                 duplicate_of_ddl  => $fks[$i]->{ddl},
2511                                                                 reason            =>
2512                                                                      "FOREIGN KEY $fks[$j]->{name} ($fks[$j]->{colnames}) "
2513                                                                    . "REFERENCES $fks[$j]->{parent_tbl} "
2514                                                                    . "($fks[$j]->{parent_colnames}) "
2515                                                                    . 'is a duplicate of '
2516                                                                    . "FOREIGN KEY $fks[$i]->{name} ($fks[$i]->{colnames}) "
2517                                                                    . "REFERENCES $fks[$i]->{parent_tbl} "
2518                                                                    ."($fks[$i]->{parent_colnames})",
2519                                                                 dupe_type         => 'fk',
2520                                                              };
2521  ***      0                                                  push @dupes, $dupe;
2522  ***      0                                                  delete $fks[$j];
2523  ***      0      0                                           $args{callback}->($dupe, %args) if $args{callback};
2524                                                           }
2525                                                        }
2526                                                     }
2527  ***      0                                         return \@dupes;
2528                                                  }
2529                                                  
2530                                                  sub remove_prefix_duplicates {
2531  ***      0                    0                    my ( $self, $left_keys, $right_keys, %args ) = @_;
2532  ***      0                                         my @dupes;
2533  ***      0                                         my $right_offset;
2534  ***      0                                         my $last_left_key;
2535  ***      0                                         my $last_right_key = scalar(@$right_keys) - 1;
2536                                                  
2537                                                  
2538  ***      0      0                                  if ( $right_keys != $left_keys ) {
2539                                                  
2540  ***      0                                            @$left_keys = sort { $a->{colnames} cmp $b->{colnames} }
      ***      0                                      
2541  ***      0                                                          grep { defined $_; }
2542                                                                      @$left_keys;
2543  ***      0                                            @$right_keys = sort { $a->{colnames} cmp $b->{colnames} }
      ***      0                                      
2544  ***      0                                                           grep { defined $_; }
2545                                                                      @$right_keys;
2546                                                  
2547  ***      0                                            $last_left_key = scalar(@$left_keys) - 1;
2548                                                  
2549  ***      0                                            $right_offset = 0;
2550                                                     }
2551                                                     else {
2552                                                  
2553  ***      0                                            @$left_keys = reverse sort { $a->{colnames} cmp $b->{colnames} }
      ***      0                                      
2554  ***      0                                                          grep { defined $_; }
2555                                                                      @$left_keys;
2556                                                        
2557  ***      0                                            $last_left_key = scalar(@$left_keys) - 2;
2558                                                  
2559  ***      0                                            $right_offset = 1;
2560                                                     }
2561                                                  
2562                                                     LEFT_KEY:
2563  ***      0                                         foreach my $left_index ( 0..$last_left_key ) {
2564  ***      0      0                                     next LEFT_KEY unless defined $left_keys->[$left_index];
2565                                                  
2566                                                        RIGHT_KEY:
2567  ***      0                                            foreach my $right_index ( $left_index+$right_offset..$last_right_key ) {
2568  ***      0      0                                        next RIGHT_KEY unless defined $right_keys->[$right_index];
2569                                                  
2570  ***      0                                               my $left_name      = $left_keys->[$left_index]->{name};
2571  ***      0                                               my $left_cols      = $left_keys->[$left_index]->{colnames};
2572  ***      0                                               my $left_len_cols  = $left_keys->[$left_index]->{len_cols};
2573  ***      0                                               my $right_name     = $right_keys->[$right_index]->{name};
2574  ***      0                                               my $right_cols     = $right_keys->[$right_index]->{colnames};
2575  ***      0                                               my $right_len_cols = $right_keys->[$right_index]->{len_cols};
2576                                                  
2577  ***      0                                               MKDEBUG && _d('Comparing left', $left_name, '(',$left_cols,')',
2578                                                              'to right', $right_name, '(',$right_cols,')');
2579                                                  
2580  ***      0      0                                        if (    substr($left_cols,  0, $right_len_cols)
2581                                                                eq substr($right_cols, 0, $right_len_cols) ) {
2582                                                  
2583  ***      0      0      0                                    if ( $args{exact_duplicates} && ($right_len_cols<$left_len_cols) ) {
2584  ***      0                                                     MKDEBUG && _d($right_name, 'not exact duplicate of', $left_name);
2585  ***      0                                                     next RIGHT_KEY;
2586                                                              }
2587                                                  
2588  ***      0      0                                           if ( exists $right_keys->[$right_index]->{unique_col} ) {
2589  ***      0                                                     MKDEBUG && _d('Cannot remove', $right_name,
2590                                                                    'because is constrains col',
2591                                                                    $right_keys->[$right_index]->{cols}->[0]);
2592  ***      0                                                     next RIGHT_KEY;
2593                                                              }
2594                                                  
2595  ***      0                                                  MKDEBUG && _d('Remove', $right_name);
2596  ***      0                                                  my $reason;
2597  ***      0      0                                           if ( $right_keys->[$right_index]->{unconstrained} ) {
2598  ***      0                                                     $reason .= "Uniqueness of $right_name ignored because "
2599                                                                    . $right_keys->[$right_index]->{constraining_key}->{name}
2600                                                                    . " is a stronger constraint\n"; 
2601                                                              }
2602  ***      0      0                                           my $exact_dupe = $right_len_cols < $left_len_cols ? 0 : 1;
2603  ***      0      0                                           $reason .= $right_name
2604                                                                       . ($exact_dupe ? ' is a duplicate of '
2605                                                                                      : ' is a left-prefix of ')
2606                                                                       . $left_name;
2607  ***      0      0                                           my $dupe = {
2608                                                                 key               => $right_name,
2609                                                                 cols              => $right_keys->[$right_index]->{real_cols},
2610                                                                 ddl               => $right_keys->[$right_index]->{ddl},
2611                                                                 duplicate_of      => $left_name,
2612                                                                 duplicate_of_cols => $left_keys->[$left_index]->{real_cols},
2613                                                                 duplicate_of_ddl  => $left_keys->[$left_index]->{ddl},
2614                                                                 reason            => $reason,
2615                                                                 dupe_type         => $exact_dupe ? 'exact' : 'prefix',
2616                                                              };
2617  ***      0                                                  push @dupes, $dupe;
2618  ***      0                                                  delete $right_keys->[$right_index];
2619                                                  
2620  ***      0      0                                           $args{callback}->($dupe, %args) if $args{callback};
2621                                                           }
2622                                                           else {
2623  ***      0                                                  MKDEBUG && _d($right_name, 'not left-prefix of', $left_name);
2624  ***      0                                                  next LEFT_KEY;
2625                                                           }
2626                                                        } # RIGHT_KEY
2627                                                     } # LEFT_KEY
2628  ***      0                                         MKDEBUG && _d('No more keys');
2629                                                  
2630  ***      0                                         @$left_keys  = grep { defined $_; } @$left_keys;
      ***      0                                      
2631  ***      0                                         @$right_keys = grep { defined $_; } @$right_keys;
      ***      0                                      
2632                                                  
2633  ***      0                                         return @dupes;
2634                                                  }
2635                                                  
2636                                                  sub remove_clustered_duplicates {
2637  ***      0                    0                    my ( $self, $ck, $keys, %args ) = @_;
2638  ***      0      0                                  die "I need a ck argument"   unless $ck;
2639  ***      0      0                                  die "I need a keys argument" unless $keys;
2640  ***      0                                         my $ck_cols = $ck->{colnames};
2641  ***      0                                         my @dupes;
2642                                                  
2643                                                     KEY:
2644  ***      0                                         for my $i ( 0 .. @$keys - 1 ) {
2645  ***      0                                            my $suffix = $keys->[$i]->{colnames};
2646                                                        SUFFIX:
2647  ***      0                                            while ( $suffix =~ s/`[^`]+`,// ) {
2648  ***      0                                               my $len = min(length($ck_cols), length($suffix));
2649  ***      0      0                                        if ( substr($suffix, 0, $len) eq substr($ck_cols, 0, $len) ) {
2650  ***      0                                                  my $dupe = {
2651                                                                 key               => $keys->[$i]->{name},
2652                                                                 cols              => $keys->[$i]->{real_cols},
2653                                                                 ddl               => $keys->[$i]->{ddl},
2654                                                                 duplicate_of      => $ck->{name},
2655                                                                 duplicate_of_cols => $ck->{real_cols},
2656                                                                 duplicate_of_ddl  => $ck->{ddl},
2657                                                                 reason            => "Key $keys->[$i]->{name} ends with a "
2658                                                                                    . "prefix of the clustered index",
2659                                                                 dupe_type         => 'clustered',
2660                                                                 short_key         => $self->shorten_clustered_duplicate(
2661                                                                                         $ck_cols,
2662  ***      0                                                                             join(',', map { "`$_`" }
2663  ***      0                                                                                @{$keys->[$i]->{real_cols}})
2664                                                                                      ),
2665                                                              };
2666  ***      0                                                  push @dupes, $dupe;
2667  ***      0                                                  delete $keys->[$i];
2668  ***      0      0                                           $args{callback}->($dupe, %args) if $args{callback};
2669  ***      0                                                  last SUFFIX;
2670                                                           }
2671                                                        }
2672                                                     }
2673  ***      0                                         MKDEBUG && _d('No more keys');
2674                                                  
2675  ***      0                                         @$keys = grep { defined $_; } @$keys;
      ***      0                                      
2676                                                  
2677  ***      0                                         return @dupes;
2678                                                  }
2679                                                  
2680                                                  sub shorten_clustered_duplicate {
2681  ***      0                    0                    my ( $self, $ck_cols, $dupe_key_cols ) = @_;
2682  ***      0      0                                  return $ck_cols if $ck_cols eq $dupe_key_cols;
2683  ***      0                                         $dupe_key_cols =~ s/$ck_cols$//;
2684  ***      0                                         $dupe_key_cols =~ s/,+$//;
2685  ***      0                                         return $dupe_key_cols;
2686                                                  }
2687                                                  
2688                                                  sub unconstrain_keys {
2689  ***      0                    0                    my ( $self, $primary_key, $unique_keys ) = @_;
2690  ***      0      0                                  die "I need a unique_keys argument" unless $unique_keys;
2691  ***      0                                         my %unique_cols;
2692  ***      0                                         my @unique_sets;
2693  ***      0                                         my %unconstrain;
2694  ***      0                                         my @unconstrained_keys;
2695                                                  
2696  ***      0                                         MKDEBUG && _d('Unconstraining redundantly unique keys');
2697                                                  
2698                                                     UNIQUE_KEY:
2699  ***      0                                         foreach my $unique_key ( $primary_key, @$unique_keys ) {
2700  ***      0      0                                     next unless $unique_key; # primary key may be undefined
2701  ***      0                                            my $cols = $unique_key->{cols};
2702  ***      0      0                                     if ( @$cols == 1 ) {
2703  ***      0                                               MKDEBUG && _d($unique_key->{name},'defines unique column:',$cols->[0]);
2704  ***      0      0                                        if ( !exists $unique_cols{$cols->[0]} ) {
2705  ***      0                                                  $unique_cols{$cols->[0]}  = $unique_key;
2706  ***      0                                                  $unique_key->{unique_col} = 1;
2707                                                           }
2708                                                        }
2709                                                        else {
2710  ***      0                                               local $LIST_SEPARATOR = '-';
2711  ***      0                                               MKDEBUG && _d($unique_key->{name}, 'defines unique set:', @$cols);
2712  ***      0                                               push @unique_sets, { cols => $cols, key => $unique_key };
2713                                                        }
2714                                                     }
2715                                                  
2716                                                     UNIQUE_SET:
2717  ***      0                                         foreach my $unique_set ( @unique_sets ) {
2718  ***      0                                            my $n_unique_cols = 0;
2719  ***      0                                            COL:
2720  ***      0                                            foreach my $col ( @{$unique_set->{cols}} ) {
2721  ***      0      0                                        if ( exists $unique_cols{$col} ) {
2722  ***      0                                                  MKDEBUG && _d('Unique set', $unique_set->{key}->{name},
2723                                                                 'has unique col', $col);
2724  ***      0      0                                           last COL if ++$n_unique_cols > 1;
2725  ***      0                                                  $unique_set->{constraining_key} = $unique_cols{$col};
2726                                                           }
2727                                                        }
2728  ***      0      0      0                              if ( $n_unique_cols && $unique_set->{key}->{name} ne 'PRIMARY' ) {
2729  ***      0                                               MKDEBUG && _d('Will unconstrain unique set',
2730                                                              $unique_set->{key}->{name},
2731                                                              'because it is redundantly constrained by key',
2732                                                              $unique_set->{constraining_key}->{name},
2733                                                              '(',$unique_set->{constraining_key}->{colnames},')');
2734  ***      0                                               $unconstrain{$unique_set->{key}->{name}}
2735                                                              = $unique_set->{constraining_key};
2736                                                        }
2737                                                     }
2738                                                  
2739  ***      0                                         for my $i ( 0..(scalar @$unique_keys-1) ) {
2740  ***      0      0                                     if ( exists $unconstrain{$unique_keys->[$i]->{name}} ) {
2741  ***      0                                               MKDEBUG && _d('Unconstraining', $unique_keys->[$i]->{name});
2742  ***      0                                               $unique_keys->[$i]->{unconstrained} = 1;
2743  ***      0                                               $unique_keys->[$i]->{constraining_key}
2744                                                              = $unconstrain{$unique_keys->[$i]->{name}};
2745  ***      0                                               push @unconstrained_keys, $unique_keys->[$i];
2746  ***      0                                               delete $unique_keys->[$i];
2747                                                        }
2748                                                     }
2749                                                  
2750  ***      0                                         MKDEBUG && _d('No more keys');
2751  ***      0                                         return @unconstrained_keys;
2752                                                  }
2753                                                  
2754                                                  sub _d {
2755  ***      0                    0                    my ($package, undef, $line) = caller 0;
2756  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
2757  ***      0                                              map { defined $_ ? $_ : 'undef' }
2758                                                          @_;
2759  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2760                                                  }
2761                                                  
2762                                                  1;
2763                                                  # ###########################################################################
2764                                                  # End DuplicateKeyFinder package
2765                                                  # ###########################################################################
2766                                                  
2767                                                  # ###########################################################################
2768                                                  # Transformers package 5266
2769                                                  # ###########################################################################
2770                                                  
2771                                                  package Transformers;
2772                                                  
2773           6                    6            46   use strict;
               6                                 16   
               6                                 32   
2774           6                    6            35   use warnings FATAL => 'all';
               6                                 15   
               6                                 34   
2775           6                    6            38   use English qw(-no_match_vars);
               6                                 19   
               6                                 29   
2776           6                    6            74   use Time::Local qw(timegm timelocal);
               6                                 17   
               6                                 66   
2777           6                    6            43   use Digest::MD5 qw(md5_hex);
               6                                 15   
               6                                 42   
2778                                                  
2779  ***      6            50      6            38   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 16   
               6                                 80   
2780                                                  
2781                                                  require Exporter;
2782                                                  our @ISA         = qw(Exporter);
2783                                                  our %EXPORT_TAGS = ();
2784                                                  our @EXPORT      = ();
2785                                                  our @EXPORT_OK   = qw(
2786                                                     micro_t
2787                                                     percentage_of
2788                                                     secs_to_time
2789                                                     shorten
2790                                                     ts
2791                                                     parse_timestamp
2792                                                     unix_timestamp
2793                                                     any_unix_timestamp
2794                                                     make_checksum
2795                                                  );
2796                                                  
2797                                                  our $mysql_ts  = qr/(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)(\.\d+)?/;
2798                                                  our $proper_ts = qr/(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)(\.\d+)?/;
2799                                                  our $n_ts      = qr/(\d{1,5})([shmd]?)/; # Limit \d{1,5} because \d{6} looks
2800                                                  
2801                                                  sub micro_t {
2802  ***      0                    0                    my ( $t, %args ) = @_;
2803  ***      0      0                                  my $p_ms = defined $args{p_ms} ? $args{p_ms} : 0;  # precision for ms vals
2804  ***      0      0                                  my $p_s  = defined $args{p_s}  ? $args{p_s}  : 0;  # precision for s vals
2805  ***      0                                         my $f;
2806                                                  
2807  ***      0      0                                  $t = 0 if $t < 0;
2808                                                  
2809  ***      0      0                                  $t = sprintf('%.17f', $t) if $t =~ /e/;
2810                                                  
2811  ***      0                                         $t =~ s/\.(\d{1,6})\d*/\.$1/;
2812                                                  
2813  ***      0      0      0                           if ($t > 0 && $t <= 0.000999) {
      ***             0      0                        
      ***             0                               
2814  ***      0                                            $f = ($t * 1000000) . 'us';
2815                                                     }
2816                                                     elsif ($t >= 0.001000 && $t <= 0.999999) {
2817  ***      0                                            $f = sprintf("%.${p_ms}f", $t * 1000);
2818  ***      0                                            $f = ($f * 1) . 'ms'; # * 1 to remove insignificant zeros
2819                                                     }
2820                                                     elsif ($t >= 1) {
2821  ***      0                                            $f = sprintf("%.${p_s}f", $t);
2822  ***      0                                            $f = ($f * 1) . 's'; # * 1 to remove insignificant zeros
2823                                                     }
2824                                                     else {
2825  ***      0                                            $f = 0;  # $t should = 0 at this point
2826                                                     }
2827                                                  
2828  ***      0                                         return $f;
2829                                                  }
2830                                                  
2831                                                  sub percentage_of {
2832  ***      0                    0                    my ( $is, $of, %args ) = @_;
2833  ***      0             0                           my $p   = $args{p} || 0; # float precision
2834  ***      0      0                                  my $fmt = $p ? "%.${p}f" : "%d";
2835  ***      0             0                           return sprintf $fmt, ($is * 100) / ($of ||= 1);
2836                                                  }
2837                                                  
2838                                                  sub secs_to_time {
2839  ***      0                    0                    my ( $secs, $fmt ) = @_;
2840  ***      0             0                           $secs ||= 0;
2841  ***      0      0                                  return '00:00' unless $secs;
2842                                                  
2843  ***      0      0      0                           $fmt ||= $secs >= 86_400 ? 'd'
      ***             0                               
2844                                                            : $secs >= 3_600  ? 'h'
2845                                                            :                   'm';
2846                                                  
2847                                                     return
2848  ***      0      0                                     $fmt eq 'd' ? sprintf(
      ***             0                               
2849                                                           "%d+%02d:%02d:%02d",
2850                                                           int($secs / 86_400),
2851                                                           int(($secs % 86_400) / 3_600),
2852                                                           int(($secs % 3_600) / 60),
2853                                                           $secs % 60)
2854                                                        : $fmt eq 'h' ? sprintf(
2855                                                           "%02d:%02d:%02d",
2856                                                           int(($secs % 86_400) / 3_600),
2857                                                           int(($secs % 3_600) / 60),
2858                                                           $secs % 60)
2859                                                        : sprintf(
2860                                                           "%02d:%02d",
2861                                                           int(($secs % 3_600) / 60),
2862                                                           $secs % 60);
2863                                                  }
2864                                                  
2865                                                  sub shorten {
2866  ***      0                    0                    my ( $num, %args ) = @_;
2867  ***      0      0                                  my $p = defined $args{p} ? $args{p} : 2;     # float precision
2868  ***      0      0                                  my $d = defined $args{d} ? $args{d} : 1_024; # divisor
2869  ***      0                                         my $n = 0;
2870  ***      0                                         my @units = ('', qw(k M G T P E Z Y));
2871  ***      0             0                           while ( $num >= $d && $n < @units - 1 ) {
2872  ***      0                                            $num /= $d;
2873  ***      0                                            ++$n;
2874                                                     }
2875  ***      0      0      0                           return sprintf(
2876                                                        $num =~ m/\./ || $n
2877                                                           ? "%.${p}f%s"
2878                                                           : '%d',
2879                                                        $num, $units[$n]);
2880                                                  }
2881                                                  
2882                                                  sub ts {
2883  ***      0                    0                    my ( $time, $gmt ) = @_;
2884  ***      0      0                                  my ( $sec, $min, $hour, $mday, $mon, $year )
2885                                                        = $gmt ? gmtime($time) : localtime($time);
2886  ***      0                                         $mon  += 1;
2887  ***      0                                         $year += 1900;
2888  ***      0                                         my $val = sprintf("%d-%02d-%02dT%02d:%02d:%02d",
2889                                                        $year, $mon, $mday, $hour, $min, $sec);
2890  ***      0      0                                  if ( my ($us) = $time =~ m/(\.\d+)$/ ) {
2891  ***      0                                            $us = sprintf("%.6f", $us);
2892  ***      0                                            $us =~ s/^0\././;
2893  ***      0                                            $val .= $us;
2894                                                     }
2895  ***      0                                         return $val;
2896                                                  }
2897                                                  
2898                                                  sub parse_timestamp {
2899  ***      0                    0                    my ( $val ) = @_;
2900  ***      0      0                                  if ( my($y, $m, $d, $h, $i, $s, $f)
2901                                                           = $val =~ m/^$mysql_ts$/ )
2902                                                     {
2903  ***      0      0                                     return sprintf "%d-%02d-%02d %02d:%02d:"
      ***             0                               
2904                                                                       . (defined $f ? '%02.6f' : '%02d'),
2905                                                                       $y + 2000, $m, $d, $h, $i, (defined $f ? $s + $f : $s);
2906                                                     }
2907  ***      0                                         return $val;
2908                                                  }
2909                                                  
2910                                                  sub unix_timestamp {
2911  ***      0                    0                    my ( $val, $gmt ) = @_;
2912  ***      0      0                                  if ( my($y, $m, $d, $h, $i, $s, $us) = $val =~ m/^$proper_ts$/ ) {
2913  ***      0      0                                     $val = $gmt
2914                                                           ? timegm($s, $i, $h, $d, $m - 1, $y)
2915                                                           : timelocal($s, $i, $h, $d, $m - 1, $y);
2916  ***      0      0                                     if ( defined $us ) {
2917  ***      0                                               $us = sprintf('%.6f', $us);
2918  ***      0                                               $us =~ s/^0\././;
2919  ***      0                                               $val .= $us;
2920                                                        }
2921                                                     }
2922  ***      0                                         return $val;
2923                                                  }
2924                                                  
2925                                                  sub any_unix_timestamp {
2926  ***      0                    0                    my ( $val, $callback ) = @_;
2927                                                  
2928  ***      0      0                                  if ( my ($n, $suffix) = $val =~ m/^$n_ts$/ ) {
      ***             0                               
      ***             0                               
2929  ***      0      0                                     $n = $suffix eq 's' ? $n            # Seconds
      ***             0                               
      ***             0                               
      ***             0                               
2930                                                           : $suffix eq 'm' ? $n * 60       # Minutes
2931                                                           : $suffix eq 'h' ? $n * 3600     # Hours
2932                                                           : $suffix eq 'd' ? $n * 86400    # Days
2933                                                           :                  $n;           # default: Seconds
2934  ***      0                                            MKDEBUG && _d('ts is now - N[shmd]:', $n);
2935  ***      0                                            return time - $n;
2936                                                     }
2937                                                     elsif ( my ($ymd, $hms) = $val =~ m/^(\d{6})(?:\s+(\d+:\d+:\d+))?/ ) {
2938  ***      0                                            MKDEBUG && _d('ts is MySQL slow log timestamp');
2939  ***      0      0                                     $val .= ' 00:00:00' unless $hms;
2940  ***      0                                            return unix_timestamp(parse_timestamp($val));
2941                                                     }
2942                                                     elsif ( ($ymd, $hms) = $val =~ m/^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) {
2943  ***      0                                            MKDEBUG && _d('ts is properly formatted timestamp');
2944  ***      0      0                                     $val .= ' 00:00:00' unless $hms;
2945  ***      0                                            return unix_timestamp($val);
2946                                                     }
2947                                                     else {
2948  ***      0                                            MKDEBUG && _d('ts is MySQL expression');
2949  ***      0      0      0                              return $callback->($val) if $callback && ref $callback eq 'CODE';
2950                                                     }
2951                                                  
2952  ***      0                                         MKDEBUG && _d('Unknown ts type:', $val);
2953  ***      0                                         return;
2954                                                  }
2955                                                  
2956                                                  sub make_checksum {
2957  ***      0                    0                    my ( $val ) = @_;
2958  ***      0                                         my $checksum = uc substr(md5_hex($val), -16);
2959  ***      0                                         MKDEBUG && _d($checksum, 'checksum for', $val);
2960  ***      0                                         return $checksum;
2961                                                  }
2962                                                  
2963                                                  sub _d {
2964  ***      0                    0                    my ($package, undef, $line) = caller 0;
2965  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
2966  ***      0                                              map { defined $_ ? $_ : 'undef' }
2967                                                          @_;
2968  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2969                                                  }
2970                                                  
2971                                                  1;
2972                                                  
2973                                                  # ###########################################################################
2974                                                  # End Transformers package
2975                                                  # ###########################################################################
2976                                                  
2977                                                  # ###########################################################################
2978                                                  # Daemon package 5266
2979                                                  # ###########################################################################
2980                                                  
2981                                                  package Daemon;
2982                                                  
2983           6                    6            44   use strict;
               6                                 15   
               6                                 36   
2984           6                    6            35   use warnings FATAL => 'all';
               6                                 29   
               6                                 35   
2985                                                  
2986           6                    6            37   use POSIX qw(setsid);
               6                                 17   
               6                                 40   
2987           6                    6            36   use English qw(-no_match_vars);
               6                                 15   
               6                                 34   
2988                                                  
2989  ***      6            50      6            40   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 15   
               6                                 79   
2990                                                  
2991                                                  sub new {
2992  ***      0                    0                    my ( $class, %args ) = @_;
2993  ***      0                                         foreach my $arg ( qw(o) ) {
2994  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
2995                                                     }
2996  ***      0                                         my $o = $args{o};
2997  ***      0      0                                  my $self = {
      ***             0                               
2998                                                        o        => $o,
2999                                                        log_file => $o->has('log') ? $o->get('log') : undef,
3000                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
3001                                                     };
3002                                                  
3003  ***      0                                         check_PID_file(undef, $self->{PID_file});
3004                                                  
3005  ***      0                                         MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
3006  ***      0                                         return bless $self, $class;
3007                                                  }
3008                                                  
3009                                                  sub daemonize {
3010  ***      0                    0                    my ( $self ) = @_;
3011                                                  
3012  ***      0                                         MKDEBUG && _d('About to fork and daemonize');
3013  ***      0      0                                  defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
3014  ***      0      0                                  if ( $pid ) {
3015  ***      0                                            MKDEBUG && _d('I am the parent and now I die');
3016  ***      0                                            exit;
3017                                                     }
3018                                                  
3019  ***      0                                         $self->{child} = 1;
3020                                                  
3021  ***      0      0                                  POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
3022  ***      0      0                                  chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
3023                                                  
3024  ***      0                                         $self->_make_PID_file();
3025                                                  
3026  ***      0                                         $OUTPUT_AUTOFLUSH = 1;
3027                                                  
3028  ***      0      0                                  if ( -t STDIN ) {
3029  ***      0                                            close STDIN;
3030  ***      0      0                                     open  STDIN, '/dev/null'
3031                                                           or die "Cannot reopen STDIN to /dev/null: $OS_ERROR";
3032                                                     }
3033                                                  
3034  ***      0      0                                  if ( $self->{log_file} ) {
3035  ***      0                                            close STDOUT;
3036  ***      0      0                                     open  STDOUT, '>>', $self->{log_file}
3037                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
3038                                                  
3039  ***      0                                            close STDERR;
3040  ***      0      0                                     open  STDERR, ">&STDOUT"
3041                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR"; 
3042                                                     }
3043                                                     else {
3044  ***      0      0                                     if ( -t STDOUT ) {
3045  ***      0                                               close STDOUT;
3046  ***      0      0                                        open  STDOUT, '>', '/dev/null'
3047                                                              or die "Cannot reopen STDOUT to /dev/null: $OS_ERROR";
3048                                                        }
3049  ***      0      0                                     if ( -t STDERR ) {
3050  ***      0                                               close STDERR;
3051  ***      0      0                                        open  STDERR, '>', '/dev/null'
3052                                                              or die "Cannot reopen STDERR to /dev/null: $OS_ERROR";
3053                                                        }
3054                                                     }
3055                                                  
3056  ***      0                                         MKDEBUG && _d('I am the child and now I live daemonized');
3057  ***      0                                         return;
3058                                                  }
3059                                                  
3060                                                  sub check_PID_file {
3061  ***      0                    0                    my ( $self, $file ) = @_;
3062  ***      0      0                                  my $PID_file = $self ? $self->{PID_file} : $file;
3063  ***      0                                         MKDEBUG && _d('Checking PID file', $PID_file);
3064  ***      0      0      0                           if ( $PID_file && -f $PID_file ) {
3065  ***      0                                            my $pid;
3066  ***      0                                            eval { chomp($pid = `cat $PID_file`); };
      ***      0                                      
3067  ***      0      0                                     die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
3068  ***      0                                            MKDEBUG && _d('PID file exists; it contains PID', $pid);
3069  ***      0      0                                     if ( $pid ) {
3070  ***      0                                               my $pid_is_alive = kill 0, $pid;
3071  ***      0      0                                        if ( $pid_is_alive ) {
3072  ***      0                                                  die "The PID file $PID_file already exists "
3073                                                                 . " and the PID that it contains, $pid, is running";
3074                                                           }
3075                                                           else {
3076  ***      0                                                  warn "Overwriting PID file $PID_file because the PID that it "
3077                                                                 . "contains, $pid, is not running";
3078                                                           }
3079                                                        }
3080                                                        else {
3081  ***      0                                               die "The PID file $PID_file already exists but it does not "
3082                                                              . "contain a PID";
3083                                                        }
3084                                                     }
3085                                                     else {
3086  ***      0                                            MKDEBUG && _d('No PID file');
3087                                                     }
3088  ***      0                                         return;
3089                                                  }
3090                                                  
3091                                                  sub make_PID_file {
3092  ***      0                    0                    my ( $self ) = @_;
3093  ***      0      0                                  if ( exists $self->{child} ) {
3094  ***      0                                            die "Do not call Daemon::make_PID_file() for daemonized scripts";
3095                                                     }
3096  ***      0                                         $self->_make_PID_file();
3097  ***      0                                         $self->{rm_PID_file} = 1;
3098  ***      0                                         return;
3099                                                  }
3100                                                  
3101                                                  sub _make_PID_file {
3102  ***      0                    0                    my ( $self ) = @_;
3103                                                  
3104  ***      0                                         my $PID_file = $self->{PID_file};
3105  ***      0      0                                  if ( !$PID_file ) {
3106  ***      0                                            MKDEBUG && _d('No PID file to create');
3107  ***      0                                            return;
3108                                                     }
3109                                                  
3110  ***      0                                         $self->check_PID_file();
3111                                                  
3112  ***      0      0                                  open my $PID_FH, '>', $PID_file
3113                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
3114  ***      0      0                                  print $PID_FH $PID
3115                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
3116  ***      0      0                                  close $PID_FH
3117                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
3118                                                  
3119  ***      0                                         MKDEBUG && _d('Created PID file:', $self->{PID_file});
3120  ***      0                                         return;
3121                                                  }
3122                                                  
3123                                                  sub _remove_PID_file {
3124  ***      0                    0                    my ( $self ) = @_;
3125  ***      0      0      0                           if ( $self->{PID_file} && -f $self->{PID_file} ) {
3126  ***      0      0                                     unlink $self->{PID_file}
3127                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
3128  ***      0                                            MKDEBUG && _d('Removed PID file');
3129                                                     }
3130                                                     else {
3131  ***      0                                            MKDEBUG && _d('No PID to remove');
3132                                                     }
3133  ***      0                                         return;
3134                                                  }
3135                                                  
3136                                                  sub DESTROY {
3137  ***      0                    0                    my ( $self ) = @_;
3138  ***      0      0      0                           $self->_remove_PID_file() if $self->{child} || $self->{rm_PID_file};
3139  ***      0                                         return;
3140                                                  }
3141                                                  
3142                                                  sub _d {
3143  ***      0                    0                    my ($package, undef, $line) = caller 0;
3144  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
3145  ***      0                                              map { defined $_ ? $_ : 'undef' }
3146                                                          @_;
3147  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3148                                                  }
3149                                                  
3150                                                  1;
3151                                                  
3152                                                  # ###########################################################################
3153                                                  # End Daemon package
3154                                                  # ###########################################################################
3155                                                  
3156                                                  # #############################################################################
3157                                                  # This is a combination of modules and programs in one -- a runnable module.
3158                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
3159                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
3160                                                  #
3161                                                  # Check at the end of this package for the call to main() which actually runs
3162                                                  # the program.
3163                                                  # #############################################################################
3164                                                  package mk_duplicate_key_checker;
3165                                                  
3166           6                    6            44   use English qw(-no_match_vars);
               6                                 14   
               6                                 32   
3167           6                    6            39   use Getopt::Long;
               6                                 14   
               6                                 38   
3168           6                    6            40   use List::Util qw(max);
               6                                 15   
               6                                 33   
3169                                                  
3170                                                  Transformers->import(qw(shorten));
3171                                                  
3172  ***      6            50      6            38   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 15   
               6                                 80   
3173                                                  
3174                                                  $OUTPUT_AUTOFLUSH = 1;
3175                                                  
3176                                                  my $max_width = 74;
3177                                                  my $hdr_width = $max_width - 2;  # for '# '
3178                                                  my $hdr_fmt   = "# %-${hdr_width}s\n";
3179                                                  
3180                                                  my %summary = ( 'Total Indexes' => 0 );
3181                                                  my %seen_tbl;
3182                                                  
3183                                                  my $q  = new Quoter();
3184                                                  my $tp = new TableParser(Quoter => $q);
3185                                                  
3186                                                  sub main {
3187  ***      0                    0                    @ARGV = @_;  # set global ARGV for this package
3188                                                  
3189                                                     # #######################################################################
3190                                                     # Get configuration information and parse command line options.
3191                                                     # #######################################################################
3192  ***      0                                         my $o  = new OptionParser(
3193                                                        description  => q{examines MySQL tables for duplicate or redundant }
3194                                                                      . q{indexes and foreign keys.  Connection options }
3195                                                                      . q{are read from MySQL option files.},
3196                                                     );
3197  ***      0                                         $o->get_specs();
3198  ***      0                                         $o->get_opts();
3199  ***      0                                         $o->usage_or_errors();
3200                                                  
3201                                                     # ########################################################################
3202                                                     # If --pid, check it first since we'll die if it already exits.
3203                                                     # ########################################################################
3204  ***      0                                         my $daemon;
3205  ***      0      0                                  if ( $o->get('pid') ) {
3206                                                        # We're not daemoninzing, it just handles PID stuff.  Keep $daemon
3207                                                        # in the the scope of main() because when it's destroyed it automatically
3208                                                        # removes the PID file.
3209  ***      0                                            $daemon = new Daemon(o=>$o);
3210  ***      0                                            $daemon->make_PID_file();
3211                                                     }
3212                                                  
3213                                                     # #######################################################################
3214                                                     # Get ready to do the main work.
3215                                                     # #######################################################################
3216  ***      0      0                                  my $get_keys = $o->get('key-types') =~ m/k/ ? 1 : 0;
3217  ***      0      0                                  my $get_fks  = $o->get('key-types') =~ m/f/ ? 1 : 0;
3218                                                  
3219                                                     # Connect to the database
3220  ***      0      0      0                           if ( $o->got('ask-pass') && !$o->got('password') ) {
3221  ***      0                                            $o->set('password', OptionParser::prompt_noecho("Enter password: "));
3222                                                     }
3223  ***      0                                         my $dp = new DSNParser;
3224  ***      0                                         $dp->prop('set-vars', $o->get('set-vars'));
3225  ***      0                                         my $dsn = $dp->parse_options($o);
3226  ***      0                                         my $dbh = $dp->get_dbh($dp->get_cxn_params($dsn), {AutoCommit=>1});
3227                                                  
3228  ***      0                                         my $vp = new VersionParser();
3229  ***      0                                         my $version = $vp->parse($dbh->selectrow_array('SELECT VERSION()'));
3230                                                  
3231  ***      0      0                                  my $ks = $o->get('summary') ? new KeySize(q=>$q) : undef;
3232  ***      0                                         my $dk = new DuplicateKeyFinder();
3233  ***      0                                         my $du = new MySQLDump();
3234                                                  
3235  ***      0                                         my %tp_opts = (
3236                                                        ignore_type  => $o->get('all-structs'),
3237                                                        ignore_order => $o->get('ignore-order'),
3238                                                        clustered    => $o->get('clustered'),
3239                                                     );
3240                                                  
3241  ***      0                                         my $finder = new MySQLFind(
3242                                                        quoter    => $q,
3243                                                        useddl    => 1,
3244                                                        parser    => $tp,
3245                                                        dumper    => $du,
3246                                                        databases => {
3247                                                           permit => $o->get('databases'),
3248                                                           reject => $o->get('ignore-databases'),
3249                                                        },
3250                                                        tables => {
3251                                                           permit => $o->get('tables'),
3252                                                           reject => $o->get('ignore-tables'),
3253                                                        },
3254                                                        engines => {
3255                                                           views  => 0,
3256                                                           permit => $o->get('engines'),
3257                                                           reject => $o->get('ignore-engines'),
3258                                                        },
3259                                                     );
3260                                                  
3261                                                     # #######################################################################
3262                                                     # Do the main work.
3263                                                     # #######################################################################
3264                                                  
3265                                                     DATABASE:
3266  ***      0                                         foreach my $database ( $finder->find_databases($dbh) ) {
3267                                                        TABLE:
3268  ***      0                                            foreach my $table ( $finder->find_tables($dbh, database => $database) ) {
3269  ***      0                                               my $ddl      = $du->get_create_table($dbh, $q, $database, $table)->[1];
3270  ***      0             0                                 my $engine   = $tp->get_engine($ddl) || next TABLE;
3271  ***      0                                               my $tbl_info = {
3272                                                              db     => $database,
3273                                                              tbl    => $table,
3274                                                              engine => $engine,
3275                                                              ddl    => $ddl,
3276                                                           };
3277                                                  
3278  ***      0      0                                        my ($keys, $clustered_key)
3279                                                                    = $tp->get_keys($ddl, {version => $version })  if $get_keys;
3280  ***      0      0                                        my $fks  = $tp->get_fks($ddl,  {database => $database}) if $get_fks;
3281                                                  
3282  ***      0      0      0                                 next TABLE unless %$keys || %$fks;
3283                                                  
3284  ***      0      0                                        if ( $o->got('verbose') ) {
3285  ***      0      0                                           print_all_keys($keys, $tbl_info) if $keys;
3286  ***      0      0                                           print_all_keys($fks,  $tbl_info) if $fks;
3287                                                           }
3288                                                           else {
3289  ***      0                                                  MKDEBUG && _d('Getting duplicate keys on', $database, $table);
3290  ***      0      0                                           $dk->get_duplicate_keys(
3291                                                                 $keys,
3292                                                                 clustered_key => $clustered_key,
3293                                                                 tbl_info      => $tbl_info,
3294                                                                 callback      => \&print_duplicate_key,
3295                                                                 %tp_opts,
3296                                                                 # get_duplicate_keys() ignores these args but passes them
3297                                                                 # to the callback:
3298                                                                    dbh   => $dbh,
3299                                                                    is_fk => 0,
3300                                                                    o     => $o,
3301                                                                    ks    => $ks,
3302                                                              ) if $keys;
3303                                                  
3304  ***      0      0                                           $dk->get_duplicate_fks(
3305                                                                 $fks,
3306                                                                 tbl_info => $tbl_info,
3307                                                                 callback => \&print_duplicate_key,
3308                                                                 %tp_opts,
3309                                                                 # get_duplicate_fks() ignores these args but passes them
3310                                                                 # to the callback:
3311                                                                    dbh   => $dbh,
3312                                                                    is_fk => 1,
3313                                                                    o     => $o,
3314                                                                    ks    => $ks,
3315                                                              ) if $fks;
3316                                                           }
3317                                                  
3318                                                           # Always count Total Keys so print_key_summary won't die
3319                                                           # because %summary is empty.
3320  ***      0                                               $summary{'Total Indexes'} += (scalar keys %$keys) + (scalar keys %$fks)
3321                                                        }
3322                                                     }
3323                                                  
3324  ***      0      0                                  print_key_summary(%summary) if $o->get('summary');
3325                                                  
3326  ***      0                                         return 0;
3327                                                  }
3328                                                  
3329                                                  # ##########################################################################
3330                                                  # Subroutines
3331                                                  # ##########################################################################
3332                                                  
3333                                                  sub print_all_keys {
3334  ***      0                    0                    my ( $keys, $tbl_info ) = @_;
3335  ***      0      0                                  return unless $keys;
3336  ***      0                                         my $db  = $tbl_info->{db};
3337  ***      0                                         my $tbl = $tbl_info->{tbl};
3338  ***      0      0                                  if ( !$seen_tbl{"$db$tbl"}++ ) {
3339  ***      0                                            printf $hdr_fmt, ('#' x $hdr_width);
3340  ***      0                                            printf $hdr_fmt, "$db.$tbl";
3341  ***      0                                            printf $hdr_fmt, ('#' x $hdr_width);
3342                                                     }
3343  ***      0                                         foreach my $key ( values %$keys ) {
3344  ***      0                                            print "\n# $key->{name} ($key->{colnames})";
3345                                                     }
3346  ***      0                                         print "\n";
3347  ***      0                                         return;
3348                                                  }
3349                                                  
3350                                                  sub print_duplicate_key {
3351  ***      0                    0                    my ( $dupe, %args ) = @_;
3352  ***      0      0                                  return unless $dupe;
3353  ***      0                                         foreach my $arg ( qw(tbl_info dbh is_fk o ks) ) {
3354  ***      0      0                                     die "I need a $arg argument" unless exists $args{$arg};
3355                                                     }
3356  ***      0                                         MKDEBUG && _d('Printing duplicate key', $dupe->{key});
3357  ***      0                                         my $db     = $args{tbl_info}->{db};
3358  ***      0                                         my $tbl    = $args{tbl_info}->{tbl};
3359  ***      0                                         my $dbh    = $args{dbh};
3360  ***      0                                         my $o      = $args{o};
3361  ***      0                                         my $ks     = $args{ks};
3362  ***      0                                         my $struct = $tp->parse($args{tbl_info}->{ddl});
3363                                                  
3364  ***      0      0                                  if ( !$seen_tbl{"$db$tbl"}++ ) {
3365  ***      0                                            printf $hdr_fmt, ('#' x $hdr_width);
3366  ***      0                                            printf $hdr_fmt, "$db.$tbl";
3367  ***      0                                            printf $hdr_fmt, ('#' x $hdr_width);
3368  ***      0                                            print "\n";
3369                                                     }
3370                                                  
3371  ***      0                                         $dupe->{reason} =~ s/\n/\n# /g;
3372  ***      0                                         print "# $dupe->{reason}\n";
3373                                                  
3374  ***      0                                         print "# Key definitions:\n";
3375  ***      0             0                           print "#   " . ($dupe->{ddl} || '') . "\n";
3376  ***      0             0                           print "#   " . ($dupe->{duplicate_of_ddl} || '') . "\n";
3377                                                  
3378  ***      0                                         print "# Column types:\n";
3379  ***      0                                         my %seen;  # print each column only once
3380  ***      0                                         foreach my $col ( @{$dupe->{cols}}, @{$dupe->{duplicate_of_cols}} ) {
      ***      0                                      
      ***      0                                      
3381  ***      0      0                                     next if $seen{$col}++;
3382  ***      0                                            MKDEBUG && _d('col', $col);
3383  ***      0                                            print "#\t" . $struct->{defs}->{lc $col} . "\n";
3384                                                     }
3385                                                  
3386  ***      0      0                                  if ( $o->get('sql') ) {
3387  ***      0      0                                     if ( $dupe->{dupe_type} ne 'clustered' ) {
3388  ***      0      0                                        print "# To remove this duplicate "
      ***             0                               
3389                                                              . ($args{is_fk} ? 'foreign key' : 'index')
3390                                                              . ", execute:\n"
3391                                                              . 'ALTER TABLE ' . $q->quote($db, $tbl)
3392                                                              . ($args{is_fk} ? ' DROP FOREIGN KEY ' : ' DROP INDEX ')
3393                                                              . "`$dupe->{key}`;\n";
3394                                                        }
3395                                                        else {
3396                                                           # Suggest shortening clustered dupes instead of
3397                                                           # removing them (issue 295).
3398  ***      0                                               print "# To shorten this duplicate clustered index, execute:\n"
3399                                                              . 'ALTER TABLE '.$q->quote($db, $tbl)." DROP INDEX `$dupe->{key}`, "
3400                                                              . "ADD INDEX ($dupe->{short_key});\n";
3401                                                        }
3402                                                     }
3403  ***      0                                         print "\n";
3404                                                  
3405  ***      0      0                                  if ( $o->get('summary') ) {
3406  ***      0                                            $summary{'Total Duplicate Indexes'} += 1;
3407  ***      0                                            my ($size, $chosen_key) = $ks->get_key_size(
3408                                                           name        => $dupe->{key},
3409                                                           cols        => $dupe->{cols},
3410                                                           tbl_name    => $q->quote($db, $tbl),
3411                                                           tbl_struct  => $struct,
3412                                                           dbh         => $dbh,
3413                                                        );
3414  ***      0      0                                     if ( $args{is_fk} ) {
3415                                                           # Foreign keys have no size because they're just constraints.
3416  ***      0                                               print "# MySQL uses the $chosen_key index for this "
3417                                                              . "foreign key constraint\n\n";
3418                                                        }
3419                                                        else {
3420  ***      0             0                                 $size ||= 0;
3421                                                  
3422                                                           # Create Size Duplicate Keys summary even if there's no valid keys.
3423  ***      0                                               $summary{'Size Duplicate Indexes'} += $size;
3424                                                  
3425  ***      0      0                                        if ( $size ) {
3426  ***      0      0      0                                    if ( $chosen_key && $chosen_key ne $dupe->{key} ) {
3427                                                                 # This shouldn't happen. But in case it does, we should know.
3428  ***      0                                                     print "# MySQL chose the $chosen_key index despite FORCE INDEX\n\n";
3429                                                              }
3430                                                           }
3431                                                        }
3432                                                     }
3433  ***      0                                         return;
3434                                                  }
3435                                                  
3436                                                  sub print_key_summary {
3437  ***      0                    0                    my ( %summary ) = @_;
3438  ***      0                                         printf $hdr_fmt, ('#' x $hdr_width);
3439  ***      0                                         printf $hdr_fmt, 'Summary of indexes';
3440  ***      0                                         printf $hdr_fmt, ('#' x $hdr_width);
3441  ***      0                                         print "\n";
3442  ***      0                                         my $max_item = max(map { length($_) } keys %summary);
      ***      0                                      
3443  ***      0                                         my $line_fmt = "# %-${max_item}s  %-s\n";
3444  ***      0                                         foreach my $item ( sort keys %summary ) {
3445  ***      0                                            printf $line_fmt, $item, $summary{$item};
3446                                                     }
3447  ***      0                                         return;
3448                                                  }
3449                                                  
3450                                                  sub _d {
3451  ***      0                    0                    my ($package, undef, $line) = caller 0;
3452  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
3453  ***      0                                              map { defined $_ ? $_ : 'undef' }
3454                                                          @_;
3455  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3456                                                  }
3457                                                  
3458                                                  # ############################################################################
3459                                                  # Run the program.
3460                                                  # ############################################################################
3461                                                  if ( !caller ) { exit main(@ARGV); }
3462                                                  
3463                                                  1; # Because this is a module as well as a script.
3464                                                  
3465                                                  # ############################################################################
3466                                                  # Documentation
3467                                                  # ############################################################################
3468                                                  
3469                                                  =pod
3470                                                  
3471                                                  =head1 NAME
3472                                                  
3473                                                  mk-duplicate-key-checker - Find duplicate indexes and foreign keys on MySQL tables.
3474                                                  
3475                                                  =head1 SYNOPSIS
3476                                                  
3477                                                     mk-duplicate-key-checker --host host1
3478                                                  
3479                                                  =head1 RISKS
3480                                                  
3481                                                  The following section is included to inform users about the potential risks,
3482                                                  whether known or unknown, of using this tool.  The two main categories of risks
3483                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
3484                                                  tools) and those created by bugs.
3485                                                  
3486                                                  mk-duplicate-key-checker is a read-only tool that executes SHOW CREATE TABLE and
3487                                                  related queries to inspect table structures, and thus is very low-risk.
3488                                                  
3489                                                  At the time of this release, we know of no bugs that could cause serious harm to
3490                                                  users.
3491                                                  
3492                                                  The authoritative source for updated information is always the online issue
3493                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
3494                                                  see a list of such issues at the following URL:
3495                                                  L<http://www.maatkit.org/bugs/mk-duplicate-key-checker>.
3496                                                  
3497                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
3498                                                  
3499                                                  =head1 DESCRIPTION
3500                                                  
3501                                                  This program examines the output of SHOW CREATE TABLE on MySQL tables, and if
3502                                                  it finds indexes that cover the same columns as another index in the same
3503                                                  order, or cover an exact leftmost prefix of another index, it prints out
3504                                                  the suspicious indexes.  By default, indexes must be of the same type, so a
3505                                                  BTREE index is not a duplicate of a FULLTEXT index, even if they have the same
3506                                                  colums.  You can override this.
3507                                                  
3508                                                  It also looks for duplicate foreign keys.  A duplicate foreign key covers the
3509                                                  same columns as another in the same table, and references the same parent
3510                                                  table.
3511                                                  
3512                                                  =head1 OPTIONS
3513                                                  
3514                                                  =over
3515                                                  
3516                                                  =item --all-structs
3517                                                  
3518                                                  Compare indexes with different structs (BTREE, HASH, etc).
3519                                                  
3520                                                  By default this is disabled, because a BTREE index that covers the same columns
3521                                                  as a FULLTEXT index is not really a duplicate, for example.
3522                                                  
3523                                                  =item --ask-pass
3524                                                  
3525                                                  Prompt for a password when connecting to MySQL.
3526                                                  
3527                                                  =item --charset
3528                                                  
3529                                                  short form: -A; type: string
3530                                                  
3531                                                  Default character set.  If the value is utf8, sets Perl's binmode on
3532                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and runs SET
3533                                                  NAMES UTF8 after connecting to MySQL.  Any other value sets binmode on STDOUT
3534                                                  without the utf8 layer, and runs SET NAMES after connecting to MySQL.
3535                                                  
3536                                                  =item --[no]clustered
3537                                                  
3538                                                  default: yes
3539                                                  
3540                                                  PK columns appended to secondary key is duplicate.
3541                                                  
3542                                                  Detects when a suffix of a secondary key is a leftmost prefix of the primary
3543                                                  key, and treats it as a duplicate key.  Only detects this condition on storage
3544                                                  engines whose primary keys are clustered (currently InnoDB and solidDB).
3545                                                  
3546                                                  Clustered storage engines append the primary key columns to the leaf nodes of
3547                                                  all secondary keys anyway, so you might consider it redundant to have them
3548                                                  appear in the internal nodes as well.  Of course, you may also want them in the
3549                                                  internal nodes, because just having them at the leaf nodes won't help for some
3550                                                  queries.  It does help for covering index queries, however.
3551                                                  
3552                                                  Here's an example of a key that is considered redundant with this option:
3553                                                  
3554                                                    PRIMARY KEY  (`a`)
3555                                                    KEY `b` (`b`,`a`)
3556                                                  
3557                                                  The use of such indexes is rather subtle.  For example, suppose you have the
3558                                                  following query:
3559                                                  
3560                                                    SELECT ... WHERE b=1 ORDER BY a;
3561                                                  
3562                                                  This query will do a filesort if we remove the index on C<b,a>.  But if we
3563                                                  shorten the index on C<b,a> to just C<b> and also remove the ORDER BY, the query
3564                                                  should return the same results.
3565                                                  
3566                                                  The tool suggests shortening duplicate clustered keys by dropping the key
3567                                                  and re-adding it without the primary key prefix.  The shortened clustered
3568                                                  key may still duplicate another key, but the tool cannot currently detect
3569                                                  when this happens without being ran a second time to re-check the newly
3570                                                  shortened clustered keys.  Therefore, if you shorten any duplicate clusterted
3571                                                  keys, you should run the tool again.
3572                                                  
3573                                                  =item --config
3574                                                  
3575                                                  type: Array
3576                                                  
3577                                                  Read this comma-separated list of config files; if specified, this must be the
3578                                                  first option on the command line.
3579                                                  
3580                                                  =item --databases
3581                                                  
3582                                                  short form: -d; type: hash
3583                                                  
3584                                                  Check only this comma-separated list of databases.
3585                                                  
3586                                                  =item --defaults-file
3587                                                  
3588                                                  short form: -F; type: string
3589                                                  
3590                                                  Only read mysql options from the given file.  You must give an absolute pathname.
3591                                                  
3592                                                  =item --engines
3593                                                  
3594                                                  short form: -e; type: hash
3595                                                  
3596                                                  Check only tables whose storage engine is in this comma-separated list.
3597                                                  
3598                                                  =item --help
3599                                                  
3600                                                  Show help and exit.
3601                                                  
3602                                                  =item --host
3603                                                  
3604                                                  short form: -h; type: string
3605                                                  
3606                                                  Connect to host.
3607                                                  
3608                                                  =item --ignore-databases
3609                                                  
3610                                                  type: Hash
3611                                                  
3612                                                  Ignore this comma-separated list of databases.
3613                                                  
3614                                                  =item --ignore-engines
3615                                                  
3616                                                  type: Hash
3617                                                  
3618                                                  Ignore this comma-separated list of storage engines.
3619                                                  
3620                                                  =item --ignore-order
3621                                                  
3622                                                  Ignore index order so KEY(a,b) duplicates KEY(b,a).
3623                                                  
3624                                                  =item --ignore-tables
3625                                                  
3626                                                  type: Hash
3627                                                  
3628                                                  Ignore this comma-separated list of tables.  Table names may be qualified with
3629                                                  the database name.
3630                                                  
3631                                                  =item --key-types
3632                                                  
3633                                                  type: string; default: fk
3634                                                  
3635                                                  Check for duplicate f=foreign keys, k=keys or fk=both.
3636                                                  
3637                                                  =item --password
3638                                                  
3639                                                  short form: -p; type: string
3640                                                  
3641                                                  Password to use when connecting.
3642                                                  
3643                                                  =item --pid
3644                                                  
3645                                                  type: string
3646                                                  
3647                                                  Create the given PID file.  The file contains the process ID of the script.
3648                                                  The PID file is removed when the script exits.  Before starting, the script
3649                                                  checks if the PID file already exists.  If it does not, then the script creates
3650                                                  and writes its own PID to it.  If it does, then the script checks the following:
3651                                                  if the file contains a PID and a process is running with that PID, then
3652                                                  the script dies; or, if there is no process running with that PID, then the
3653                                                  script overwrites the file with its own PID and starts; else, if the file
3654                                                  contains no PID, then the script dies.
3655                                                  
3656                                                  =item --port
3657                                                  
3658                                                  short form: -P; type: int
3659                                                  
3660                                                  Port number to use for connection.
3661                                                  
3662                                                  =item --set-vars
3663                                                  
3664                                                  type: string; default: wait_timeout=10000
3665                                                  
3666                                                  Set these MySQL variables.  Immediately after connecting to MySQL, this string
3667                                                  will be appended to SET and executed.
3668                                                  
3669                                                  =item --socket
3670                                                  
3671                                                  short form: -S; type: string
3672                                                  
3673                                                  Socket file to use for connection.
3674                                                  
3675                                                  =item --[no]sql
3676                                                  
3677                                                  default: yes
3678                                                  
3679                                                  Print DROP KEY statement for each duplicate key.  By default an ALTER TABLE
3680                                                  DROP KEY statement is printed below each duplicate key so that, if you want to
3681                                                  remove the duplicate key, you can copy-paste the statement into MySQL.
3682                                                  
3683                                                  To disable printing these statements, specify --nosql.
3684                                                  
3685                                                  =item --[no]summary
3686                                                  
3687                                                  default: yes
3688                                                  
3689                                                  Print summary of indexes at end of output.
3690                                                  
3691                                                  =item --tables
3692                                                  
3693                                                  short form: -t; type: hash
3694                                                  
3695                                                  Check only this comma-separated list of tables.
3696                                                  
3697                                                  Table names may be qualified with the database name.
3698                                                  
3699                                                  =item --user
3700                                                  
3701                                                  short form: -u; type: string
3702                                                  
3703                                                  User for login if not current user.
3704                                                  
3705                                                  =item --verbose
3706                                                  
3707                                                  short form: -v
3708                                                  
3709                                                  Output all keys and/or foreign keys found, not just redundant ones.
3710                                                  
3711                                                  =item --version
3712                                                  
3713                                                  Show version and exit.
3714                                                  
3715                                                  =back
3716                                                  
3717                                                  =head1 DOWNLOADING
3718                                                  
3719                                                  You can download Maatkit from Google Code at
3720                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
3721                                                  easily with a command like the following:
3722                                                  
3723                                                     wget http://www.maatkit.org/get/toolname
3724                                                     or
3725                                                     wget http://www.maatkit.org/trunk/toolname
3726                                                  
3727                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
3728                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
3729                                                  needed.  The first URL gets the latest released version of the tool, and the
3730                                                  second gets the latest trunk code from Subversion.
3731                                                  
3732                                                  =head1 ENVIRONMENT
3733                                                  
3734                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
3735                                                  the Maatkit tools:
3736                                                  
3737                                                     MKDEBUG=1 mk-....
3738                                                  
3739                                                  =head1 SYSTEM REQUIREMENTS
3740                                                  
3741                                                  You need the following Perl modules: DBI and DBD::mysql.
3742                                                  
3743                                                  =head1 BUGS
3744                                                  
3745                                                  For list of known bugs see L<http://www.maatkit.org/bugs/mk-duplicate-key-checker>.
3746                                                  
3747                                                  Please use Google Code Issues and Groups to report bugs or request support:
3748                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
3749                                                  discuss Maatkit.
3750                                                  
3751                                                  Please include the complete command-line used to reproduce the problem you are
3752                                                  seeing, the version of all MySQL servers involved, the complete output of the
3753                                                  tool when run with L<"--version">, and if possible, debugging output produced by
3754                                                  running with the C<MKDEBUG=1> environment variable.
3755                                                  
3756                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
3757                                                  
3758                                                  This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
3759                                                  Feedback and improvements are welcome.
3760                                                  
3761                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
3762                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
3763                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
3764                                                  
3765                                                  This program is free software; you can redistribute it and/or modify it under
3766                                                  the terms of the GNU General Public License as published by the Free Software
3767                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
3768                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
3769                                                  licenses.
3770                                                  
3771                                                  You should have received a copy of the GNU General Public License along with
3772                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
3773                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
3774                                                  
3775                                                  =head1 AUTHOR
3776                                                  
3777                                                  Baron Schwartz, Daniel Nichter
3778                                                  
3779                                                  =head1 ABOUT MAATKIT
3780                                                  
3781                                                  This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
3782                                                  was created by Baron Schwartz; Baron and Daniel Nichter are the primary
3783                                                  code contributors.  Both are employed by Percona.  Financial support for
3784                                                  Maatkit development is primarily provided by Percona and its clients. 
3785                                                  
3786                                                  =head1 VERSION
3787                                                  
3788                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 5425 $.
3789                                                  
3790                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
56    ***      0      0      0   if (not $$self{$dbh})
60    ***      0      0      0   $$self{$dbh} ge $self->parse($target) ? :
67    ***      0      0      0   defined $_ ? :
107   ***      0      0      0   unless defined $val
108   ***      0      0      0   if $val eq ''
110   ***      0      0      0   if (not defined $is_numeric)
111   ***      0      0      0   $val =~ /^0|\D/ ? :
114   ***      0      0      0   if $is_numeric
124   ***      0      0      0   if (not $tbl)
133   ***      0      0      0   unless $like
164   ***     50      0      6   unless $args{$arg}
173   ***      0      0      0   unless $ddl
174   ***      0      0      0   if (ref $ddl eq 'ARRAY')
175   ***      0      0      0   if (lc $$ddl[0] eq 'table') { }
185   ***      0      0      0   if (not $ddl =~ /CREATE (?:TEMPORARY )?TABLE `/)
191   ***      0      0      0   if $name
209   ***      0      0      0   unless $type
211   ***      0      0      0   if ($type =~ /(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/)
215   ***      0      0      0   if (not $def =~ /NOT NULL/)
219   ***      0      0      0   $def =~ /AUTO_INCREMENT/i ? :
250   ***      0      0      0   unless ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
264   ***      0      0      0   if ($index)
267   ***      0      0      0   if (not $best)
268   ***      0      0      0   if ($index) { }
281   ***      0      0      0   unless $where
287   ***      0      0      0   if ($$expl{'possible_keys'}) { }
291   ***      0      0      0   if ($$expl{'key'})
311   ***      0      0      0   unless $args{$arg}
325   ***      0      0      0   if ($EVAL_ERROR)
329   ***      0      0      0   if (not $$row[0] or $$row[0] ne $tbl)
335   ***      0      0      0   unless $args{'all_privs'}
342   ***      0      0      0   if ($EVAL_ERROR)
346   ***      0      0      0   if (not scalar keys %$row)
357   ***      0      0      0   $EVAL_ERROR ? :
362   ***      0      0      0   if (not $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete)
388   ***      0      0      0   if $key =~ /FOREIGN/
393   ***      0      0      0   if (not $engine =~ /MEMORY|HEAP/)
400   ***      0      0      0   if ($$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i)
407   ***      0      0      0   $key =~ /PRIMARY|UNIQUE/ ? :
431   ***      0      0      0   if ($engine =~ /InnoDB/i and not $clustered_key)
433   ***      0      0      0   if ($$this_key{'name'} eq 'PRIMARY') { }
      ***      0      0      0   elsif ($$this_key{'is_unique'} and not $$this_key{'is_nullable'}) { }
457   ***      0      0      0   if (not $parent =~ /\./ and $$opts{'database'})
486   ***      0      0      0   if (($$tbl_struct{'engine'} || '') =~ /InnoDB/i) { }
500   ***      0      0      0   if (@sec_indexes)
517   ***      0      0      0   defined $_ ? :
567   ***      0      0      0   unless defined $args{'cache'}
575   ***      0      0      0   if ($what eq 'table') { }
      ***      0      0      0   elsif ($what eq 'triggers') { }
      ***      0      0      0   elsif ($what eq 'view') { }
577   ***      0      0      0   unless $ddl
578   ***      0      0      0   if ($$ddl[0] eq 'table') { }
592   ***      0      0      0   if ($trgs and @$trgs) { }
595   ***      0      0      0   if ($$trg{'sql_mode'})
599   ***      0      0      0   if ($$trg{'definer'})
631   ***      0      0      0   if (not $new)
638   ***      0      0      0   if ($curr and $new and $curr eq $new)
650   ***      0      0      0   if (not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl})
663   ***      0      0      0   if ($EVAL_ERROR)
673   ***      0      0      0   if ($key) { }
689   ***      0      0      0   if (not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl})
719   ***      0      0      0   if (not $$self{'cache'} or not $$self{'triggers'}{$db})
732   ***      0      0      0   if ($sth->rows)
745   ***      0      0      0   if ($tbl)
753   ***      0      0      0   if (not $$self{'cache'} or not $$self{'databases'} or $like)
756   ***      0      0      0   if ($like)
764   ***      0      0      0   unless $like
772   ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_status'}{$db} or $like)
775   ***      0      0      0   if ($like)
790   ***      0      0      0   unless $like
798   ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_list'}{$db} or $like)
801   ***      0      0      0   if ($like)
809   ***      0      0      0   ($$_[1] || '') eq 'VIEW' ? :
816   ***      0      0      0   unless $like
824   ***      0      0      0   defined $_ ? :
855   ***      0      0      0   unless $args{$arg}
857   ***      0      0      0   if $args{'dbh'}
859   ***      0      0      0   $$self{'engines'}{'permit'} || $$self{'engines'}{'reject'} || $$self{'engines'}{'regexp'} ? :
863   ***      0      0      0   if $$self{'need_engine'} and not defined $args{'parser'}
866   ***      0      0      0   unless defined $$self{'engines'}{'views'}
867   ***      0      0      0   unless defined $$self{'tables'}{'status'}
868   ***      0      0      0   if ($args{'useddl'})
876   ***      0      0      0   if $$self{'timestamp'}{$dbh}{'now'}
903   ***      0      0      0   if ($$self{'need_engine'})
905   ***      0      0      0   if $$tbl{'engine'}
910   ***      0      0      0   unless $struct
919   ***      0      0      0   if ($broken_table{$tables[$i]{'name'}})
946   ***      0      0      0   if (not $new)
953   ***      0      0      0   if ($curr and $new and $curr eq $new)
965   ***      0      0      0   unless $args{'database'}
970   ***      0      0      0   if (scalar @{$$self{'tables'}{'status'};}) { }
986   ***      0      0      0   unless $$self{'engines'}{'views'}
1007  ***      0      0      0   unless defined $val
1008  ***      0      0      0   if ($thing eq 'tables') { }
1010  ***      0      0      0   if !$reject || !$$reject{$val} && !$$reject{$tbl} and !$permit || $$permit{$val} || $$permit{$tbl}
1015  ***      0      0      0   if !$reject || !$$reject{$val} and !$permit || $$permit{$val}
1025  ***      0      0      0   if (not defined $$table{$prop})
1030  ***      0      0      0   unless defined $num
1037  ***      0      0      0   if ($equality)
1046  ***      0      0      0   defined $_ ? :
1132  ***     50      0     15   if (@_ > 2)
1141  ***     50      0      5   if (not $dsn)
1153  ***     50     20      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
1165  ***     50      0     40   if (not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'})
1171         100     20     20   if (not defined $final_props{$key})
1178  ***     50      0     20   unless exists $opts{$key}
1181  ***     50      0      5   if (my $required = $self->prop('required'))
1183  ***      0      0      0   unless $final_props{$key}
1192  ***      0      0      0   unless ref $o eq 'OptionParser'
1195  ***      0      0      0   if $o->has($_)
1205  ***      0      0      0   unless ref $dsn
1206  ***      0      0      0   $_ eq 'p' ? :
1207  ***      0      0      0   if defined $$dsn{$_}
1220  ***      0      0      0   $opts{$key}{'copy'} ? :
1234  ***     50      0      5   if ($driver eq 'Pg') { }
1266  ***     50      0      5   $cxn_string =~ /charset=utf8/ ? :
1275  ***     50      0      5   if (not $have_dbi)
1294  ***     50      5      0   if ($cxn_string =~ /mysql/i)
1302  ***     50      0      5   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
1307  ***      0      0      0   if ($charset eq 'utf8') { }
1308  ***      0      0      0   unless binmode STDOUT, ':utf8'
1312  ***      0      0      0   unless binmode STDOUT
1316  ***     50      0      5   if ($self->prop('set-vars'))
1323  ***     50      0      5   if (not $dbh and $EVAL_ERROR)
1325  ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/) { }
      ***      0      0      0   elsif ($EVAL_ERROR =~ m[locate DBD/mysql]i) { }
1338  ***      0      0      0   if (not $tries)
1360  ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
1377  ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
1387  ***      0      0      0   unless $dsn_1
1388  ***      0      0      0   unless $dsn_2
1392  ***      0      0      0   if ($args{'overwrite'}) { }
1393  ***      0      0      0   defined $$dsn_1{$key} ? :
1396  ***      0      0      0   defined $$dsn_2{$key} ? :
1405  ***      0      0      0   defined $_ ? :
1445  ***      0      0      0   unless $args{$arg}
1451  ***      0      0      0   exists $args{'strict'} ? :
1494  ***      0      0      0   unless open my $fh, '<', $file
1514  ***      0      0      0   unless $para =~ /^=head1 OPTIONS/
1519  ***      0      0      0   if $para =~ /^=over/
1527  ***      0      0      0   unless $para
1530  ***      0      0      0   if (my($option) = $para =~ /^=item --(.*)/)
1537  ***      0      0      0   if ($para =~ /: /) { }
1541  ***      0      0      0   unless $attributes{$attrib}
1545  ***      0      0      0   if ($attribs{'short form'})
1561  ***      0      0      0   if $para =~ /^=item/
1563  ***      0      0      0   if (my($base_option) = $option =~ /^\[no\](.*)/)
1568  ***      0      0      0   $attribs{'short form'} ? :
      ***      0      0      0   $attribs{'negatable'} ? :
      ***      0      0      0   $attribs{'cumulative'} ? :
      ***      0      0      0   $attribs{'type'} ? :
      ***      0      0      0   $attribs{'default'} ? :
      ***      0      0      0   $attribs{'group'} ? :
1580  ***      0      0      0   unless $para
1583  ***      0      0      0   if ($para =~ /^=head1/)
1587  ***      0      0      0   if $para =~ /^=item --/
1591  ***      0      0      0   unless @specs
1602  ***      0      0      0   if (ref $opt) { }
1607  ***      0      0      0   if (not $long)
1612  ***      0      0      0   if exists $$self{'opts'}{$long}
1615  ***      0      0      0   if (length $long == 1)
1620  ***      0      0      0   if ($short) { }
1621  ***      0      0      0   if exists $$self{'short_opts'}{$short}
1630  ***      0      0      0   $$opt{'spec'} =~ /!/ ? :
1631  ***      0      0      0   $$opt{'spec'} =~ /\+/ ? :
1632  ***      0      0      0   $$opt{'desc'} =~ /required/ ? :
1644  ***      0      0      0   if ($type and $type eq 'd' and not $$self{'dp'})
1649  ***      0      0      0   if $type and $type =~ /[HhAadzm]/
1651  ***      0      0      0   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
1652  ***      0      0      0   defined $def ? :
1656  ***      0      0      0   if ($long eq 'config')
1660  ***      0      0      0   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
1673  ***      0      0      0   if ($opt =~ /mutually exclusive|one and only one/)
1678  ***      0      0      0   if ($opt =~ /at least one|one and only one/)
1683  ***      0      0      0   if ($opt =~ /default to/)
1688  ***      0      0      0   if ($opt =~ /restricted to option groups/)
1698  ***      0      0      0   unless $rule_ok
1715  ***      0      0      0   unless exists $$self{'opts'}{$long}
1739  ***      0      0      0   unless exists $$self{'opts'}{$long}
1759  ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***      0      0      0   exists $$self{'opts'}{$opt} ? :
1764  ***      0      0      0   if ($$opt{'is_cumulative'}) { }
1779  ***      0      0      0   $$self{'opts'}{$long}{'is_cumulative'} ? :
      ***      0      0      0   exists $$self{'defaults'}{$long} ? :
1788  ***      0      0      0   if (@ARGV and $ARGV[0] eq '--config')
1792  ***      0      0      0   if ($self->has('config'))
1798  ***      0      0      0   if ($EVAL_ERROR)
1799  ***      0      0      0   $self->got('config') ? :
1814  ***      0      0      0   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
1817  ***      0      0      0   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
1818  ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
1824  ***      0      0      0   if (@ARGV and $$self{'strict'})
1830  ***      0      0      0   if (@set > 1)
1841  ***      0      0      0   if (@set == 0)
1851  ***      0      0      0   if ($$opt{'got'}) { }
      ***      0      0      0   elsif ($$opt{'is_required'}) { }
1852  ***      0      0      0   if (exists $$self{'disables'}{$long})
1859  ***      0      0      0   if (exists $$self{'allowed_groups'}{$long})
1871  ***      0      0      0   if $restricted_opt eq $long
1872  ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
1877  ***      0      0      0   if (@restricted_opts)
1879  ***      0      0      0   if (@restricted_opts == 1) { }
1908  ***      0      0      0   unless $opt and $$opt{'type'}
1911  ***      0      0      0   if ($val and $$opt{'type'} eq 'm') { }
      ***      0      0      0   elsif ($val and $$opt{'type'} eq 'd') { }
      ***      0      0      0   elsif ($val and $$opt{'type'} eq 'z') { }
      ***      0      0      0   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
      ***      0      0      0   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
1914  ***      0      0      0   if (not $suffix)
1920  ***      0      0      0   if ($suffix =~ /[smhd]/) { }
1921  ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
1936  ***      0      0      0   if ($from_key)
1947  ***      0      0      0   if (defined $num) { }
1948  ***      0      0      0   if ($factor)
1975  ***      0      0      0   length $opt == 1 ? :
1976  ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
1983  ***      0      0      0   length $opt == 1 ? :
1984  ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
1991  ***      0      0      0   length $opt == 1 ? :
1992  ***      0      0      0   defined $long ? :
1997  ***      0      0      0   length $opt == 1 ? :
1998  ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
2032  ***      0      0      0   if ($$self{'opts'}{'help'}{'got'}) { }
      ***      0      0      0   elsif (scalar @{$$self{'errors'};}) { }
2033  ***      0      0      0   unless print $self->print_usage
2037  ***      0      0      0   unless print $self->print_errors
2046  ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
2055  ***      0      0      0   unless $$self{'got_opts'}
2058  ***      0      0      0   $$_{'is_negatable'} ? :
2062  ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
2078  ***      0      0      0   $group eq 'default' ? :
2084  ***      0      0      0   $$opt{'is_negatable'} ? :
2087  ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
2096  ***      0      0      0   if ($short) { }
2105  ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
2109  ***      0      0      0   if ($$self{'dp'})
2117  ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
2129  ***      0      0      0   if ref $_[0] eq 'OptionParser'
2132  ***      0      0      0   unless print $prompt
2140  ***      0      0      0   unless print "\n"
2143  ***      0      0      0   if ($EVAL_ERROR)
2165  ***      0      0      0   unless open my $fh, '<', $filename
2173  ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
2176  ***      0      0      0   if ($line eq '--')
2181  ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
2199  ***      0      0      0   unless open my $fh, '<', $file
2203  ***      0      0      0   unless $para =~ /^=pod$/m
2207  ***      0      0      0   unless $para =~ /$regex/
2212  ***      0      0      0   unless close $fh
2226  ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
2241  ***      0      0      0   defined $_ ? :
2273  ***      0      0      0   unless $args{$arg}
2283  ***      0      0      0   if (@cols == 0)
2292  ***      0      0      0   $key_exists ? :
2300  ***      0      0      0   if (scalar @cols == 1)
2310  ***      0      0      0   if ($EVAL_ERROR)
2325  ***      0      0      0   if ($key_len and $rows) { }
2326  ***      0      0      0   if ($chosen_key =~ /,/ and $key_len =~ /,/)
2338  ***      0      0      0   wantarray ? :
2358  ***      0      0      0   exists $args{'tbl_struct'}{'keys'}{lc $args{'name'}} ? :
2363  ***      0      0      0   $$explain{$_} ? :
2371  ***      0      0      0   defined $_ ? :
2404  ***      0      0      0   unless $keys
2418  ***      0      0      0   if ($$key{'name'} eq 'PRIMARY' or $args{'clustered_key'} and $$key{'name'} eq $args{'clustered_key'})
2425  ***      0      0      0   $$key{'type'} eq 'FULLTEXT' ? :
2426  ***      0      0      0   if ($args{'ignore_order'} or $is_fulltext)
2433  ***      0      0      0   $$key{'is_unique'} ? :
2434  ***      0      0      0   if (not $args{'ignore_structure'})
2435  ***      0      0      0   if $is_fulltext
2442  ***      0      0      0   if ($primary_key)
2465  ***      0      0      0   $args{'clustered_key'} ? :
2468  ***      0      0      0   if ($clustered_key and $args{'clustered'} and $args{'tbl_info'}{'engine'} and $args{'tbl_info'}{'engine'} =~ /InnoDB/i)
2487  ***      0      0      0   unless $fks
2492  ***      0      0      0   unless $fks[$i]
2494  ***      0      0      0   unless $fks[$j]
2501  ***      0      0      0   if ($fks[$i]{'parent_tbl'} eq $fks[$j]{'parent_tbl'} and $i_cols eq $j_cols and $i_pcols eq $j_pcols)
2523  ***      0      0      0   if $args{'callback'}
2538  ***      0      0      0   if ($right_keys != $left_keys) { }
2564  ***      0      0      0   unless defined $$left_keys[$left_index]
2568  ***      0      0      0   unless defined $$right_keys[$right_index]
2580  ***      0      0      0   if (substr($left_cols, 0, $right_len_cols) eq substr($right_cols, 0, $right_len_cols)) { }
2583  ***      0      0      0   if ($args{'exact_duplicates'} and $right_len_cols < $left_len_cols)
2588  ***      0      0      0   if (exists $$right_keys[$right_index]{'unique_col'})
2597  ***      0      0      0   if ($$right_keys[$right_index]{'unconstrained'})
2602  ***      0      0      0   $right_len_cols < $left_len_cols ? :
2603  ***      0      0      0   $exact_dupe ? :
2607  ***      0      0      0   $exact_dupe ? :
2620  ***      0      0      0   if $args{'callback'}
2638  ***      0      0      0   unless $ck
2639  ***      0      0      0   unless $keys
2649  ***      0      0      0   if (substr($suffix, 0, $len) eq substr($ck_cols, 0, $len))
2668  ***      0      0      0   if $args{'callback'}
2682  ***      0      0      0   if $ck_cols eq $dupe_key_cols
2690  ***      0      0      0   unless $unique_keys
2700  ***      0      0      0   unless $unique_key
2702  ***      0      0      0   if (@$cols == 1) { }
2704  ***      0      0      0   if (not exists $unique_cols{$$cols[0]})
2721  ***      0      0      0   if (exists $unique_cols{$col})
2724  ***      0      0      0   if ++$n_unique_cols > 1
2728  ***      0      0      0   if ($n_unique_cols and $$unique_set{'key'}{'name'} ne 'PRIMARY')
2740  ***      0      0      0   if (exists $unconstrain{$$unique_keys[$i]{'name'}})
2756  ***      0      0      0   defined $_ ? :
2803  ***      0      0      0   defined $args{'p_ms'} ? :
2804  ***      0      0      0   defined $args{'p_s'} ? :
2807  ***      0      0      0   if $t < 0
2809  ***      0      0      0   if $t =~ /e/
2813  ***      0      0      0   if ($t > 0 and $t <= 0.000999) { }
      ***      0      0      0   elsif ($t >= 0.001 and $t <= 0.999999) { }
      ***      0      0      0   elsif ($t >= 1) { }
2834  ***      0      0      0   $p ? :
2841  ***      0      0      0   unless $secs
2843  ***      0      0      0   $secs >= 3600 ? :
      ***      0      0      0   $secs >= 86400 ? :
2848  ***      0      0      0   $fmt eq 'h' ? :
      ***      0      0      0   $fmt eq 'd' ? :
2867  ***      0      0      0   defined $args{'p'} ? :
2868  ***      0      0      0   defined $args{'d'} ? :
2875  ***      0      0      0   $num =~ /\./ || $n ? :
2884  ***      0      0      0   $gmt ? :
2890  ***      0      0      0   if (my($us) = $time =~ /(\.\d+)$/)
2900  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s, $f) = $val =~ /^$mysql_ts$/)
2903  ***      0      0      0   defined $f ? :
      ***      0      0      0   defined $f ? :
2912  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s, $us) = $val =~ /^$proper_ts$/)
2913  ***      0      0      0   $gmt ? :
2916  ***      0      0      0   if (defined $us)
2928  ***      0      0      0   if (my($n, $suffix) = $val =~ /^$n_ts$/) { }
      ***      0      0      0   elsif (my($ymd, $hms) = $val =~ /^(\d{6})(?:\s+(\d+:\d+:\d+))?/) { }
      ***      0      0      0   elsif (($ymd, $hms) = $val =~ /^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) { }
2929  ***      0      0      0   $suffix eq 'd' ? :
      ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
2939  ***      0      0      0   unless $hms
2944  ***      0      0      0   unless $hms
2949  ***      0      0      0   if $callback and ref $callback eq 'CODE'
2965  ***      0      0      0   defined $_ ? :
2994  ***      0      0      0   unless $args{$arg}
2997  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
3013  ***      0      0      0   unless defined(my $pid = fork)
3014  ***      0      0      0   if ($pid)
3021  ***      0      0      0   unless POSIX::setsid()
3022  ***      0      0      0   unless chdir '/'
3028  ***      0      0      0   if (-t STDIN)
3030  ***      0      0      0   unless open STDIN, '/dev/null'
3034  ***      0      0      0   if ($$self{'log_file'}) { }
3036  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
3040  ***      0      0      0   unless open STDERR, '>&STDOUT'
3044  ***      0      0      0   if (-t STDOUT)
3046  ***      0      0      0   unless open STDOUT, '>', '/dev/null'
3049  ***      0      0      0   if (-t STDERR)
3051  ***      0      0      0   unless open STDERR, '>', '/dev/null'
3062  ***      0      0      0   $self ? :
3064  ***      0      0      0   if ($PID_file and -f $PID_file) { }
3067  ***      0      0      0   if $EVAL_ERROR
3069  ***      0      0      0   if ($pid) { }
3071  ***      0      0      0   if ($pid_is_alive) { }
3093  ***      0      0      0   if (exists $$self{'child'})
3105  ***      0      0      0   if (not $PID_file)
3112  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
3114  ***      0      0      0   unless print $PID_FH $PID
3116  ***      0      0      0   unless close $PID_FH
3125  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
3126  ***      0      0      0   unless unlink $$self{'PID_file'}
3138  ***      0      0      0   if $$self{'child'} or $$self{'rm_PID_file'}
3144  ***      0      0      0   defined $_ ? :
3205  ***      0      0      0   if ($o->get('pid'))
3216  ***      0      0      0   $o->get('key-types') =~ /k/ ? :
3217  ***      0      0      0   $o->get('key-types') =~ /f/ ? :
3220  ***      0      0      0   if ($o->got('ask-pass') and not $o->got('password'))
3231  ***      0      0      0   $o->get('summary') ? :
3278  ***      0      0      0   if $get_keys
3280  ***      0      0      0   if $get_fks
3282  ***      0      0      0   unless %$keys or %$fks
3284  ***      0      0      0   if ($o->got('verbose')) { }
3285  ***      0      0      0   if $keys
3286  ***      0      0      0   if $fks
3290  ***      0      0      0   if $keys
3304  ***      0      0      0   if $fks
3324  ***      0      0      0   if $o->get('summary')
3335  ***      0      0      0   unless $keys
3338  ***      0      0      0   if (not $seen_tbl{"$db$tbl"}++)
3352  ***      0      0      0   unless $dupe
3354  ***      0      0      0   unless exists $args{$arg}
3364  ***      0      0      0   if (not $seen_tbl{"$db$tbl"}++)
3381  ***      0      0      0   if $seen{$col}++
3386  ***      0      0      0   if ($o->get('sql'))
3387  ***      0      0      0   if ($$dupe{'dupe_type'} ne 'clustered') { }
3388  ***      0      0      0   $args{'is_fk'} ? :
      ***      0      0      0   $args{'is_fk'} ? :
3405  ***      0      0      0   if ($o->get('summary'))
3414  ***      0      0      0   if ($args{'is_fk'}) { }
3425  ***      0      0      0   if ($size)
3426  ***      0      0      0   if ($chosen_key and $chosen_key ne $$dupe{'key'})
3452  ***      0      0      0   defined $_ ? :


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
362   ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/
      ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/
      ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete
400   ***      0      0      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000'
      ***      0      0      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i
431   ***      0      0      0      0   $engine =~ /InnoDB/i and not $clustered_key
433   ***      0      0      0      0   $$this_key{'is_unique'} and not $$this_key{'is_nullable'}
457   ***      0      0      0      0   not $parent =~ /\./ and $$opts{'database'}
592   ***      0      0      0      0   $trgs and @$trgs
638   ***      0      0      0      0   $curr and $new
      ***      0      0      0      0   $curr and $new and $curr eq $new
863   ***      0      0      0      0   $$self{'need_engine'} and not defined $args{'parser'}
953   ***      0      0      0      0   $curr and $new
      ***      0      0      0      0   $curr and $new and $curr eq $new
1010  ***      0      0      0      0   !$$reject{$val} && !$$reject{$tbl}
      ***      0      0      0      0   !$reject || !$$reject{$val} && !$$reject{$tbl} and !$permit || $$permit{$val} || $$permit{$tbl}
1015  ***      0      0      0      0   !$reject || !$$reject{$val} and !$permit || $$permit{$val}
1038  ***      0      0      0      0   $equality eq '-' && $$table{$prop} gt $time
      ***      0      0      0      0   $equality eq '+' && $$table{$prop} lt $time
1165  ***     66     20     20      0   not defined $final_props{$key} and defined $$prev{$key}
      ***     33     40      0      0   not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'}
1287  ***     66      5      0      5   not $dbh and $tries--
1323  ***     33      5      0      0   not $dbh and $EVAL_ERROR
1644  ***      0      0      0      0   $type and $type eq 'd'
      ***      0      0      0      0   $type and $type eq 'd' and not $$self{'dp'}
1649  ***      0      0      0      0   $type and $type =~ /[HhAadzm]/
1788  ***      0      0      0      0   @ARGV and $ARGV[0] eq '--config'
1817  ***      0      0      0      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
1824  ***      0      0      0      0   @ARGV and $$self{'strict'}
1908  ***      0      0      0      0   $opt and $$opt{'type'}
1911  ***      0      0      0      0   $val and $$opt{'type'} eq 'm'
      ***      0      0      0      0   $val and $$opt{'type'} eq 'd'
      ***      0      0      0      0   $val and $$opt{'type'} eq 'z'
      ***      0      0      0      0   defined $val and $$opt{'type'} eq 'h'
      ***      0      0      0      0   defined $val and $$opt{'type'} eq 'a'
1976  ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
1984  ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
1998  ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
2087  ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
2181  ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
2325  ***      0      0      0      0   $key_len and $rows
2326  ***      0      0      0      0   $chosen_key =~ /,/ and $key_len =~ /,/
2418  ***      0      0      0      0   $args{'clustered_key'} and $$key{'name'} eq $args{'clustered_key'}
2468  ***      0      0      0      0   $clustered_key and $args{'clustered'}
      ***      0      0      0      0   $clustered_key and $args{'clustered'} and $args{'tbl_info'}{'engine'}
      ***      0      0      0      0   $clustered_key and $args{'clustered'} and $args{'tbl_info'}{'engine'} and $args{'tbl_info'}{'engine'} =~ /InnoDB/i
2501  ***      0      0      0      0   $fks[$i]{'parent_tbl'} eq $fks[$j]{'parent_tbl'} and $i_cols eq $j_cols
      ***      0      0      0      0   $fks[$i]{'parent_tbl'} eq $fks[$j]{'parent_tbl'} and $i_cols eq $j_cols and $i_pcols eq $j_pcols
2583  ***      0      0      0      0   $args{'exact_duplicates'} and $right_len_cols < $left_len_cols
2728  ***      0      0      0      0   $n_unique_cols and $$unique_set{'key'}{'name'} ne 'PRIMARY'
2813  ***      0      0      0      0   $t > 0 and $t <= 0.000999
      ***      0      0      0      0   $t >= 0.001 and $t <= 0.999999
2871  ***      0      0      0      0   $num >= $d and $n < @units - 1
2949  ***      0      0      0      0   $callback and ref $callback eq 'CODE'
3064  ***      0      0      0      0   $PID_file and -f $PID_file
3125  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
3220  ***      0      0      0      0   $o->got('ask-pass') and not $o->got('password')
3426  ***      0      0      0      0   $chosen_key and $chosen_key ne $$dupe{'key'}

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
40    ***     50      0      6   $ENV{'MKDEBUG'} || 0
89    ***     50      0      6   $ENV{'MKDEBUG'} || 0
157   ***     50      0      6   $ENV{'MKDEBUG'} || 0
376   ***      0      0      0   $engine || undef
399   ***      0      0      0   $type || $special || 'BTREE'
486   ***      0      0      0   $$tbl_struct{'engine'} || ''
488   ***      0      0      0   $clustered_key ||= ''
539   ***     50      0      6   $ENV{'MKDEBUG'} || 0
809   ***      0      0      0   $$_[1] || ''
849   ***     50      0      6   $ENV{'MKDEBUG'} || 0
1075  ***     50      0      6   $ENV{'MKDEBUG'} || 0
1146  ***     50      0      5   $prev ||= {}
1147  ***     50      0      5   $defaults ||= {}
1220  ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
1233  ***     50      0      5   $self->prop('dbidriver') || ''
1237  ***      0      0      0   $$info{'D'} || ''
1243  ***     50      0      5   $$info{'D'} || ''
1265  ***     50      5      0   $opts ||= {}
1360  ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
1376  ***      0      0      0   $level ||= 0
1377  ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
1429  ***     50      0      6   $ENV{'MKDEBUG'} || 0
1449  ***      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
1451  ***      0      0      0   $args{'prompt'} || '<options>'
      ***      0      0      0   $args{'dp'} || undef
1493  ***      0      0      0   $file ||= '/home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker'
1634  ***      0      0      0   $$opt{'group'} ||= 'default'
1916  ***      0      0      0   $s || 's'
1925  ***      0      0      0   $prefix || ''
1953  ***      0      0      0   $pre || ''
1960  ***      0      0      0   $val || ''
1963  ***      0      0      0   $val || ''
2021  ***      0      0      0   $$self{'description'} || ''
2089  ***      0      0      0   $s ||= 's'
2115  ***      0      0      0   $$opt{'type'} || ''
2262  ***     50      0      6   $ENV{'MKDEBUG'} || 0
2394  ***     50      0      6   $ENV{'MKDEBUG'} || 0
2779  ***     50      0      6   $ENV{'MKDEBUG'} || 0
2833  ***      0      0      0   $args{'p'} || 0
2835  ***      0      0      0   $of ||= 1
2840  ***      0      0      0   $secs ||= 0
2989  ***     50      0      6   $ENV{'MKDEBUG'} || 0
3172  ***     50      0      6   $ENV{'MKDEBUG'} || 0
3375  ***      0      0      0   $$dupe{'ddl'} || ''
3376  ***      0      0      0   $$dupe{'duplicate_of_ddl'} || ''
3420  ***      0      0      0   $size ||= 0

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
250   ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'}
      ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
329   ***      0      0      0      0   not $$row[0] or $$row[0] ne $tbl
350   ***      0      0      0      0   $$row{'privileges'} || $$row{'Privileges'}
399   ***      0      0      0      0   $type || $special
650   ***      0      0      0      0   not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl}
689   ***      0      0      0      0   not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl}
719   ***      0      0      0      0   not $$self{'cache'} or not $$self{'triggers'}{$db}
753   ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'} or $like
772   ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db} or $like
786   ***      0      0      0      0   $tbl{'type'} || $tbl{'comment'}
      ***      0      0      0      0   $tbl{'engine'} ||= $tbl{'type'} || $tbl{'comment'}
798   ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db} or $like
859   ***      0      0      0      0   $$self{'engines'}{'permit'} || $$self{'engines'}{'reject'}
      ***      0      0      0      0   $$self{'engines'}{'permit'} || $$self{'engines'}{'reject'} || $$self{'engines'}{'regexp'}
1010  ***      0      0      0      0   not $regexp or $val =~ /$regexp/
      ***      0      0      0      0   !$reject || !$$reject{$val} && !$$reject{$tbl}
      ***      0      0      0      0   !$permit || $$permit{$val}
      ***      0      0      0      0   !$permit || $$permit{$val} || $$permit{$tbl}
1015  ***      0      0      0      0   not $regexp or $val =~ /$regexp/
      ***      0      0      0      0   !$reject || !$$reject{$val}
      ***      0      0      0      0   !$permit || $$permit{$val}
1035  ***      0      0      0      0   $$self{'timestamp'}{$dbh}{$num} ||= $dbh->selectrow_array($sql)
1038  ***      0      0      0      0   $equality eq '-' && $$table{$prop} gt $time || $equality eq '+' && $$table{$prop} lt $time
1256  ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
1257  ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
1258  ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
1259  ***      0      0      0      0   $$dsn{'u'} ||= $user
1260  ***      0      0      0      0   $$dsn{'D'} ||= $db
1448  ***      0      0      0      0   $program_name ||= $PROGRAM_NAME
1449  ***      0      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***      0      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
1911  ***      0      0      0      0   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***      0      0      0      0   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
2418  ***      0      0      0      0   $$key{'name'} eq 'PRIMARY' or $args{'clustered_key'} and $$key{'name'} eq $args{'clustered_key'}
2426  ***      0      0      0      0   $args{'ignore_order'} or $is_fulltext
2843  ***      0      0      0      0   $fmt ||= $secs >= 86400 ? 'd' : ($secs >= 3600 ? 'h' : 'm')
2875  ***      0      0      0      0   $num =~ /\./ || $n
3138  ***      0      0      0      0   $$self{'child'} or $$self{'rm_PID_file'}
3270  ***      0      0      0      0   $tp->get_engine($ddl) || next TABLE
3282  ***      0      0      0      0   %$keys or %$fks


Covered Subroutines
-------------------

Subroutine                  Count Location                                                                       
--------------------------- ----- -------------------------------------------------------------------------------
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1063
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1064
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1065
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1066
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1075
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1422
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1423
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1425
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1426
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1427
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1429
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:149 
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:150 
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:151 
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:152 
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:157 
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2258
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2259
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2260
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2262
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:23  
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2388
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2389
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2390
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2392
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2394
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:24  
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2773
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2774
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2775
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2776
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2777
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2779
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2983
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2984
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2986
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2987
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2989
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3166
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3167
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3168
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3172
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:35  
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:36  
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:38  
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:40  
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:534 
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:535 
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:537 
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:539 
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:82  
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:83  
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:841 
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:842 
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:844 
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:845 
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:849 
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:87  
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:89  
get_cxn_params                  5 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1230
get_dbh                         5 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1264
new                             5 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1078
new                             6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:161 
new                             6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:92  
parse                           5 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1140
prop                           15 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1131

Uncovered Subroutines
---------------------

Subroutine                  Count Location                                                                       
--------------------------- ----- -------------------------------------------------------------------------------
DESTROY                         0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3137
__ANON__                        0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1812
__ANON__                        0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:887 
__ANON__                        0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:898 
__ANON__                        0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:913 
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1045
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1404
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2240
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2370
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2755
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2964
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3143
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3451
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:516 
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:66  
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:823 
_explain_to_text                0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2362
_fetch_tbl_list                 0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:964 
_filter                         0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1000
_get_participants               0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1712
_key_exists                     0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2357
_make_PID_file                  0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3102
_parse_specs                    0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1598
_pod_to_specs                   0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1492
_read_config_file               0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2164
_remove_PID_file                0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3124
_set_option                     0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1758
_test_date                      0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1023
_use_db                         0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:630 
_use_db                         0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:945 
_validate_type                  0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1907
any_unix_timestamp              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2926
as_string                       0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1204
check_PID_file                  0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3061
check_table                     0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:308 
clone                           0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2217
copy                            0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1386
daemonize                       0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3010
descr                           0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2020
disconnect                      0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1369
dump                            0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:573 
error                           0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2352
errors                          0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2010
explain                         0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2347
fill_in_dsn                     0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1252
find_best_index                 0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:262 
find_databases                  0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:884 
find_possible_keys              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:280 
find_tables                     0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:895 
find_views                      0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:937 
get                             0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1974
get_columns                     0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:687 
get_create_table                0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:649 
get_databases                   0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:752 
get_defaults                    0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1748
get_defaults_files              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1487
get_duplicate_fks               0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2486
get_duplicate_keys              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2403
get_engine                      0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:373 
get_fks                         0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:447 
get_groups                      0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1753
get_hostname                    0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1359
get_key_size                    0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2271
get_keys                        0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:380 
get_opts                        0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1775
get_specs                       0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1480
get_table_list                  0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:797 
get_table_status                0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:771 
get_tmp_table                   0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:707 
get_triggers                    0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:718 
got                             0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1982
has                             0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1990
init_timestamp                  0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:875 
literal_like                    0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:132 
main                            0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3187
make_PID_file                   0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3092
make_checksum                   0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2957
micro_t                         0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2802
new                             0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1443
new                             0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2265
new                             0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2397
new                             0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2992
new                             0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:43  
new                             0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:566 
new                             0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:853 
opts                            0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1724
parse                           0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:172 
parse                           0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:48  
parse_options                   0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1191
parse_timestamp                 0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2899
percentage_of                   0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2832
print_active_handles            0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1375
print_all_keys                  0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3334
print_duplicate_key             0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3351
print_errors                    0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2044
print_key_summary               0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3437
print_usage                     0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2054
prompt                          0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2015
prompt_noecho                   0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2129
query                           0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2342
quote                           0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:97  
quote_val                       0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:105 
read_para_after                 0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2198
remove_auto_increment           0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:476 
remove_clustered_duplicates     0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2637
remove_prefix_duplicates        0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2531
remove_secondary_indexes        0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:482 
save_error                      0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2005
secs_to_time                    0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2839
set                             0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1996
set_defaults                    0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1736
short_opts                      0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1730
shorten                         0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2866
shorten_clustered_duplicate     0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2681
sort_indexes                    0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:243 
split_unquote                   0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:121 
ts                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2883
unconstrain_keys                0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2689
unix_timestamp                  0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2911
usage                           0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1213
usage_or_errors                 0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2031
version_ge                      0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:55  


