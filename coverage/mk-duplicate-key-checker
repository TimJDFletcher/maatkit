---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
.../mk-duplicate-key-checker   14.2    2.2    3.3   36.4    n/a  100.0   11.5
Total                          14.2    2.2    3.3   36.4    n/a  100.0   11.5
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          mk-duplicate-key-checker.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Jun 12 18:40:10 2009
Finish:       Fri Jun 12 18:40:12 2009

/home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This is mk-duplicate-key-checker, a program to analyze MySQL tables for
4                                                     # duplicated or redundant indexes and foreign key constraints.
5                                                     # 
6                                                     # This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
7                                                     # Feedback and improvements are welcome.
8                                                     #
9                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
10                                                    # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
11                                                    # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
12                                                    #
13                                                    # This program is free software; you can redistribute it and/or modify it under
14                                                    # the terms of the GNU General Public License as published by the Free Software
15                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
16                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
17                                                    # licenses.
18                                                    #
19                                                    # You should have received a copy of the GNU General Public License along with
20                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
21                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
22                                                    
23             1                    1             5   use strict;
               1                                  6   
               1                                  7   
24             1                    1           104   use warnings FATAL => 'all';
               1                                  3   
               1                                  9   
25                                                    
26                                                    our $VERSION = '@VERSION@';
27                                                    our $DISTRIB = '@DISTRIB@';
28                                                    our $SVN_REV = sprintf("%d", (q$Revision: 3924 $ =~ m/(\d+)/g, 0));
29                                                    
30                                                    # ###########################################################################
31                                                    # VersionParser package 3186
32                                                    # ###########################################################################
33                                                    package VersionParser;
34                                                    
35             1                    1             6   use strict;
               1                                  2   
               1                                  4   
36             1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                  4   
37                                                    
38             1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  8   
39                                                    
40             1                    1             7   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                 11   
41                                                    
42                                                    sub new {
43    ***      0                    0             0      my ( $class ) = @_;
44    ***      0                                  0      bless {}, $class;
45                                                    }
46                                                    
47                                                    sub parse {
48    ***      0                    0             0      my ( $self, $str ) = @_;
49    ***      0                                  0      my $result = sprintf('%03d%03d%03d', $str =~ m/(\d+)/g);
50    ***      0                                  0      MKDEBUG && _d($str, 'parses to', $result);
51    ***      0                                  0      return $result;
52                                                    }
53                                                    
54                                                    sub version_ge {
55    ***      0                    0             0      my ( $self, $dbh, $target ) = @_;
56    ***      0      0                           0      if ( !$self->{$dbh} ) {
57    ***      0                                  0         $self->{$dbh} = $self->parse(
58                                                             $dbh->selectrow_array('SELECT VERSION()'));
59                                                       }
60    ***      0      0                           0      my $result = $self->{$dbh} ge $self->parse($target) ? 1 : 0;
61    ***      0                                  0      MKDEBUG && _d($self->{$dbh}, 'ge', $target, ':', $result);
62    ***      0                                  0      return $result;
63                                                    }
64                                                    
65                                                    sub _d {
66    ***      0                    0             0      my ($package, undef, $line) = caller 0;
67    ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
68    ***      0                                  0           map { defined $_ ? $_ : 'undef' }
69                                                            @_;
70    ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
71                                                    }
72                                                    
73                                                    1;
74                                                    
75                                                    # ###########################################################################
76                                                    # End VersionParser package
77                                                    # ###########################################################################
78                                                    
79                                                    # ###########################################################################
80                                                    # Quoter package 3186
81                                                    # ###########################################################################
82             1                    1             6   use strict;
               1                                  3   
               1                                  4   
83             1                    1             5   use warnings FATAL => 'all';
               1                                  2   
               1                                  5   
84                                                    
85                                                    package Quoter;
86                                                    
87             1                    1             6   use English qw(-no_match_vars);
               1                                  5   
               1                                  4   
88                                                    
89             1                    1             6   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                  7   
90                                                    
91                                                    sub new {
92             1                    1             4      my ( $class ) = @_;
93             1                                 14      bless {}, $class;
94                                                    }
95                                                    
96                                                    sub quote {
97    ***      0                    0             0      my ( $self, @vals ) = @_;
98    ***      0                                  0      foreach my $val ( @vals ) {
99    ***      0                                  0         $val =~ s/`/``/g;
100                                                      }
101   ***      0                                  0      return join('.', map { '`' . $_ . '`' } @vals);
      ***      0                                  0   
102                                                   }
103                                                   
104                                                   sub quote_val {
105   ***      0                    0             0      my ( $self, @vals ) = @_;
106                                                      return join(', ',
107                                                         map {
108   ***      0      0                           0            if ( defined $_ ) {
      ***      0                                  0   
109   ***      0                                  0               $_ =~ s/(['\\])/\\$1/g;
110   ***      0      0      0                    0               $_ eq '' || $_ =~ m/^0|\D/ ? "'$_'" : $_;
111                                                            }
112                                                            else {
113   ***      0                                  0               'NULL';
114                                                            }
115                                                         } @vals
116                                                      );
117                                                   }
118                                                   
119                                                   sub split_unquote {
120   ***      0                    0             0      my ( $self, $db_tbl, $default_db ) = @_;
121   ***      0                                  0      $db_tbl =~ s/`//g;
122   ***      0                                  0      my ( $db, $tbl ) = split(/[.]/, $db_tbl);
123   ***      0      0                           0      if ( !$tbl ) {
124   ***      0                                  0         $tbl = $db;
125   ***      0                                  0         $db  = $default_db;
126                                                      }
127   ***      0                                  0      return ($db, $tbl);
128                                                   }
129                                                   
130                                                   1;
131                                                   
132                                                   # ###########################################################################
133                                                   # End Quoter package
134                                                   # ###########################################################################
135                                                   
136                                                   # ###########################################################################
137                                                   # TableParser package 3475
138                                                   # ###########################################################################
139                                                   package TableParser;
140                                                   
141            1                    1             7   use strict;
               1                                  6   
               1                                  5   
142            1                    1             6   use warnings FATAL => 'all';
               1                                  7   
               1                                  5   
143            1                    1             6   use English qw(-no_match_vars);
               1                                  6   
               1                                  4   
144                                                   
145            1                    1             6   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                  7   
146                                                   
147                                                   sub new {
148            1                    1             4      my ( $class ) = @_;
149            1                                  9      return bless {}, $class;
150                                                   }
151                                                   
152                                                   
153                                                   sub parse {
154   ***      0                    0             0      my ( $self, $ddl, $opts ) = @_;
155                                                   
156   ***      0      0                           0      if ( ref $ddl eq 'ARRAY' ) {
157   ***      0      0                           0         if ( lc $ddl->[0] eq 'table' ) {
158   ***      0                                  0            $ddl = $ddl->[1];
159                                                         }
160                                                         else {
161                                                            return {
162   ***      0                                  0               engine => 'VIEW',
163                                                            };
164                                                         }
165                                                      }
166                                                   
167   ***      0      0                           0      if ( $ddl !~ m/CREATE (?:TEMPORARY )?TABLE `/ ) {
168   ***      0                                  0         die "Cannot parse table definition; is ANSI quoting "
169                                                            . "enabled or SQL_QUOTE_SHOW_CREATE disabled?";
170                                                      }
171                                                   
172   ***      0                                  0      $ddl =~ s/(`[^`]+`)/\L$1/g;
173                                                   
174   ***      0                                  0      my $engine = $self->get_engine($ddl);
175                                                   
176   ***      0                                  0      my @defs   = $ddl =~ m/^(\s+`.*?),?$/gm;
177   ***      0                                  0      my @cols   = map { $_ =~ m/`([^`]+)`/ } @defs;
      ***      0                                  0   
178   ***      0                                  0      MKDEBUG && _d('Columns:', join(', ', @cols));
179                                                   
180   ***      0                                  0      my %def_for;
181   ***      0                                  0      @def_for{@cols} = @defs;
182                                                   
183   ***      0                                  0      my (@nums, @null);
184   ***      0                                  0      my (%type_for, %is_nullable, %is_numeric, %is_autoinc);
185   ***      0                                  0      foreach my $col ( @cols ) {
186   ***      0                                  0         my $def = $def_for{$col};
187   ***      0                                  0         my ( $type ) = $def =~ m/`[^`]+`\s([a-z]+)/;
188   ***      0      0                           0         die "Can't determine column type for $def" unless $type;
189   ***      0                                  0         $type_for{$col} = $type;
190   ***      0      0                           0         if ( $type =~ m/(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/ ) {
191   ***      0                                  0            push @nums, $col;
192   ***      0                                  0            $is_numeric{$col} = 1;
193                                                         }
194   ***      0      0                           0         if ( $def !~ m/NOT NULL/ ) {
195   ***      0                                  0            push @null, $col;
196   ***      0                                  0            $is_nullable{$col} = 1;
197                                                         }
198   ***      0      0                           0         $is_autoinc{$col} = $def =~ m/AUTO_INCREMENT/i ? 1 : 0;
199                                                      }
200                                                   
201   ***      0                                  0      my $keys = $self->get_keys($ddl, $opts, \%is_nullable);
202                                                   
203                                                      return {
204   ***      0                                  0         cols           => \@cols,
205   ***      0                                  0         col_posn       => { map { $cols[$_] => $_ } 0..$#cols },
206   ***      0                                  0         is_col         => { map { $_ => 1 } @cols },
207                                                         null_cols      => \@null,
208                                                         is_nullable    => \%is_nullable,
209                                                         is_autoinc     => \%is_autoinc,
210                                                         keys           => $keys,
211                                                         defs           => \%def_for,
212                                                         numeric_cols   => \@nums,
213                                                         is_numeric     => \%is_numeric,
214                                                         engine         => $engine,
215                                                         type_for       => \%type_for,
216                                                      };
217                                                   }
218                                                   
219                                                   sub sort_indexes {
220   ***      0                    0             0      my ( $self, $tbl ) = @_;
221                                                   
222                                                      my @indexes
223   ***      0                                  0         = sort {
224   ***      0                                  0            (($a ne 'PRIMARY') <=> ($b ne 'PRIMARY'))
225                                                            || ( !$tbl->{keys}->{$a}->{is_unique} <=> !$tbl->{keys}->{$b}->{is_unique} )
226                                                            || ( $tbl->{keys}->{$a}->{is_nullable} <=> $tbl->{keys}->{$b}->{is_nullable} )
227   ***      0      0      0                    0            || ( scalar(@{$tbl->{keys}->{$a}->{cols}}) <=> scalar(@{$tbl->{keys}->{$b}->{cols}}) )
      ***      0             0                    0   
228                                                         }
229                                                         grep {
230   ***      0                                  0            $tbl->{keys}->{$_}->{type} eq 'BTREE'
231                                                         }
232   ***      0                                  0         sort keys %{$tbl->{keys}};
233                                                   
234   ***      0                                  0      MKDEBUG && _d('Indexes sorted best-first:', join(', ', @indexes));
235   ***      0                                  0      return @indexes;
236                                                   }
237                                                   
238                                                   sub find_best_index {
239   ***      0                    0             0      my ( $self, $tbl, $index ) = @_;
240   ***      0                                  0      my $best;
241   ***      0      0                           0      if ( $index ) {
242   ***      0                                  0         ($best) = grep { uc $_ eq uc $index } keys %{$tbl->{keys}};
      ***      0                                  0   
      ***      0                                  0   
243                                                      }
244   ***      0      0                           0      if ( !$best ) {
245   ***      0      0                           0         if ( $index ) {
246   ***      0                                  0            die "Index '$index' does not exist in table";
247                                                         }
248                                                         else {
249   ***      0                                  0            ($best) = $self->sort_indexes($tbl);
250                                                         }
251                                                      }
252   ***      0                                  0      MKDEBUG && _d('Best index found is', $best);
253   ***      0                                  0      return $best;
254                                                   }
255                                                   
256                                                   sub find_possible_keys {
257   ***      0                    0             0      my ( $self, $dbh, $database, $table, $quoter, $where ) = @_;
258   ***      0      0                           0      return () unless $where;
259   ***      0                                  0      my $sql = 'EXPLAIN SELECT * FROM ' . $quoter->quote($database, $table)
260                                                         . ' WHERE ' . $where;
261   ***      0                                  0      MKDEBUG && _d($sql);
262   ***      0                                  0      my $expl = $dbh->selectrow_hashref($sql);
263   ***      0                                  0      $expl = { map { lc($_) => $expl->{$_} } keys %$expl };
      ***      0                                  0   
264   ***      0      0                           0      if ( $expl->{possible_keys} ) {
265   ***      0                                  0         MKDEBUG && _d('possible_keys =', $expl->{possible_keys});
266   ***      0                                  0         my @candidates = split(',', $expl->{possible_keys});
267   ***      0                                  0         my %possible   = map { $_ => 1 } @candidates;
      ***      0                                  0   
268   ***      0      0                           0         if ( $expl->{key} ) {
269   ***      0                                  0            MKDEBUG && _d('MySQL chose', $expl->{key});
270   ***      0                                  0            unshift @candidates, grep { $possible{$_} } split(',', $expl->{key});
      ***      0                                  0   
271   ***      0                                  0            MKDEBUG && _d('Before deduping:', join(', ', @candidates));
272   ***      0                                  0            my %seen;
273   ***      0                                  0            @candidates = grep { !$seen{$_}++ } @candidates;
      ***      0                                  0   
274                                                         }
275   ***      0                                  0         MKDEBUG && _d('Final list:', join(', ', @candidates));
276   ***      0                                  0         return @candidates;
277                                                      }
278                                                      else {
279   ***      0                                  0         MKDEBUG && _d('No keys in possible_keys');
280   ***      0                                  0         return ();
281                                                      }
282                                                   }
283                                                   
284                                                   sub table_exists {
285   ***      0                    0             0      my ( $self, $dbh, $db, $tbl, $q, $can_insert ) = @_;
286   ***      0                                  0      my $result = 0;
287   ***      0                                  0      my $db_tbl = $q->quote($db, $tbl);
288   ***      0                                  0      my $sql    = "SHOW FULL COLUMNS FROM $db_tbl";
289   ***      0                                  0      MKDEBUG && _d($sql);
290   ***      0                                  0      eval {
291   ***      0                                  0         my $sth = $dbh->prepare($sql);
292   ***      0                                  0         $sth->execute();
293   ***      0                                  0         my @columns = @{$sth->fetchall_arrayref({})};
      ***      0                                  0   
294   ***      0      0                           0         if ( $can_insert ) {
295   ***      0             0                    0            $result = grep { ($_->{Privileges} || '') =~ m/insert/ } @columns;
      ***      0                                  0   
296                                                         }
297                                                         else {
298   ***      0                                  0            $result = 1;
299                                                         }
300                                                      };
301   ***      0                                  0      if ( MKDEBUG && $EVAL_ERROR ) {
302                                                         _d($EVAL_ERROR);
303                                                      }
304   ***      0                                  0      return $result;
305                                                   }
306                                                   
307                                                   sub get_engine {
308   ***      0                    0             0      my ( $self, $ddl, $opts ) = @_;
309   ***      0                                  0      my ( $engine ) = $ddl =~ m/\).*?(?:ENGINE|TYPE)=(\w+)/;
310   ***      0                                  0      MKDEBUG && _d('Storage engine:', $engine);
311   ***      0             0                    0      return $engine || undef;
312                                                   }
313                                                   
314                                                   sub get_keys {
315   ***      0                    0             0      my ( $self, $ddl, $opts, $is_nullable ) = @_;
316   ***      0                                  0      my $engine = $self->get_engine($ddl);
317   ***      0                                  0      my $keys   = {};
318                                                   
319                                                      KEY:
320   ***      0                                  0      foreach my $key ( $ddl =~ m/^  ((?:[A-Z]+ )?KEY .*)$/gm ) {
321                                                   
322   ***      0      0                           0         next KEY if $key =~ m/FOREIGN/;
323                                                   
324   ***      0                                  0         MKDEBUG && _d('Parsed key:', $key);
325                                                   
326   ***      0      0                           0         if ( $engine !~ m/MEMORY|HEAP/ ) {
327   ***      0                                  0            $key =~ s/USING HASH/USING BTREE/;
328                                                         }
329                                                   
330   ***      0                                  0         my ( $type, $cols ) = $key =~ m/(?:USING (\w+))? \((.+)\)/;
331   ***      0                                  0         my ( $special ) = $key =~ m/(FULLTEXT|SPATIAL)/;
332   ***      0             0                    0         $type = $type || $special || 'BTREE';
      ***                    0                        
333   ***      0      0      0                    0         if ( $opts->{mysql_version} && $opts->{mysql_version} lt '004001000'
      ***                    0                        
334                                                            && $engine =~ m/HEAP|MEMORY/i )
335                                                         {
336   ***      0                                  0            $type = 'HASH'; # MySQL pre-4.1 supports only HASH indexes on HEAP
337                                                         }
338                                                   
339   ***      0                                  0         my ($name) = $key =~ m/(PRIMARY|`[^`]*`)/;
340   ***      0      0                           0         my $unique = $key =~ m/PRIMARY|UNIQUE/ ? 1 : 0;
341   ***      0                                  0         my @cols;
342   ***      0                                  0         my @col_prefixes;
343   ***      0                                  0         foreach my $col_def ( split(',', $cols) ) {
344   ***      0                                  0            my ($name, $prefix) = $col_def =~ m/`([^`]+)`(?:\((\d+)\))?/;
345   ***      0                                  0            push @cols, $name;
346   ***      0                                  0            push @col_prefixes, $prefix;
347                                                         }
348   ***      0                                  0         $name =~ s/`//g;
349                                                   
350   ***      0                                  0         MKDEBUG && _d('Key', $name, 'cols:', join(', ', @cols));
351                                                   
352   ***      0                                  0         $keys->{$name} = {
353                                                            name         => $name,
354                                                            type         => $type,
355                                                            colnames     => $cols,
356                                                            cols         => \@cols,
357                                                            col_prefixes => \@col_prefixes,
358                                                            is_unique    => $unique,
359   ***      0                                  0            is_nullable  => scalar(grep { $is_nullable->{$_} } @cols),
360   ***      0                                  0            is_col       => { map { $_ => 1 } @cols },
361                                                         };
362                                                      }
363                                                   
364   ***      0                                  0      return $keys;
365                                                   }
366                                                   
367                                                   sub get_fks {
368   ***      0                    0             0      my ( $self, $ddl, $opts ) = @_;
369   ***      0                                  0      my $fks = {};
370                                                   
371   ***      0                                  0      foreach my $fk (
372                                                         $ddl =~ m/CONSTRAINT .* FOREIGN KEY .* REFERENCES [^\)]*\)/mg )
373                                                      {
374   ***      0                                  0         my ( $name ) = $fk =~ m/CONSTRAINT `(.*?)`/;
375   ***      0                                  0         my ( $cols ) = $fk =~ m/FOREIGN KEY \(([^\)]+)\)/;
376   ***      0                                  0         my ( $parent, $parent_cols ) = $fk =~ m/REFERENCES (\S+) \(([^\)]+)\)/;
377                                                   
378   ***      0      0      0                    0         if ( $parent !~ m/\./ && $opts->{database} ) {
379   ***      0                                  0            $parent = "`$opts->{database}`.$parent";
380                                                         }
381                                                   
382   ***      0                                  0         $fks->{$name} = {
383                                                            name           => $name,
384                                                            colnames       => $cols,
385   ***      0                                  0            cols           => [ map { s/[ `]+//g; $_; } split(',', $cols) ],
      ***      0                                  0   
386                                                            parent_tbl     => $parent,
387                                                            parent_colnames=> $parent_cols,
388   ***      0                                  0            parent_cols    => [ map { s/[ `]+//g; $_; } split(',', $parent_cols) ],
      ***      0                                  0   
389                                                         };
390                                                      }
391                                                   
392   ***      0                                  0      return $fks;
393                                                   }
394                                                   
395                                                   sub remove_auto_increment {
396   ***      0                    0             0      my ( $self, $ddl ) = @_;
397   ***      0                                  0      $ddl =~ s/(^\).*?) AUTO_INCREMENT=\d+\b/$1/m;
398   ***      0                                  0      return $ddl;
399                                                   }
400                                                   
401                                                   sub _d {
402   ***      0                    0             0      my ($package, undef, $line) = caller 0;
403   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
404   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
405                                                           @_;
406   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
407                                                   }
408                                                   
409                                                   1;
410                                                   
411                                                   # ###########################################################################
412                                                   # End TableParser package
413                                                   # ###########################################################################
414                                                   
415                                                   # ###########################################################################
416                                                   # MySQLDump package 3312
417                                                   # ###########################################################################
418                                                   package MySQLDump;
419                                                   
420            1                    1             7   use strict;
               1                                  9   
               1                                  6   
421            1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                  5   
422                                                   
423            1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  5   
424                                                   
425            1                    1            12   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  3   
               1                                 10   
426                                                   
427                                                   ( our $before = <<'EOF') =~ s/^   //gm;
428                                                      /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
429                                                      /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
430                                                      /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
431                                                      /*!40101 SET NAMES utf8 */;
432                                                      /*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
433                                                      /*!40103 SET TIME_ZONE='+00:00' */;
434                                                      /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
435                                                      /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
436                                                      /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
437                                                      /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
438                                                   EOF
439                                                   
440                                                   ( our $after = <<'EOF') =~ s/^   //gm;
441                                                      /*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;
442                                                      /*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
443                                                      /*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
444                                                      /*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
445                                                      /*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
446                                                      /*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
447                                                      /*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
448                                                      /*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
449                                                   EOF
450                                                   
451                                                   sub new {
452   ***      0                    0             0      my ( $class, %args ) = @_;
453   ***      0      0                           0      $args{cache} = 1 unless defined $args{cache};
454   ***      0                                  0      my $self = bless \%args, $class;
455   ***      0                                  0      return $self;
456                                                   }
457                                                   
458                                                   sub dump {
459   ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl, $what ) = @_;
460                                                   
461   ***      0      0                           0      if ( $what eq 'table' ) {
      ***             0                               
      ***             0                               
462   ***      0                                  0         my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
463   ***      0      0                           0         if ( $ddl->[0] eq 'table' ) {
464   ***      0                                  0            return $before
465                                                               . 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
466                                                               . $ddl->[1] . ";\n";
467                                                         }
468                                                         else {
469   ***      0                                  0            return 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
470                                                               . '/*!50001 DROP VIEW IF EXISTS '
471                                                               . $quoter->quote($tbl) . "*/;\n/*!50001 "
472                                                               . $self->get_tmp_table($dbh, $quoter, $db, $tbl) . "*/;\n";
473                                                         }
474                                                      }
475                                                      elsif ( $what eq 'triggers' ) {
476   ***      0                                  0         my $trgs = $self->get_triggers($dbh, $quoter, $db, $tbl);
477   ***      0      0      0                    0         if ( $trgs && @$trgs ) {
478   ***      0                                  0            my $result = $before . "\nDELIMITER ;;\n";
479   ***      0                                  0            foreach my $trg ( @$trgs ) {
480   ***      0      0                           0               if ( $trg->{sql_mode} ) {
481   ***      0                                  0                  $result .= qq{/*!50003 SET SESSION SQL_MODE='$trg->{sql_mode}' */;;\n};
482                                                               }
483   ***      0                                  0               $result .= "/*!50003 CREATE */ ";
484   ***      0      0                           0               if ( $trg->{definer} ) {
485   ***      0                                  0                  my ( $user, $host )
486   ***      0                                  0                     = map { s/'/''/g; "'$_'"; }
      ***      0                                  0   
487                                                                       split('@', $trg->{definer}, 2);
488   ***      0                                  0                  $result .= "/*!50017 DEFINER=$user\@$host */ ";
489                                                               }
490   ***      0                                  0               $result .= sprintf("/*!50003 TRIGGER %s %s %s ON %s\nFOR EACH ROW %s */;;\n\n",
491                                                                  $quoter->quote($trg->{trigger}),
492   ***      0                                  0                  @{$trg}{qw(timing event)},
493                                                                  $quoter->quote($trg->{table}),
494                                                                  $trg->{statement});
495                                                            }
496   ***      0                                  0            $result .= "DELIMITER ;\n\n/*!50003 SET SESSION SQL_MODE=\@OLD_SQL_MODE */;\n\n";
497   ***      0                                  0            return $result;
498                                                         }
499                                                         else {
500   ***      0                                  0            return undef;
501                                                         }
502                                                      }
503                                                      elsif ( $what eq 'view' ) {
504   ***      0                                  0         my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
505   ***      0                                  0         return '/*!50001 DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
506                                                            . '/*!50001 DROP VIEW IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
507                                                            . '/*!50001 ' . $ddl->[1] . "*/;\n";
508                                                      }
509                                                      else {
510   ***      0                                  0         die "You didn't say what to dump.";
511                                                      }
512                                                   }
513                                                   
514                                                   sub _use_db {
515   ***      0                    0             0      my ( $self, $dbh, $quoter, $new ) = @_;
516   ***      0      0                           0      if ( !$new ) {
517   ***      0                                  0         MKDEBUG && _d('No new DB to use');
518   ***      0                                  0         return;
519                                                      }
520   ***      0                                  0      my $sql = 'SELECT DATABASE()';
521   ***      0                                  0      MKDEBUG && _d($sql);
522   ***      0                                  0      my $curr = $dbh->selectrow_array($sql);
523   ***      0      0      0                    0      if ( $curr && $new && $curr eq $new ) {
      ***                    0                        
524   ***      0                                  0         MKDEBUG && _d('Current and new DB are the same');
525   ***      0                                  0         return $curr;
526                                                      }
527   ***      0                                  0      $sql = 'USE ' . $quoter->quote($new);
528   ***      0                                  0      MKDEBUG && _d($sql);
529   ***      0                                  0      $dbh->do($sql);
530   ***      0                                  0      return $curr;
531                                                   }
532                                                   
533                                                   sub get_create_table {
534   ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
535   ***      0      0      0                    0      if ( !$self->{cache} || !$self->{tables}->{$db}->{$tbl} ) {
536   ***      0                                  0         my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
537                                                            . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
538                                                            . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
539                                                            . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
540   ***      0                                  0         MKDEBUG && _d($sql);
541   ***      0                                  0         eval { $dbh->do($sql); };
      ***      0                                  0   
542   ***      0                                  0         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
543   ***      0                                  0         my $curr_db = $self->_use_db($dbh, $quoter, $db);
544   ***      0                                  0         $sql = "SHOW CREATE TABLE " . $quoter->quote($db, $tbl);
545   ***      0                                  0         MKDEBUG && _d($sql);
546   ***      0                                  0         my $href = $dbh->selectrow_hashref($sql);
547   ***      0                                  0         $self->_use_db($dbh, $quoter, $curr_db);
548   ***      0                                  0         $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
549                                                            . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
550   ***      0                                  0         MKDEBUG && _d($sql);
551   ***      0                                  0         $dbh->do($sql);
552   ***      0                                  0         my ($key) = grep { m/create table/i } keys %$href;
      ***      0                                  0   
553   ***      0      0                           0         if ( $key ) {
554   ***      0                                  0            MKDEBUG && _d('This table is a base table');
555   ***      0                                  0            $self->{tables}->{$db}->{$tbl} = [ 'table', $href->{$key} ];
556                                                         }
557                                                         else {
558   ***      0                                  0            MKDEBUG && _d('This table is a view');
559   ***      0                                  0            ($key) = grep { m/create view/i } keys %$href;
      ***      0                                  0   
560   ***      0                                  0            $self->{tables}->{$db}->{$tbl} = [ 'view', $href->{$key} ];
561                                                         }
562                                                      }
563   ***      0                                  0      return $self->{tables}->{$db}->{$tbl};
564                                                   }
565                                                   
566                                                   sub get_columns {
567   ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
568   ***      0                                  0      MKDEBUG && _d('Get columns for', $db, $tbl);
569   ***      0      0      0                    0      if ( !$self->{cache} || !$self->{columns}->{$db}->{$tbl} ) {
570   ***      0                                  0         my $curr_db = $self->_use_db($dbh, $quoter, $db);
571   ***      0                                  0         my $sql = "SHOW COLUMNS FROM " . $quoter->quote($db, $tbl);
572   ***      0                                  0         MKDEBUG && _d($sql);
573   ***      0                                  0         my $cols = $dbh->selectall_arrayref($sql, { Slice => {} });
574   ***      0                                  0         $self->_use_db($dbh, $quoter, $curr_db);
575   ***      0                                  0         $self->{columns}->{$db}->{$tbl} = [
576                                                            map {
577   ***      0                                  0               my %row;
578   ***      0                                  0               @row{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
579   ***      0                                  0               \%row;
580                                                            } @$cols
581                                                         ];
582                                                      }
583   ***      0                                  0      return $self->{columns}->{$db}->{$tbl};
584                                                   }
585                                                   
586                                                   sub get_tmp_table {
587   ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
588   ***      0                                  0      my $result = 'CREATE TABLE ' . $quoter->quote($tbl) . " (\n";
589   ***      0                                  0      $result .= join(",\n",
590   ***      0                                  0         map { '  ' . $quoter->quote($_->{field}) . ' ' . $_->{type} }
591   ***      0                                  0         @{$self->get_columns($dbh, $quoter, $db, $tbl)});
592   ***      0                                  0      $result .= "\n)";
593   ***      0                                  0      MKDEBUG && _d($result);
594   ***      0                                  0      return $result;
595                                                   }
596                                                   
597                                                   sub get_triggers {
598   ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
599   ***      0      0      0                    0      if ( !$self->{cache} || !$self->{triggers}->{$db} ) {
600   ***      0                                  0         $self->{triggers}->{$db} = {};
601   ***      0                                  0         my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
602                                                            . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
603                                                            . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
604                                                            . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
605   ***      0                                  0         MKDEBUG && _d($sql);
606   ***      0                                  0         eval { $dbh->do($sql); };
      ***      0                                  0   
607   ***      0                                  0         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
608   ***      0                                  0         $sql = "SHOW TRIGGERS FROM " . $quoter->quote($db);
609   ***      0                                  0         MKDEBUG && _d($sql);
610   ***      0                                  0         my $sth = $dbh->prepare($sql);
611   ***      0                                  0         $sth->execute();
612   ***      0      0                           0         if ( $sth->rows ) {
613   ***      0                                  0            my $trgs = $sth->fetchall_arrayref({});
614   ***      0                                  0            foreach my $trg (@$trgs) {
615   ***      0                                  0               my %trg;
616   ***      0                                  0               @trg{ map { lc $_ } keys %$trg } = values %$trg;
      ***      0                                  0   
617   ***      0                                  0               push @{ $self->{triggers}->{$db}->{ $trg{table} } }, \%trg;
      ***      0                                  0   
618                                                            }
619                                                         }
620   ***      0                                  0         $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
621                                                            . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
622   ***      0                                  0         MKDEBUG && _d($sql);
623   ***      0                                  0         $dbh->do($sql);
624                                                      }
625   ***      0      0                           0      if ( $tbl ) {
626   ***      0                                  0         return $self->{triggers}->{$db}->{$tbl};
627                                                      }
628   ***      0                                  0      return values %{$self->{triggers}->{$db}};
      ***      0                                  0   
629                                                   }
630                                                   
631                                                   sub get_databases {
632   ***      0                    0             0      my ( $self, $dbh, $quoter, $like ) = @_;
633   ***      0      0      0                    0      if ( !$self->{cache} || !$self->{databases} || $like ) {
      ***                    0                        
634   ***      0                                  0         my $sql = 'SHOW DATABASES';
635   ***      0                                  0         my @params;
636   ***      0      0                           0         if ( $like ) {
637   ***      0                                  0            $sql .= ' LIKE ?';
638   ***      0                                  0            push @params, $like;
639                                                         }
640   ***      0                                  0         my $sth = $dbh->prepare($sql);
641   ***      0                                  0         MKDEBUG && _d($sql, @params);
642   ***      0                                  0         $sth->execute( @params );
643   ***      0                                  0         my @dbs = map { $_->[0] } @{$sth->fetchall_arrayref()};
      ***      0                                  0   
      ***      0                                  0   
644   ***      0      0                           0         $self->{databases} = \@dbs unless $like;
645   ***      0                                  0         return @dbs;
646                                                      }
647   ***      0                                  0      return @{$self->{databases}};
      ***      0                                  0   
648                                                   }
649                                                   
650                                                   sub get_table_status {
651   ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $like ) = @_;
652   ***      0      0      0                    0      if ( !$self->{cache} || !$self->{table_status}->{$db} || $like ) {
      ***                    0                        
653   ***      0                                  0         my $sql = "SHOW TABLE STATUS FROM " . $quoter->quote($db);
654   ***      0                                  0         my @params;
655   ***      0      0                           0         if ( $like ) {
656   ***      0                                  0            $sql .= ' LIKE ?';
657   ***      0                                  0            push @params, $like;
658                                                         }
659   ***      0                                  0         MKDEBUG && _d($sql, @params);
660   ***      0                                  0         my $sth = $dbh->prepare($sql);
661   ***      0                                  0         $sth->execute(@params);
662   ***      0                                  0         my @tables = @{$sth->fetchall_arrayref({})};
      ***      0                                  0   
663   ***      0                                  0         @tables = map {
664   ***      0                                  0            my %tbl; # Make a copy with lowercased keys
665   ***      0                                  0            @tbl{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
666   ***      0             0                    0            $tbl{engine} ||= $tbl{type} || $tbl{comment};
      ***                    0                        
667   ***      0                                  0            delete $tbl{type};
668   ***      0                                  0            \%tbl;
669                                                         } @tables;
670   ***      0      0                           0         $self->{table_status}->{$db} = \@tables unless $like;
671   ***      0                                  0         return @tables;
672                                                      }
673   ***      0                                  0      return @{$self->{table_status}->{$db}};
      ***      0                                  0   
674                                                   }
675                                                   
676                                                   sub get_table_list {
677   ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $like ) = @_;
678   ***      0      0      0                    0      if ( !$self->{cache} || !$self->{table_list}->{$db} || $like ) {
      ***                    0                        
679   ***      0                                  0         my $sql = "SHOW /*!50002 FULL*/ TABLES FROM " . $quoter->quote($db);
680   ***      0                                  0         my @params;
681   ***      0      0                           0         if ( $like ) {
682   ***      0                                  0            $sql .= ' LIKE ?';
683   ***      0                                  0            push @params, $like;
684                                                         }
685   ***      0                                  0         MKDEBUG && _d($sql, @params);
686   ***      0                                  0         my $sth = $dbh->prepare($sql);
687   ***      0                                  0         $sth->execute(@params);
688   ***      0                                  0         my @tables = @{$sth->fetchall_arrayref()};
      ***      0                                  0   
689   ***      0      0      0                    0         @tables = map {
690   ***      0                                  0            my %tbl = (
691                                                               name   => $_->[0],
692                                                               engine => ($_->[1] || '') eq 'VIEW' ? 'VIEW' : '',
693                                                            );
694   ***      0                                  0            \%tbl;
695                                                         } @tables;
696   ***      0      0                           0         $self->{table_list}->{$db} = \@tables unless $like;
697   ***      0                                  0         return @tables;
698                                                      }
699   ***      0                                  0      return @{$self->{table_list}->{$db}};
      ***      0                                  0   
700                                                   }
701                                                   
702                                                   sub _d {
703   ***      0                    0             0      my ($package, undef, $line) = caller 0;
704   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
705   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
706                                                           @_;
707   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
708                                                   }
709                                                   
710                                                   1;
711                                                   
712                                                   # ###########################################################################
713                                                   # End MySQLDump package
714                                                   # ###########################################################################
715                                                   
716                                                   # ###########################################################################
717                                                   # MySQLFind package 3186
718                                                   # ###########################################################################
719                                                   package MySQLFind;
720                                                   
721            1                    1            16   use strict;
               1                                  3   
               1                                  8   
722            1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                  8   
723                                                   
724            1                    1             7   use English qw(-no_match_vars);
               1                                  2   
               1                                  8   
725            1                    1             7   use Data::Dumper;
               1                                  3   
               1                                 11   
726                                                   $Data::Dumper::Indent    = 0;
727                                                   $Data::Dumper::Quotekeys = 0;
728                                                   
729            1                    1             7   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  3   
               1                                  9   
730                                                   
731                                                   
732                                                   sub new {
733   ***      0                    0             0      my ( $class, %args ) = @_;
734   ***      0                                  0      foreach my $arg ( qw(dumper quoter) ) {
735   ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
736                                                      }
737   ***      0      0                           0      die "Do not pass me a dbh argument" if $args{dbh};
738   ***      0                                  0      my $self = bless \%args, $class;
739   ***      0      0      0                    0      $self->{need_engine}
      ***                    0                        
740                                                         = (   $self->{engines}->{permit}
741                                                            || $self->{engines}->{reject}
742                                                            || $self->{engines}->{regexp} ? 1 : 0);
743   ***      0      0      0                    0      die "I need a parser argument"
744                                                         if $self->{need_engine} && !defined $args{parser};
745   ***      0                                  0      MKDEBUG && _d('Need engine:', $self->{need_engine} ? 'yes' : 'no');
746   ***      0      0                           0      $self->{engines}->{views} = 1  unless defined $self->{engines}->{views};
747   ***      0      0                           0      $self->{tables}->{status} = [] unless defined $self->{tables}->{status};
748   ***      0      0                           0      if ( $args{useddl} ) {
749   ***      0                                  0         MKDEBUG && _d('Will prefer DDL');
750                                                      }
751   ***      0                                  0      return $self;
752                                                   }
753                                                   
754                                                   sub init_timestamp {
755   ***      0                    0             0      my ( $self, $dbh ) = @_;
756   ***      0      0                           0      return if $self->{timestamp}->{$dbh}->{now};
757   ***      0                                  0      my $sql = 'SELECT CURRENT_TIMESTAMP';
758   ***      0                                  0      MKDEBUG && _d($sql);
759   ***      0                                  0      ($self->{timestamp}->{$dbh}->{now}) = $dbh->selectrow_array($sql);
760   ***      0                                  0      MKDEBUG && _d('Current timestamp:', $self->{timestamp}->{$dbh}->{now});
761                                                   }
762                                                   
763                                                   sub find_databases {
764   ***      0                    0             0      my ( $self, $dbh ) = @_;
765   ***      0                                  0      return grep {
766                                                         $_ !~ m/^(information_schema|lost\+found)$/i
767   ***      0                    0             0      }  $self->_filter('databases', sub { $_[0] },
768   ***      0                                  0            $self->{dumper}->get_databases(
769                                                               $dbh,
770                                                               $self->{quoter},
771                                                               $self->{databases}->{like}));
772                                                   }
773                                                   
774                                                   sub find_tables {
775   ***      0                    0             0      my ( $self, $dbh, %args ) = @_; 
776                                                   
777                                                      my @tables
778   ***      0                    0             0         = $self->_filter('tables', sub { $_[0]->{name} },
779   ***      0                                  0            $self->_fetch_tbl_list($dbh, %args));
780                                                   
781   ***      0      0                           0      if ( $self->{need_engine} ) {
782   ***      0                                  0         foreach my $tbl ( @tables ) {
783   ***      0      0                           0            next if $tbl->{engine};
784   ***      0                                  0            my ( $tbl_name ) = $tbl->{name} =~ m/\.(.+)$/;
785   ***      0                                  0            my $struct = $self->{parser}->parse(
786                                                               $self->{dumper}->get_create_table(
787                                                                  $dbh, $self->{quoter}, $args{database}, $tbl_name));
788   ***      0                                  0            $tbl->{engine} = $struct->{engine};
789                                                         }
790   ***      0                    0             0         @tables = $self->_filter('engines', sub { $_[0]->{engine} }, @tables);
      ***      0                                  0   
791                                                      }
792                                                   
793   ***      0                                  0      map { $_->{name} =~ s/^[^.]*\.// } @tables;
      ***      0                                  0   
794                                                   
795   ***      0                                  0      foreach my $crit ( @{$self->{tables}->{status}} ) {
      ***      0                                  0   
796   ***      0                                  0         my ($key, $test) = %$crit;
797                                                         @tables
798   ***      0                                  0            = grep {
799   ***      0                                  0               $self->_test_date($_, $key, $test, $dbh)
800                                                            } @tables;
801                                                      }
802                                                   
803   ***      0                                  0      return map { $_->{name} } @tables;
      ***      0                                  0   
804                                                   }
805                                                   
806                                                   sub find_views {
807   ***      0                    0             0      my ( $self, $dbh, %args ) = @_;
808   ***      0                                  0      my @tables = $self->_fetch_tbl_list($dbh, %args);
809   ***      0                                  0      @tables = grep { $_->{engine} eq 'VIEW' } @tables;
      ***      0                                  0   
810   ***      0                                  0      map { $_->{name} =~ s/^[^.]*\.// } @tables; # <database>.<table> => <table> 
      ***      0                                  0   
811   ***      0                                  0      return map { $_->{name} } @tables;
      ***      0                                  0   
812                                                   }
813                                                   
814                                                   sub _use_db {
815   ***      0                    0             0      my ( $self, $dbh, $new ) = @_;
816   ***      0      0                           0      if ( !$new ) {
817   ***      0                                  0         MKDEBUG && _d('No new DB to use');
818   ***      0                                  0         return;
819                                                      }
820   ***      0                                  0      my $sql = 'SELECT DATABASE()';
821   ***      0                                  0      MKDEBUG && _d($sql);
822   ***      0                                  0      my $curr = $dbh->selectrow_array($sql);
823   ***      0      0      0                    0      if ( $curr && $new && $curr eq $new ) {
      ***                    0                        
824   ***      0                                  0         MKDEBUG && _d('Current and new DB are the same');
825   ***      0                                  0         return $curr;
826                                                      }
827   ***      0                                  0      $sql = 'USE ' . $self->{quoter}->quote($new);
828   ***      0                                  0      MKDEBUG && _d($sql);
829   ***      0                                  0      $dbh->do($sql);
830   ***      0                                  0      return $curr;
831                                                   }
832                                                   
833                                                   sub _fetch_tbl_list {
834   ***      0                    0             0      my ( $self, $dbh, %args ) = @_;
835   ***      0      0                           0      die "database is required" unless $args{database};
836                                                   
837   ***      0                                  0      my $curr_db = $self->_use_db($dbh, $args{database});
838                                                   
839   ***      0                                  0      my @tables;
840   ***      0      0                           0      if ( scalar @{$self->{tables}->{status}} ) {
      ***      0                                  0   
841   ***      0                                  0         @tables = $self->{dumper}->get_table_status(
842                                                            $dbh,
843                                                            $self->{quoter},
844                                                            $args{database},
845                                                            $self->{tables}->{like});
846                                                      }
847                                                      else {
848   ***      0                                  0         @tables = $self->{dumper}->get_table_list(
849                                                            $dbh,
850                                                            $self->{quoter},
851                                                            $args{database},
852                                                            $self->{tables}->{like});
853                                                      }
854                                                   
855   ***      0                                  0      @tables = map {
856   ***      0      0                           0         my %hash = %$_;
857   ***      0                                  0         $hash{name} = join('.', $args{database}, $hash{name});
858   ***      0                                  0         \%hash;
859                                                      }
860                                                      grep {
861   ***      0                                  0         ( $self->{engines}->{views} || ($_->{engine} ne 'VIEW') )
862                                                      } @tables;
863                                                   
864   ***      0                                  0      $self->_use_db($dbh, $curr_db);
865                                                   
866   ***      0                                  0      return @tables;
867                                                   }
868                                                   
869                                                   sub _filter {
870   ***      0                    0             0      my ( $self, $thing, $sub, @vals ) = @_;
871   ***      0                                  0      MKDEBUG && _d('Filtering', $thing, 'list on', Dumper($self->{$thing}));
872   ***      0                                  0      my $permit = $self->{$thing}->{permit};
873   ***      0                                  0      my $reject = $self->{$thing}->{reject};
874   ***      0                                  0      my $regexp = $self->{$thing}->{regexp};
875   ***      0                                  0      return grep {
876   ***      0                                  0         my $val = $sub->($_);
877   ***      0      0                           0         $val = '' unless defined $val;
878   ***      0      0                           0         if ( $thing eq 'tables' ) {
879   ***      0                                  0            (my $tbl = $val) =~ s/^.*\.//;
880   ***      0      0      0                    0            ( !$reject || (!$reject->{$val} && !$reject->{$tbl}) )
      ***                    0                        
      ***                    0                        
      ***                    0                        
      ***                    0                        
      ***                    0                        
881                                                               && ( !$permit || $permit->{$val} || $permit->{$tbl} )
882                                                               && ( !$regexp || $val =~ m/$regexp/ )
883                                                         }
884                                                         else {
885   ***      0      0      0                    0            ( !$reject || !$reject->{$val} )
      ***                    0                        
      ***                    0                        
      ***                    0                        
886                                                               && ( !$permit || $permit->{$val} )
887                                                               && ( !$regexp || $val =~ m/$regexp/ )
888                                                         }
889                                                      } @vals;
890                                                   }
891                                                   
892                                                   sub _test_date {
893   ***      0                    0             0      my ( $self, $table, $prop, $test, $dbh ) = @_;
894   ***      0                                  0      $prop = lc $prop;
895   ***      0      0                           0      if ( !defined $table->{$prop} ) {
896   ***      0                                  0         MKDEBUG && _d($prop, 'is not defined');
897   ***      0                                  0         return $self->{nullpass};
898                                                      }
899   ***      0                                  0      my ( $equality, $num ) = $test =~ m/^([+-])?(\d+)$/;
900   ***      0      0                           0      die "Invalid date test $test for $prop" unless defined $num;
901   ***      0                                  0      $self->init_timestamp($dbh);
902   ***      0                                  0      my $sql = "SELECT DATE_SUB('$self->{timestamp}->{$dbh}->{now}', "
903                                                              . "INTERVAL $num SECOND)";
904   ***      0                                  0      MKDEBUG && _d($sql);
905   ***      0             0                    0      ($self->{timestamp}->{$dbh}->{$num}) ||= $dbh->selectrow_array($sql);
906   ***      0                                  0      my $time = $self->{timestamp}->{$dbh}->{$num};
907                                                      return 
908   ***      0             0                    0            ( $equality eq '-' && $table->{$prop} gt $time )
      ***                    0                        
      ***                    0                        
      ***                    0                        
909                                                         || ( $equality eq '+' && $table->{$prop} lt $time )
910                                                         || (                     $table->{$prop} eq $time );
911                                                   }
912                                                   
913                                                   sub _d {
914   ***      0                    0             0      my ($package, undef, $line) = caller 0;
915   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
916   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
917                                                           @_;
918   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
919                                                   }
920                                                   
921                                                   1;
922                                                   
923                                                   # ###########################################################################
924                                                   # End MySQLFind package
925                                                   # ###########################################################################
926                                                   
927                                                   # ###########################################################################
928                                                   # DSNParser package 3577
929                                                   # ###########################################################################
930            1                    1             9   use strict;
               1                                  2   
               1                                  7   
931            1                    1             5   use warnings FATAL => 'all';
               1                                  3   
               1                                  5   
932                                                   
933                                                   package DSNParser;
934                                                   
935            1                    1            12   use DBI;
               1                                  5   
               1                                 11   
936            1                    1             7   use Data::Dumper;
               1                                  2   
               1                                 50   
937                                                   $Data::Dumper::Indent    = 0;
938                                                   $Data::Dumper::Quotekeys = 0;
939            1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  9   
940                                                   
941            1                    1             6   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  3   
               1                                 10   
942                                                   
943                                                   sub new {
944            1                    1             6      my ( $class, @opts ) = @_;
945            1                                 27      my $self = {
946                                                         opts => {
947                                                            A => {
948                                                               desc => 'Default character set',
949                                                               dsn  => 'charset',
950                                                               copy => 1,
951                                                            },
952                                                            D => {
953                                                               desc => 'Database to use',
954                                                               dsn  => 'database',
955                                                               copy => 1,
956                                                            },
957                                                            F => {
958                                                               desc => 'Only read default options from the given file',
959                                                               dsn  => 'mysql_read_default_file',
960                                                               copy => 1,
961                                                            },
962                                                            h => {
963                                                               desc => 'Connect to host',
964                                                               dsn  => 'host',
965                                                               copy => 1,
966                                                            },
967                                                            p => {
968                                                               desc => 'Password to use when connecting',
969                                                               dsn  => 'password',
970                                                               copy => 1,
971                                                            },
972                                                            P => {
973                                                               desc => 'Port number to use for connection',
974                                                               dsn  => 'port',
975                                                               copy => 1,
976                                                            },
977                                                            S => {
978                                                               desc => 'Socket file to use for connection',
979                                                               dsn  => 'mysql_socket',
980                                                               copy => 1,
981                                                            },
982                                                            u => {
983                                                               desc => 'User for login if not current user',
984                                                               dsn  => 'user',
985                                                               copy => 1,
986                                                            },
987                                                         },
988                                                      };
989            1                                  5      foreach my $opt ( @opts ) {
990   ***      0                                  0         MKDEBUG && _d('Adding extra property', $opt->{key});
991   ***      0                                  0         $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
992                                                      }
993            1                                 13      return bless $self, $class;
994                                                   }
995                                                   
996                                                   sub prop {
997            4                    4            19      my ( $self, $prop, $value ) = @_;
998   ***      4     50                          19      if ( @_ > 2 ) {
999   ***      0                                  0         MKDEBUG && _d('Setting', $prop, 'property');
1000  ***      0                                  0         $self->{$prop} = $value;
1001                                                     }
1002           4                                 27      return $self->{$prop};
1003                                                  }
1004                                                  
1005                                                  sub parse {
1006           1                    1             4      my ( $self, $dsn, $prev, $defaults ) = @_;
1007  ***      1     50                           5      if ( !$dsn ) {
1008  ***      0                                  0         MKDEBUG && _d('No DSN to parse');
1009  ***      0                                  0         return;
1010                                                     }
1011           1                                  2      MKDEBUG && _d('Parsing', $dsn);
1012  ***      1            50                    5      $prev     ||= {};
1013  ***      1            50                    5      $defaults ||= {};
1014           1                                  2      my %given_props;
1015           1                                  2      my %final_props;
1016           1                                  3      my %opts = %{$self->{opts}};
               1                                 13   
1017           1                                  6      my $prop_autokey = $self->prop('autokey');
1018                                                  
1019           1                                 15      foreach my $dsn_part ( split(/,/, $dsn) ) {
1020  ***      2     50                          18         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
      ***             0                               
1021           2                                 11            $given_props{$prop_key} = $prop_val;
1022                                                        }
1023                                                        elsif ( $prop_autokey ) {
1024  ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as',
1025                                                              $prop_autokey, '=', $dsn_part);
1026  ***      0                                  0            $given_props{$prop_autokey} = $dsn_part;
1027                                                        }
1028                                                        else {
1029  ***      0                                  0            MKDEBUG && _d('Bad DSN part:', $dsn_part);
1030                                                        }
1031                                                     }
1032                                                  
1033           1                                  6      foreach my $key ( keys %opts ) {
1034           8                                 16         MKDEBUG && _d('Finding value for', $key);
1035           8                                 26         $final_props{$key} = $given_props{$key};
1036  ***      8     50     66                   83         if (   !defined $final_props{$key}
      ***                   33                        
1037                                                             && defined $prev->{$key} && $opts{$key}->{copy} )
1038                                                        {
1039  ***      0                                  0            $final_props{$key} = $prev->{$key};
1040  ***      0                                  0            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
1041                                                        }
1042           8    100                          33         if ( !defined $final_props{$key} ) {
1043           6                                 18            $final_props{$key} = $defaults->{$key};
1044           6                                 16            MKDEBUG && _d('Copying value for', $key, 'from defaults');
1045                                                        }
1046                                                     }
1047                                                  
1048           1                                  5      foreach my $key ( keys %given_props ) {
1049  ***      2     50                          10         die "Unrecognized DSN part '$key' in '$dsn'\n"
1050                                                           unless exists $opts{$key};
1051                                                     }
1052  ***      1     50                           4      if ( (my $required = $self->prop('required')) ) {
1053  ***      0                                  0         foreach my $key ( keys %$required ) {
1054  ***      0      0                           0            die "Missing DSN part '$key' in '$dsn'\n" unless $final_props{$key};
1055                                                        }
1056                                                     }
1057                                                  
1058           1                                  6      return \%final_props;
1059                                                  }
1060                                                  
1061                                                  sub parse_options {
1062  ***      0                    0             0      my ( $self, $o ) = @_;
1063  ***      0      0                           0      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
1064  ***      0                                  0      my $dsn_string
1065                                                        = join(',',
1066  ***      0      0                           0             map  { "$_=".$o->get($_); }
1067  ***      0                                  0             grep { $o->has($_) && $o->get($_) }
1068  ***      0                                  0             keys %{$self->{opts}}
1069                                                          );
1070  ***      0                                  0      MKDEBUG && _d('DSN string made from options:', $dsn_string);
1071  ***      0                                  0      return $self->parse($dsn_string);
1072                                                  }
1073                                                  
1074                                                  sub as_string {
1075  ***      0                    0             0      my ( $self, $dsn ) = @_;
1076  ***      0      0                           0      return $dsn unless ref $dsn;
1077  ***      0      0                           0      return join(',',
1078  ***      0      0                           0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
1079  ***      0                                  0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
1080                                                        sort keys %$dsn );
1081                                                  }
1082                                                  
1083                                                  sub usage {
1084  ***      0                    0             0      my ( $self ) = @_;
1085  ***      0                                  0      my $usage
1086                                                        = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
1087                                                        . "  KEY  COPY  MEANING\n"
1088                                                        . "  ===  ====  =============================================\n";
1089  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1090  ***      0                                  0      foreach my $key ( sort keys %opts ) {
1091  ***      0      0      0                    0         $usage .= "  $key    "
1092                                                               .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
1093                                                               .  ($opts{$key}->{desc} || '[No description]')
1094                                                               . "\n";
1095                                                     }
1096  ***      0      0                           0      if ( (my $key = $self->prop('autokey')) ) {
1097  ***      0                                  0         $usage .= "  If the DSN is a bareword, the word is treated as the '$key' key.\n";
1098                                                     }
1099  ***      0                                  0      return $usage;
1100                                                  }
1101                                                  
1102                                                  sub get_cxn_params {
1103           1                    1             3      my ( $self, $info ) = @_;
1104           1                                  6      my $dsn;
1105           1                                  3      my %opts = %{$self->{opts}};
               1                                  8   
1106  ***      1            50                    5      my $driver = $self->prop('dbidriver') || '';
1107  ***      1     50                           4      if ( $driver eq 'Pg' ) {
1108  ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
1109  ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1110  ***      0             0                    0                        grep { defined $info->{$_} }
1111                                                                       qw(h P));
1112                                                     }
1113                                                     else {
1114           2                                 14         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
1115           5                                 18            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1116  ***      1            50                   12                        grep { defined $info->{$_} }
1117                                                                       qw(F h P S A))
1118                                                           . ';mysql_read_default_group=client';
1119                                                     }
1120           1                                  3      MKDEBUG && _d($dsn);
1121           1                                  8      return ($dsn, $info->{u}, $info->{p});
1122                                                  }
1123                                                  
1124                                                  sub fill_in_dsn {
1125  ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
1126  ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
1127  ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
1128  ***      0                                  0      $user =~ s/@.*//;
1129  ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
1130  ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
1131  ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
1132  ***      0             0                    0      $dsn->{u} ||= $user;
1133  ***      0             0                    0      $dsn->{D} ||= $db;
1134                                                  }
1135                                                  
1136                                                  sub get_dbh {
1137           1                    1             5      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
1138  ***      1            50                    5      $opts ||= {};
1139  ***      1     50                          13      my $defaults = {
1140                                                        AutoCommit        => 0,
1141                                                        RaiseError        => 1,
1142                                                        PrintError        => 0,
1143                                                        mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
1144                                                     };
1145           1                                  5      @{$defaults}{ keys %$opts } = values %$opts;
               1                                  4   
1146                                                  
1147           1                                  6      my $dbh;
1148           1                                  3      my $tries = 2;
1149  ***      1            66                   10      while ( !$dbh && $tries-- ) {
1150                                                        MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
1151           1                                  2            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
1152                                                  
1153           1                                  3         eval {
1154           1                                  7            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
1155                                                  
1156  ***      1     50                          11            if ( $cxn_string =~ m/mysql/i ) {
1157           1                                  3               my $sql;
1158                                                  
1159           1                                  4               $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
1160                                                                   . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
1161           1                                  3               MKDEBUG && _d($dbh, ':', $sql);
1162           1                                141               $dbh->do($sql);
1163                                                  
1164  ***      1     50                          10               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
1165  ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
1166  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1167  ***      0                                  0                  $dbh->do($sql);
1168  ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
1169  ***      0      0                           0                  if ( $charset eq 'utf8' ) {
1170  ***      0      0                           0                     binmode(STDOUT, ':utf8')
1171                                                                       or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
1172                                                                 }
1173                                                                 else {
1174  ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
1175                                                                 }
1176                                                              }
1177                                                  
1178  ***      1     50                           6               if ( $self->prop('setvars') ) {
1179  ***      0                                  0                  $sql = "SET " . $self->prop('setvars');
1180  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1181  ***      0                                  0                  $dbh->do($sql);
1182                                                              }
1183                                                           }
1184                                                        };
1185  ***      1     50     33                   11         if ( !$dbh && $EVAL_ERROR ) {
1186  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
1187  ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
1188  ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
1189  ***      0                                  0               delete $defaults->{mysql_enable_utf8};
1190                                                           }
1191  ***      0      0                           0            if ( !$tries ) {
1192  ***      0                                  0               die $EVAL_ERROR;
1193                                                           }
1194                                                        }
1195                                                     }
1196                                                  
1197           1                                  3      MKDEBUG && _d('DBH info: ',
1198                                                        $dbh,
1199                                                        Dumper($dbh->selectrow_hashref(
1200                                                           'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
1201                                                        'Connection info:',      $dbh->{mysql_hostinfo},
1202                                                        'Character set info:',   Dumper($dbh->selectall_arrayref(
1203                                                                       'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
1204                                                        '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
1205                                                        '$DBI::VERSION:',        $DBI::VERSION,
1206                                                     );
1207                                                  
1208           1                                  7      return $dbh;
1209                                                  }
1210                                                  
1211                                                  sub get_hostname {
1212  ***      0                    0             0      my ( $self, $dbh ) = @_;
1213  ***      0      0      0                    0      if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
1214  ***      0                                  0         return $host;
1215                                                     }
1216  ***      0                                  0      my ( $hostname, $one ) = $dbh->selectrow_array(
1217                                                        'SELECT /*!50038 @@hostname, */ 1');
1218  ***      0                                  0      return $hostname;
1219                                                  }
1220                                                  
1221                                                  sub disconnect {
1222  ***      0                    0             0      my ( $self, $dbh ) = @_;
1223  ***      0                                  0      MKDEBUG && $self->print_active_handles($dbh);
1224  ***      0                                  0      $dbh->disconnect;
1225                                                  }
1226                                                  
1227                                                  sub print_active_handles {
1228  ***      0                    0             0      my ( $self, $thing, $level ) = @_;
1229  ***      0             0                    0      $level ||= 0;
1230  ***      0      0      0                    0      printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
1231                                                        $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
1232                                                        or die "Cannot print: $OS_ERROR";
1233  ***      0                                  0      foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                  0   
      ***      0                                  0   
1234  ***      0                                  0         $self->print_active_handles( $handle, $level + 1 );
1235                                                     }
1236                                                  }
1237                                                  
1238                                                  sub copy {
1239  ***      0                    0             0      my ( $self, $dsn_1, $dsn_2, %args ) = @_;
1240  ***      0      0                           0      die 'I need a dsn_1 argument' unless $dsn_1;
1241  ***      0      0                           0      die 'I need a dsn_2 argument' unless $dsn_2;
1242  ***      0                                  0      my %new_dsn = map {
1243  ***      0                                  0         my $key = $_;
1244  ***      0                                  0         my $val;
1245  ***      0      0                           0         if ( $args{overwrite} ) {
1246  ***      0      0                           0            $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
1247                                                        }
1248                                                        else {
1249  ***      0      0                           0            $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
1250                                                        }
1251  ***      0                                  0         $key => $val;
1252  ***      0                                  0      } keys %{$self->{opts}};
1253  ***      0                                  0      return \%new_dsn;
1254                                                  }
1255                                                  
1256                                                  sub _d {
1257  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1258  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1259  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1260                                                          @_;
1261  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1262                                                  }
1263                                                  
1264                                                  1;
1265                                                  
1266                                                  # ###########################################################################
1267                                                  # End DSNParser package
1268                                                  # ###########################################################################
1269                                                  
1270                                                  # ###########################################################################
1271                                                  # OptionParser package 3695
1272                                                  # ###########################################################################
1273                                                  package OptionParser;
1274                                                  
1275           1                    1             8   use strict;
               1                                  3   
               1                                  8   
1276           1                    1             6   use warnings FATAL => 'all';
               1                                  3   
               1                                  9   
1277                                                  
1278           1                    1            14   use Getopt::Long;
               1                                  4   
               1                                  6   
1279           1                    1             7   use List::Util qw(max);
               1                                  3   
               1                                 11   
1280           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  7   
1281                                                  
1282           1                    1             7   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  3   
               1                                  8   
1283                                                  
1284                                                  my $POD_link_re = '[LC]<"?([^">]+)"?>';
1285                                                  
1286                                                  sub new {
1287  ***      0                    0             0      my ( $class, %args ) = @_;
1288  ***      0                                  0      foreach my $arg ( qw(description) ) {
1289  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
1290                                                     }
1291  ***      0                                  0      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
1292  ***      0             0                    0      $program_name ||= $PROGRAM_NAME;
1293                                                  
1294  ***      0      0      0                    0      my $self = {
      ***                    0                        
1295                                                        description    => $args{description},
1296                                                        prompt         => $args{prompt} || '<options>',
1297                                                        strict         => (exists $args{strict} ? $args{strict} : 1),
1298                                                        dp             => $args{dp}     || undef,
1299                                                        program_name   => $program_name,
1300                                                        opts           => {},
1301                                                        got_opts       => 0,
1302                                                        short_opts     => {},
1303                                                        defaults       => {},
1304                                                        groups         => {},
1305                                                        allowed_groups => {},
1306                                                        errors         => [],
1307                                                        rules          => [],  # desc of rules for --help
1308                                                        mutex          => [],  # rule: opts are mutually exclusive
1309                                                        atleast1       => [],  # rule: at least one opt is required
1310                                                        disables       => {},  # rule: opt disables other opts 
1311                                                        defaults_to    => {},  # rule: opt defaults to value of other opt
1312                                                        default_files  => [
1313                                                           "/etc/maatkit/maatkit.conf",
1314                                                           "/etc/maatkit/$program_name.conf",
1315                                                           "$ENV{HOME}/.maatkit.conf",
1316                                                           "$ENV{HOME}/.$program_name.conf",
1317                                                        ],
1318                                                     };
1319  ***      0                                  0      return bless $self, $class;
1320                                                  }
1321                                                  
1322                                                  sub get_specs {
1323  ***      0                    0             0      my ( $self, $file ) = @_;
1324  ***      0                                  0      my @specs = $self->_pod_to_specs($file);
1325  ***      0                                  0      $self->_parse_specs(@specs);
1326  ***      0                                  0      return;
1327                                                  }
1328                                                  
1329                                                  sub get_defaults_files {
1330  ***      0                    0             0      my ( $self ) = @_;
1331  ***      0                                  0      return @{$self->{default_files}};
      ***      0                                  0   
1332                                                  }
1333                                                  
1334                                                  sub _pod_to_specs {
1335  ***      0                    0             0      my ( $self, $file ) = @_;
1336  ***      0             0                    0      $file ||= __FILE__;
1337  ***      0      0                           0      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
1338                                                  
1339  ***      0                                  0      my %types = (
1340                                                        string => 's', # standard Getopt type
1341                                                        'int'  => 'i', # standard Getopt type
1342                                                        float  => 'f', # standard Getopt type
1343                                                        Hash   => 'H', # hash, formed from a comma-separated list
1344                                                        hash   => 'h', # hash as above, but only if a value is given
1345                                                        Array  => 'A', # array, similar to Hash
1346                                                        array  => 'a', # array, similar to hash
1347                                                        DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
1348                                                        size   => 'z', # size with kMG suffix (powers of 2^10)
1349                                                        'time' => 'm', # time, with an optional suffix of s/h/m/d
1350                                                     );
1351  ***      0                                  0      my @specs = ();
1352  ***      0                                  0      my @rules = ();
1353  ***      0                                  0      my $para;
1354                                                  
1355  ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
1356  ***      0                                  0      while ( $para = <$fh> ) {
1357  ***      0      0                           0         next unless $para =~ m/^=head1 OPTIONS/;
1358  ***      0                                  0         last;
1359                                                     }
1360                                                  
1361  ***      0                                  0      while ( $para = <$fh> ) {
1362  ***      0      0                           0         last if $para =~ m/^=over/;
1363  ***      0                                  0         chomp $para;
1364  ***      0                                  0         $para =~ s/\s+/ /g;
1365  ***      0                                  0         $para =~ s/$POD_link_re/$1/go;
1366  ***      0                                  0         MKDEBUG && _d('Option rule:', $para);
1367  ***      0                                  0         push @rules, $para;
1368                                                     }
1369                                                  
1370  ***      0      0                           0      die 'POD has no OPTIONS section' unless $para;
1371                                                  
1372  ***      0                                  0      do {
1373  ***      0      0                           0         if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
1374  ***      0                                  0            chomp $para;
1375  ***      0                                  0            MKDEBUG && _d($para);
1376  ***      0                                  0            my %attribs;
1377                                                  
1378  ***      0                                  0            $para = <$fh>; # read next paragraph, possibly attributes
1379                                                  
1380  ***      0      0                           0            if ( $para =~ m/: / ) { # attributes
1381  ***      0                                  0               $para =~ s/\s+\Z//g;
1382  ***      0                                  0               %attribs = map { split(/: /, $_) } split(/; /, $para);
      ***      0                                  0   
1383  ***      0      0                           0               if ( $attribs{'short form'} ) {
1384  ***      0                                  0                  $attribs{'short form'} =~ s/-//;
1385                                                              }
1386  ***      0                                  0               $para = <$fh>; # read next paragraph, probably short help desc
1387                                                           }
1388                                                           else {
1389  ***      0                                  0               MKDEBUG && _d('Option has no attributes');
1390                                                           }
1391                                                  
1392  ***      0                                  0            $para =~ s/\s+\Z//g;
1393  ***      0                                  0            $para =~ s/\s+/ /g;
1394  ***      0                                  0            $para =~ s/$POD_link_re/$1/go;
1395                                                  
1396  ***      0                                  0            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
1397  ***      0                                  0            MKDEBUG && _d('Short help:', $para);
1398                                                  
1399  ***      0      0                           0            die "No description after option spec $option" if $para =~ m/^=item/;
1400                                                  
1401  ***      0      0                           0            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
1402  ***      0                                  0               $option = $base_option;
1403  ***      0                                  0               $attribs{'negatable'} = 1;
1404                                                           }
1405                                                  
1406  ***      0      0                           0            push @specs, {
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
1407                                                              spec  => $option
1408                                                                 . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
1409                                                                 . ($attribs{'negatable'}  ? '!'                          : '' )
1410                                                                 . ($attribs{'cumulative'} ? '+'                          : '' )
1411                                                                 . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
1412                                                              desc  => $para
1413                                                                 . ($attribs{default} ? " (default $attribs{default})" : ''),
1414                                                              group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
1415                                                           };
1416                                                        }
1417  ***      0                                  0         while ( $para = <$fh> ) {
1418  ***      0      0                           0            last unless $para;
1419                                                  
1420                                                  
1421  ***      0      0                           0            if ( $para =~ m/^=head1/ ) {
1422  ***      0                                  0               $para = undef; # Can't 'last' out of a do {} block.
1423  ***      0                                  0               last;
1424                                                           }
1425  ***      0      0                           0            last if $para =~ m/^=item --/;
1426                                                        }
1427                                                     } while ( $para );
1428                                                  
1429  ***      0      0                           0      die 'No valid specs in POD OPTIONS' unless @specs;
1430                                                  
1431  ***      0                                  0      close $fh;
1432  ***      0                                  0      return @specs, @rules;
1433                                                  }
1434                                                  
1435                                                  sub _parse_specs {
1436  ***      0                    0             0      my ( $self, @specs ) = @_;
1437  ***      0                                  0      my %disables; # special rule that requires deferred checking
1438                                                  
1439  ***      0                                  0      foreach my $opt ( @specs ) {
1440  ***      0      0                           0         if ( ref $opt ) { # It's an option spec, not a rule.
1441                                                           MKDEBUG && _d('Parsing opt spec:',
1442  ***      0                                  0               map { ($_, '=>', $opt->{$_}) } keys %$opt);
1443                                                  
1444  ***      0                                  0            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
1445  ***      0      0                           0            if ( !$long ) {
1446  ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
1447                                                           }
1448  ***      0                                  0            $opt->{long} = $long;
1449                                                  
1450  ***      0      0                           0            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
1451  ***      0                                  0            $self->{opts}->{$long} = $opt;
1452                                                  
1453  ***      0      0                           0            if ( length $long == 1 ) {
1454  ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
1455  ***      0                                  0               $self->{short_opts}->{$long} = $long;
1456                                                           }
1457                                                  
1458  ***      0      0                           0            if ( $short ) {
1459  ***      0      0                           0               die "Duplicate short option -$short"
1460                                                                 if exists $self->{short_opts}->{$short};
1461  ***      0                                  0               $self->{short_opts}->{$short} = $long;
1462  ***      0                                  0               $opt->{short} = $short;
1463                                                           }
1464                                                           else {
1465  ***      0                                  0               $opt->{short} = undef;
1466                                                           }
1467                                                  
1468  ***      0      0                           0            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
1469  ***      0      0                           0            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
1470  ***      0      0                           0            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
1471                                                  
1472  ***      0             0                    0            $opt->{group} ||= 'default';
1473  ***      0                                  0            $self->{groups}->{ $opt->{group} }->{$long} = 1;
1474                                                  
1475  ***      0                                  0            $opt->{value} = undef;
1476  ***      0                                  0            $opt->{got}   = 0;
1477                                                  
1478  ***      0                                  0            my ( $type ) = $opt->{spec} =~ m/=(.)/;
1479  ***      0                                  0            $opt->{type} = $type;
1480  ***      0                                  0            MKDEBUG && _d($long, 'type:', $type);
1481                                                  
1482  ***      0      0      0                    0            if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                    0                        
1483  ***      0                                  0               die "$opt->{long} is type DSN (d) but no dp argument "
1484                                                                 . "was given when this OptionParser object was created";
1485                                                           }
1486                                                  
1487  ***      0      0      0                    0            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
1488                                                  
1489  ***      0      0                           0            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
1490  ***      0      0                           0               if ( $opt->{is_negatable} ) {
1491  ***      0      0                           0                  $def = $def eq 'yes' ? 1
      ***             0                               
1492                                                                      : $def eq 'no'  ? 0
1493                                                                      : $def;
1494                                                              }
1495  ***      0      0                           0               $self->{defaults}->{$long} = defined $def ? $def : 1;
1496  ***      0                                  0               MKDEBUG && _d($long, 'default:', $def);
1497                                                           }
1498                                                  
1499  ***      0      0                           0            if ( $long eq 'config' ) {
1500  ***      0                                  0               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
1501                                                           }
1502                                                  
1503  ***      0      0                           0            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
1504  ***      0                                  0               $disables{$long} = $dis;
1505  ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
1506                                                           }
1507                                                  
1508  ***      0                                  0            $self->{opts}->{$long} = $opt;
1509                                                        }
1510                                                        else { # It's an option rule, not a spec.
1511  ***      0                                  0            MKDEBUG && _d('Parsing rule:', $opt); 
1512  ***      0                                  0            push @{$self->{rules}}, $opt;
      ***      0                                  0   
1513  ***      0                                  0            my @participants = $self->_get_participants($opt);
1514  ***      0                                  0            my $rule_ok = 0;
1515                                                  
1516  ***      0      0                           0            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
1517  ***      0                                  0               $rule_ok = 1;
1518  ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
1519  ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
1520                                                           }
1521  ***      0      0                           0            if ( $opt =~ m/at least one|one and only one/ ) {
1522  ***      0                                  0               $rule_ok = 1;
1523  ***      0                                  0               push @{$self->{atleast1}}, \@participants;
      ***      0                                  0   
1524  ***      0                                  0               MKDEBUG && _d(@participants, 'require at least one');
1525                                                           }
1526  ***      0      0                           0            if ( $opt =~ m/default to/ ) {
1527  ***      0                                  0               $rule_ok = 1;
1528  ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
1529  ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
1530                                                           }
1531  ***      0      0                           0            if ( $opt =~ m/restricted to option groups/ ) {
1532  ***      0                                  0               $rule_ok = 1;
1533  ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
1534  ***      0                                  0               my @groups = split(',', $groups);
1535  ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
1536  ***      0                                  0                  s/\s+//;
1537  ***      0                                  0                  $_ => 1;
1538                                                              } @groups;
1539                                                           }
1540                                                  
1541  ***      0      0                           0            die "Unrecognized option rule: $opt" unless $rule_ok;
1542                                                        }
1543                                                     }
1544                                                  
1545  ***      0                                  0      foreach my $long ( keys %disables ) {
1546  ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
1547  ***      0                                  0         $self->{disables}->{$long} = \@participants;
1548  ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
1549                                                     }
1550                                                  
1551  ***      0                                  0      return; 
1552                                                  }
1553                                                  
1554                                                  sub _get_participants {
1555  ***      0                    0             0      my ( $self, $str ) = @_;
1556  ***      0                                  0      my @participants;
1557  ***      0                                  0      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
1558  ***      0      0                           0         die "Option --$long does not exist while processing rule $str"
1559                                                           unless exists $self->{opts}->{$long};
1560  ***      0                                  0         push @participants, $long;
1561                                                     }
1562  ***      0                                  0      MKDEBUG && _d('Participants for', $str, ':', @participants);
1563  ***      0                                  0      return @participants;
1564                                                  }
1565                                                  
1566                                                  sub opts {
1567  ***      0                    0             0      my ( $self ) = @_;
1568  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1569  ***      0                                  0      return %opts;
1570                                                  }
1571                                                  
1572                                                  sub opt_values {
1573  ***      0                    0             0      my ( $self ) = @_;
1574  ***      0      0                           0      my %opts = map {
1575  ***      0                                  0         my $opt = $self->{opts}->{$_}->{short} ? $self->{opts}->{$_}->{short}
1576                                                                : $_;
1577  ***      0                                  0         $opt => $self->{opts}->{$_}->{value}
1578  ***      0                                  0      } keys %{$self->{opts}};
1579  ***      0                                  0      return %opts;
1580                                                  }
1581                                                  
1582                                                  sub short_opts {
1583  ***      0                    0             0      my ( $self ) = @_;
1584  ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
1585  ***      0                                  0      return %short_opts;
1586                                                  }
1587                                                  
1588                                                  sub set_defaults {
1589  ***      0                    0             0      my ( $self, %defaults ) = @_;
1590  ***      0                                  0      $self->{defaults} = {};
1591  ***      0                                  0      foreach my $long ( keys %defaults ) {
1592  ***      0      0                           0         die "Cannot set default for nonexistent option $long"
1593                                                           unless exists $self->{opts}->{$long};
1594  ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
1595  ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
1596                                                     }
1597  ***      0                                  0      return;
1598                                                  }
1599                                                  
1600                                                  sub get_defaults {
1601  ***      0                    0             0      my ( $self ) = @_;
1602  ***      0                                  0      return $self->{defaults};
1603                                                  }
1604                                                  
1605                                                  sub get_groups {
1606  ***      0                    0             0      my ( $self ) = @_;
1607  ***      0                                  0      return $self->{groups};
1608                                                  }
1609                                                  
1610                                                  sub _set_option {
1611  ***      0                    0             0      my ( $self, $opt, $val ) = @_;
1612  ***      0      0                           0      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***             0                               
1613                                                              : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
1614                                                              : die "Getopt::Long gave a nonexistent option: $opt";
1615                                                  
1616  ***      0                                  0      $opt = $self->{opts}->{$long};
1617  ***      0      0                           0      if ( $opt->{is_cumulative} ) {
1618  ***      0                                  0         $opt->{value}++;
1619                                                     }
1620                                                     else {
1621  ***      0                                  0         $opt->{value} = $val;
1622                                                     }
1623  ***      0                                  0      $opt->{got} = 1;
1624  ***      0                                  0      MKDEBUG && _d('Got option', $long, '=', $val);
1625                                                  }
1626                                                  
1627                                                  sub get_opts {
1628  ***      0                    0             0      my ( $self ) = @_; 
1629                                                  
1630  ***      0                                  0      foreach my $long ( keys %{$self->{opts}} ) {
      ***      0                                  0   
1631  ***      0                                  0         $self->{opts}->{$long}->{got} = 0;
1632  ***      0      0                           0         $self->{opts}->{$long}->{value}
      ***             0                               
1633                                                           = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
1634                                                           : $self->{opts}->{$long}->{is_cumulative} ? 0
1635                                                           : undef;
1636                                                     }
1637  ***      0                                  0      $self->{got_opts} = 0;
1638                                                  
1639  ***      0                                  0      $self->{errors} = [];
1640                                                  
1641  ***      0      0      0                    0      if ( @ARGV && $ARGV[0] eq "--config" ) {
1642  ***      0                                  0         shift @ARGV;
1643  ***      0                                  0         $self->_set_option('config', shift @ARGV);
1644                                                     }
1645  ***      0      0                           0      if ( $self->has('config') ) {
1646  ***      0                                  0         my @extra_args;
1647  ***      0                                  0         foreach my $filename ( split(',', $self->get('config')) ) {
1648  ***      0                                  0            eval {
1649  ***      0                                  0               push @ARGV, $self->_read_config_file($filename);
1650                                                           };
1651  ***      0      0                           0            if ( $EVAL_ERROR ) {
1652  ***      0      0                           0               if ( $self->got('config') ) {
1653  ***      0                                  0                  die $EVAL_ERROR;
1654                                                              }
1655                                                              elsif ( MKDEBUG ) {
1656                                                                 _d($EVAL_ERROR);
1657                                                              }
1658                                                           }
1659                                                        }
1660  ***      0                                  0         unshift @ARGV, @extra_args;
1661                                                     }
1662                                                  
1663  ***      0                                  0      Getopt::Long::Configure('no_ignore_case', 'bundling');
1664                                                     GetOptions(
1665  ***      0                    0             0         map    { $_->{spec} => sub { $self->_set_option(@_); } }
      ***      0                                  0   
      ***      0                                  0   
1666  ***      0                                  0         grep   { $_->{long} ne 'config' } # --config is handled specially above.
1667  ***      0      0                           0         values %{$self->{opts}}
1668                                                     ) or $self->save_error('Error parsing options');
1669                                                  
1670  ***      0      0      0                    0      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
1671  ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
1672                                                           $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
1673                                                              or die "Cannot print: $OS_ERROR";
1674  ***      0                                  0         exit 0;
1675                                                     }
1676                                                  
1677  ***      0      0      0                    0      if ( @ARGV && $self->{strict} ) {
1678  ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
1679                                                     }
1680                                                  
1681  ***      0                                  0      foreach my $mutex ( @{$self->{mutex}} ) {
      ***      0                                  0   
1682  ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
1683  ***      0      0                           0         if ( @set > 1 ) {
1684  ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
1685  ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
1686                                                                   . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
1687                                                                   . ' are mutually exclusive.';
1688  ***      0                                  0            $self->save_error($err);
1689                                                        }
1690                                                     }
1691                                                  
1692  ***      0                                  0      foreach my $required ( @{$self->{atleast1}} ) {
      ***      0                                  0   
1693  ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                  0   
1694  ***      0      0                           0         if ( @set == 0 ) {
1695  ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
1696  ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
1697                                                                   .' or --'.$self->{opts}->{$required->[-1]}->{long};
1698  ***      0                                  0            $self->save_error("Specify at least one of $err");
1699                                                        }
1700                                                     }
1701                                                  
1702  ***      0                                  0      foreach my $long ( keys %{$self->{opts}} ) {
      ***      0                                  0   
1703  ***      0                                  0         my $opt = $self->{opts}->{$long};
1704  ***      0      0                           0         if ( $opt->{got} ) {
      ***             0                               
1705  ***      0      0                           0            if ( exists $self->{disables}->{$long} ) {
1706  ***      0                                  0               my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
1707  ***      0                                  0               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
1708  ***      0                                  0               MKDEBUG && _d('Unset options', @disable_opts,
1709                                                                 'because', $long,'disables them');
1710                                                           }
1711                                                  
1712  ***      0      0                           0            if ( exists $self->{allowed_groups}->{$long} ) {
1713                                                  
1714  ***      0                                  0               my @restricted_groups = grep {
1715  ***      0                                  0                  !exists $self->{allowed_groups}->{$long}->{$_}
1716  ***      0                                  0               } keys %{$self->{groups}};
1717                                                  
1718  ***      0                                  0               my @restricted_opts;
1719  ***      0                                  0               foreach my $restricted_group ( @restricted_groups ) {
1720  ***      0                                  0                  RESTRICTED_OPT:
1721  ***      0                                  0                  foreach my $restricted_opt (
1722                                                                    keys %{$self->{groups}->{$restricted_group}} )
1723                                                                 {
1724  ***      0      0                           0                     next RESTRICTED_OPT if $restricted_opt eq $long;
1725  ***      0      0                           0                     push @restricted_opts, $restricted_opt
1726                                                                       if $self->{opts}->{$restricted_opt}->{got};
1727                                                                 }
1728                                                              }
1729                                                  
1730  ***      0      0                           0               if ( @restricted_opts ) {
1731  ***      0                                  0                  my $err;
1732  ***      0      0                           0                  if ( @restricted_opts == 1 ) {
1733  ***      0                                  0                     $err = "--$restricted_opts[0]";
1734                                                                 }
1735                                                                 else {
1736  ***      0                                  0                     $err = join(', ',
1737  ***      0                                  0                               map { "--$self->{opts}->{$_}->{long}" }
1738  ***      0                                  0                               grep { $_ } 
1739                                                                              @restricted_opts[0..scalar(@restricted_opts) - 2]
1740                                                                           )
1741                                                                         . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
1742                                                                 }
1743  ***      0                                  0                  $self->save_error("--$long is not allowed with $err");
1744                                                              }
1745                                                           }
1746                                                  
1747                                                        }
1748                                                        elsif ( $opt->{is_required} ) { 
1749  ***      0                                  0            $self->save_error("Required option --$long must be specified");
1750                                                        }
1751                                                  
1752  ***      0                                  0         $self->_validate_type($opt);
1753                                                     }
1754                                                  
1755  ***      0                                  0      $self->{got_opts} = 1;
1756  ***      0                                  0      return;
1757                                                  }
1758                                                  
1759                                                  sub _validate_type {
1760  ***      0                    0             0      my ( $self, $opt ) = @_;
1761  ***      0      0      0                    0      return unless $opt && $opt->{type};
1762  ***      0                                  0      my $val = $opt->{value};
1763                                                  
1764  ***      0      0      0                    0      if ( $val && $opt->{type} eq 'm' ) {
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***                    0                        
      ***                    0                        
1765  ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
1766  ***      0                                  0         my ( $num, $suffix ) = $val =~ m/(\d+)([a-z])?$/;
1767  ***      0      0                           0         if ( !$suffix ) {
1768  ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
1769  ***      0             0                    0            $suffix = $s || 's';
1770  ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
1771                                                              $opt->{long}, '(value:', $val, ')');
1772                                                        }
1773  ***      0      0                           0         if ( $suffix =~ m/[smhd]/ ) {
1774  ***      0      0                           0            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***             0                               
1775                                                                : $suffix eq 'm' ? $num * 60       # Minutes
1776                                                                : $suffix eq 'h' ? $num * 3600     # Hours
1777                                                                :                  $num * 86400;   # Days
1778  ***      0                                  0            $opt->{value} = $val;
1779  ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
1780                                                        }
1781                                                        else {
1782  ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
1783                                                        }
1784                                                     }
1785                                                     elsif ( $val && $opt->{type} eq 'd' ) {
1786  ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
1787  ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
1788  ***      0                                  0         my $default = {};
1789  ***      0      0                           0         if ( $from_key ) {
1790  ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
1791  ***      0                                  0            $default = $self->{dp}->parse(
1792                                                              $self->{dp}->as_string($self->{opts}->{$from_key}->{value}) );
1793                                                        }
1794  ***      0                                  0         $opt->{value} = $self->{dp}->parse($val, $default);
1795                                                     }
1796                                                     elsif ( $val && $opt->{type} eq 'z' ) {
1797  ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
1798  ***      0                                  0         my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
1799  ***      0                                  0         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
1800  ***      0      0                           0         if ( defined $num ) {
1801  ***      0      0                           0            if ( $factor ) {
1802  ***      0                                  0               $num *= $factor_for{$factor};
1803  ***      0                                  0               MKDEBUG && _d('Setting option', $opt->{y},
1804                                                                 'to num', $num, '* factor', $factor);
1805                                                           }
1806  ***      0             0                    0            $opt->{value} = ($pre || '') . $num;
1807                                                        }
1808                                                        else {
1809  ***      0                                  0            $self->save_error("Invalid size for --$opt->{long}");
1810                                                        }
1811                                                     }
1812                                                     elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
1813  ***      0             0                    0         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
      ***      0                                  0   
1814                                                     }
1815                                                     elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
1816  ***      0             0                    0         $opt->{value} = [ split(/(?<!\\),/, ($val || '')) ];
1817                                                     }
1818                                                     else {
1819  ***      0                                  0         MKDEBUG && _d('Nothing to validate for option',
1820                                                           $opt->{long}, 'type', $opt->{type}, 'value', $val);
1821                                                     }
1822                                                  
1823  ***      0                                  0      return;
1824                                                  }
1825                                                  
1826                                                  sub get {
1827  ***      0                    0             0      my ( $self, $opt ) = @_;
1828  ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1829  ***      0      0      0                    0      die "Option $opt does not exist"
1830                                                        unless $long && exists $self->{opts}->{$long};
1831  ***      0                                  0      return $self->{opts}->{$long}->{value};
1832                                                  }
1833                                                  
1834                                                  sub got {
1835  ***      0                    0             0      my ( $self, $opt ) = @_;
1836  ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1837  ***      0      0      0                    0      die "Option $opt does not exist"
1838                                                        unless $long && exists $self->{opts}->{$long};
1839  ***      0                                  0      return $self->{opts}->{$long}->{got};
1840                                                  }
1841                                                  
1842                                                  sub has {
1843  ***      0                    0             0      my ( $self, $opt ) = @_;
1844  ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1845  ***      0      0                           0      return defined $long ? exists $self->{opts}->{$long} : 0;
1846                                                  }
1847                                                  
1848                                                  sub set {
1849  ***      0                    0             0      my ( $self, $opt, $val ) = @_;
1850  ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1851  ***      0      0      0                    0      die "Option $opt does not exist"
1852                                                        unless $long && exists $self->{opts}->{$long};
1853  ***      0                                  0      $self->{opts}->{$long}->{value} = $val;
1854  ***      0                                  0      return;
1855                                                  }
1856                                                  
1857                                                  sub save_error {
1858  ***      0                    0             0      my ( $self, $error ) = @_;
1859  ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
1860                                                  }
1861                                                  
1862                                                  sub errors {
1863  ***      0                    0             0      my ( $self ) = @_;
1864  ***      0                                  0      return $self->{errors};
1865                                                  }
1866                                                  
1867                                                  sub prompt {
1868  ***      0                    0             0      my ( $self ) = @_;
1869  ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
1870                                                  }
1871                                                  
1872                                                  sub descr {
1873  ***      0                    0             0      my ( $self ) = @_;
1874  ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
1875                                                                . "  For more details, please use the --help option, "
1876                                                                . "or try 'perldoc $PROGRAM_NAME' "
1877                                                                . "for complete documentation.";
1878  ***      0                                  0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g);
1879  ***      0                                  0      $descr =~ s/ +$//mg;
1880  ***      0                                  0      return $descr;
1881                                                  }
1882                                                  
1883                                                  sub usage_or_errors {
1884  ***      0                    0             0      my ( $self ) = @_;
1885  ***      0      0                           0      if ( $self->{opts}->{help}->{got} ) {
      ***      0      0                           0   
1886  ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
1887  ***      0                                  0         exit 0;
1888                                                     }
1889                                                     elsif ( scalar @{$self->{errors}} ) {
1890  ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
1891  ***      0                                  0         exit 0;
1892                                                     }
1893  ***      0                                  0      return;
1894                                                  }
1895                                                  
1896                                                  sub print_errors {
1897  ***      0                    0             0      my ( $self ) = @_;
1898  ***      0                                  0      my $usage = $self->prompt() . "\n";
1899  ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
1900  ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
1901                                                                . "\n";
1902                                                     }
1903  ***      0                                  0      return $usage . "\n" . $self->descr();
1904                                                  }
1905                                                  
1906                                                  sub print_usage {
1907  ***      0                    0             0      my ( $self ) = @_;
1908  ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
1909  ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
1910                                                  
1911  ***      0      0                           0      my $maxl = max(
1912  ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
1913                                                        @opts);
1914                                                  
1915  ***      0      0                           0      my $maxs = max(0,
1916  ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
1917  ***      0                                  0         values %{$self->{short_opts}});
1918                                                  
1919  ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
1920  ***      0                                  0      my $rcol = 80 - $lcol - 6;
1921  ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
1922                                                  
1923  ***      0                                  0      $maxs = max($lcol - 3, $maxs);
1924                                                  
1925  ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
1926                                                  
1927  ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
1928  ***      0                                  0      push @groups, 'default';
1929                                                  
1930  ***      0                                  0      foreach my $group ( reverse @groups ) {
1931  ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
1932  ***      0                                  0         foreach my $opt (
      ***      0                                  0   
1933  ***      0                                  0            sort { $a->{long} cmp $b->{long} }
1934                                                           grep { $_->{group} eq $group }
1935                                                           @opts )
1936                                                        {
1937  ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
1938  ***      0                                  0            my $short = $opt->{short};
1939  ***      0                                  0            my $desc  = $opt->{desc};
1940  ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
1941  ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
1942  ***      0             0                    0               $s    ||= 's';
1943  ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
1944  ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
1945                                                                     . "d=days; if no suffix, $s is used.";
1946                                                           }
1947  ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
1948  ***      0                                  0            $desc =~ s/ +$//mg;
1949  ***      0      0                           0            if ( $short ) {
1950  ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
1951                                                           }
1952                                                           else {
1953  ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
1954                                                           }
1955                                                        }
1956                                                     }
1957                                                  
1958  ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
1959  ***      0                                  0         $usage .= "\nRules:\n\n";
1960  ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
1961                                                     }
1962  ***      0      0                           0      if ( $self->{dp} ) {
1963  ***      0                                  0         $usage .= "\n" . $self->{dp}->usage();
1964                                                     }
1965  ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
1966  ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
1967  ***      0                                  0         my $val   = $opt->{value};
1968  ***      0             0                    0         my $type  = $opt->{type} || '';
1969  ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
1970  ***      0      0                           0         $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
1971                                                                  : !defined $val             ? '(No value)'
1972                                                                  : $type eq 'd'              ? $self->{dp}->as_string($val)
1973                                                                  : $type =~ m/H|h/           ? join(',', sort keys %$val)
1974                                                                  : $type =~ m/A|a/           ? join(',', @$val)
1975                                                                  :                             $val;
1976  ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
1977                                                     }
1978  ***      0                                  0      return $usage;
1979                                                  }
1980                                                  
1981                                                  sub prompt_noecho {
1982  ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
1983  ***      0                                  0      my ( $prompt ) = @_;
1984  ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
1985  ***      0      0                           0      print $prompt
1986                                                        or die "Cannot print: $OS_ERROR";
1987  ***      0                                  0      my $response;
1988  ***      0                                  0      eval {
1989  ***      0                                  0         require Term::ReadKey;
1990  ***      0                                  0         Term::ReadKey::ReadMode('noecho');
1991  ***      0                                  0         chomp($response = <STDIN>);
1992  ***      0                                  0         Term::ReadKey::ReadMode('normal');
1993  ***      0      0                           0         print "\n"
1994                                                           or die "Cannot print: $OS_ERROR";
1995                                                     };
1996  ***      0      0                           0      if ( $EVAL_ERROR ) {
1997  ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
1998                                                     }
1999  ***      0                                  0      return $response;
2000                                                  }
2001                                                  
2002                                                  if ( MKDEBUG ) {
2003                                                     print '# ', $^X, ' ', $], "\n";
2004                                                     my $uname = `uname -a`;
2005                                                     if ( $uname ) {
2006                                                        $uname =~ s/\s+/ /g;
2007                                                        print "# $uname\n";
2008                                                     }
2009                                                     printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
2010                                                        $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
2011                                                        ($main::SVN_REV || ''), __LINE__);
2012                                                     print('# Arguments: ',
2013                                                        join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
2014                                                  }
2015                                                  
2016                                                  sub _read_config_file {
2017  ***      0                    0             0      my ( $self, $filename ) = @_;
2018  ***      0      0                           0      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
2019  ***      0                                  0      my @args;
2020  ***      0                                  0      my $prefix = '--';
2021  ***      0                                  0      my $parse  = 1;
2022                                                  
2023                                                     LINE:
2024  ***      0                                  0      while ( my $line = <$fh> ) {
2025  ***      0                                  0         chomp $line;
2026  ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
2027  ***      0                                  0         $line =~ s/\s+#.*$//g;
2028  ***      0                                  0         $line =~ s/^\s+|\s+$//g;
2029  ***      0      0                           0         if ( $line eq '--' ) {
2030  ***      0                                  0            $prefix = '';
2031  ***      0                                  0            $parse  = 0;
2032  ***      0                                  0            next LINE;
2033                                                        }
2034  ***      0      0      0                    0         if ( $parse
      ***             0                               
2035                                                           && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
2036                                                        ) {
2037  ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
2038                                                        }
2039                                                        elsif ( $line =~ m/./ ) {
2040  ***      0                                  0            push @args, $line;
2041                                                        }
2042                                                        else {
2043  ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
2044                                                        }
2045                                                     }
2046  ***      0                                  0      close $fh;
2047  ***      0                                  0      return @args;
2048                                                  }
2049                                                  
2050                                                  sub read_para_after {
2051  ***      0                    0             0      my ( $self, $file, $regex ) = @_;
2052  ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
2053  ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
2054  ***      0                                  0      my $para;
2055  ***      0                                  0      while ( $para = <$fh> ) {
2056  ***      0      0                           0         next unless $para =~ m/^=pod$/m;
2057  ***      0                                  0         last;
2058                                                     }
2059  ***      0                                  0      while ( $para = <$fh> ) {
2060  ***      0      0                           0         next unless $para =~ m/$regex/;
2061  ***      0                                  0         last;
2062                                                     }
2063  ***      0                                  0      $para = <$fh>;
2064  ***      0                                  0      chomp($para);
2065  ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
2066  ***      0                                  0      return $para;
2067                                                  }
2068                                                  
2069                                                  sub clone {
2070  ***      0                    0             0      my ( $self ) = @_;
2071                                                  
2072  ***      0                                  0      my %clone = map {
2073  ***      0                                  0         my $hashref  = $self->{$_};
2074  ***      0                                  0         my $val_copy = {};
2075  ***      0                                  0         foreach my $key ( keys %$hashref ) {
2076  ***      0                                  0            my $ref = ref $hashref->{$key};
2077  ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
2078  ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
2079  ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
2080                                                                             : $hashref->{$key};
2081                                                        }
2082  ***      0                                  0         $_ => $val_copy;
2083                                                     } qw(opts short_opts defaults);
2084                                                  
2085  ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
2086  ***      0                                  0         $clone{$scalar} = $self->{$scalar};
2087                                                     }
2088                                                  
2089  ***      0                                  0      return bless \%clone;     
2090                                                  }
2091                                                  
2092                                                  sub _d {
2093  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2094  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2095  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2096                                                          @_;
2097  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2098                                                  }
2099                                                  
2100                                                  1;
2101                                                  
2102                                                  # ###########################################################################
2103                                                  # End OptionParser package
2104                                                  # ###########################################################################
2105                                                  
2106                                                  # ###########################################################################
2107                                                  # KeySize package 3923
2108                                                  # ###########################################################################
2109                                                  package KeySize;
2110                                                  
2111           1                    1            48   use strict;
               1                                  3   
               1                                  8   
2112           1                    1             6   use warnings FATAL => 'all';
               1                                  3   
               1                                  7   
2113           1                    1             6   use English qw(-no_match_vars);
               1                                  3   
               1                                  6   
2114           1                    1             7   use DBI;
               1                                  9   
               1                                  6   
2115                                                  
2116           1                    1             6   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                  9   
2117                                                  
2118                                                  sub new {
2119  ***      0                    0             0      my ( $class, %args ) = @_;
2120  ***      0                                  0      my $self = { %args };
2121  ***      0                                  0      return bless $self, $class;
2122                                                  }
2123                                                  
2124                                                  sub get_key_size {
2125  ***      0                    0             0      my ( $self, %args ) = @_;
2126  ***      0                                  0      foreach my $arg ( qw(name cols tbl_name tbl_struct dbh) ) {
2127  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
2128                                                     }
2129  ***      0                                  0      my $name = $args{name};
2130  ***      0                                  0      my @cols = @{$args{cols}};
      ***      0                                  0   
2131  ***      0                                  0      my $dbh  = $args{dbh};
2132                                                  
2133  ***      0                                  0      $self->{explain} = '';
2134  ***      0                                  0      $self->{query}   = '';
2135  ***      0                                  0      $self->{error}   = '';
2136                                                  
2137  ***      0      0                           0      if ( @cols == 0 ) {
2138  ***      0                                  0         $self->{error} = "No columns for key $name";
2139  ***      0                                  0         return;
2140                                                     }
2141                                                  
2142  ***      0                                  0      my $key_exists = $self->_key_exists(%args);
2143  ***      0                                  0      MKDEBUG && _d('Key', $name, 'exists in', $args{tbl_name}, ':',
2144                                                        $key_exists ? 'yes': 'no');
2145                                                  
2146  ***      0      0                           0      my $sql = 'EXPLAIN SELECT ' . join(', ', @cols)
2147                                                             . ' FROM ' . $args{tbl_name}
2148                                                             . ($key_exists ? " FORCE INDEX (`$name`)" : '')
2149                                                             . ' WHERE ';
2150  ***      0                                  0      my @where_cols;
2151  ***      0                                  0      foreach my $col ( @cols ) {
2152  ***      0                                  0         push @where_cols, "$col=1";
2153                                                     }
2154  ***      0      0                           0      if ( scalar @cols == 1 ) {
2155  ***      0                                  0         push @where_cols, "$cols[0]<>1";
2156                                                     }
2157  ***      0                                  0      $sql .= join(' OR ', @where_cols);
2158  ***      0                                  0      $self->{query} = $sql;
2159  ***      0                                  0      MKDEBUG && _d('sql:', $sql);
2160                                                  
2161  ***      0                                  0      my $explain;
2162  ***      0                                  0      my $sth = $dbh->prepare($sql);
2163  ***      0                                  0      eval { $sth->execute(); };
      ***      0                                  0   
2164  ***      0      0                           0      if ( $EVAL_ERROR ) {
2165  ***      0                                  0         $self->{error} = "Cannot get size of $name key: $DBI::errstr";
2166  ***      0                                  0         return;
2167                                                     }
2168  ***      0                                  0      $explain = $sth->fetchrow_hashref();
2169                                                  
2170  ***      0                                  0      $self->{explain} = $explain;
2171  ***      0                                  0      my $key_len      = $explain->{key_len};
2172  ***      0                                  0      my $rows         = $explain->{rows};
2173  ***      0                                  0      my $chosen_key   = $explain->{key};  # May differ from $name
2174  ***      0                                  0      MKDEBUG && _d('MySQL chose key:', $chosen_key, 'len:', $key_len,
2175                                                        'rows:', $rows);
2176                                                  
2177  ***      0                                  0      my $key_size = 0;
2178  ***      0      0      0                    0      if ( $key_len && $rows ) {
2179  ***      0      0      0                    0         if ( $chosen_key =~ m/,/ && $key_len =~ m/,/ ) {
2180  ***      0                                  0            $self->{error} = "MySQL chose multiple keys: $chosen_key";
2181  ***      0                                  0            return;
2182                                                        }
2183  ***      0                                  0         $key_size = $key_len * $rows;
2184                                                     }
2185                                                     else {
2186  ***      0                                  0         $self->{error} = "key_len or rows NULL in EXPLAIN:\n"
2187                                                                       . _explain_to_text($explain);
2188  ***      0                                  0         return;
2189                                                     }
2190                                                  
2191  ***      0      0                           0      return wantarray ? ($key_size, $chosen_key) : $key_size;
2192                                                  }
2193                                                  
2194                                                  sub query {
2195  ***      0                    0             0      my ( $self ) = @_;
2196  ***      0                                  0      return $self->{query};
2197                                                  }
2198                                                  
2199                                                  sub explain {
2200  ***      0                    0             0      my ( $self ) = @_;
2201  ***      0                                  0      return _explain_to_text($self->{explain});
2202                                                  }
2203                                                  
2204                                                  sub error {
2205  ***      0                    0             0      my ( $self ) = @_;
2206  ***      0                                  0      return $self->{error};
2207                                                  }
2208                                                  
2209                                                  sub _key_exists {
2210  ***      0                    0             0      my ( $self, %args ) = @_;
2211  ***      0      0                           0      return exists $args{tbl_struct}->{keys}->{ lc $args{name} } ? 1 : 0;
2212                                                  }
2213                                                  
2214                                                  sub _explain_to_text {
2215  ***      0                    0             0      my ( $explain ) = @_;
2216  ***      0      0                           0      return join("\n",
2217  ***      0                                  0         map { "$_: ".($explain->{$_} ? $explain->{$_} : 'NULL') }
2218                                                        sort keys %$explain
2219                                                     );
2220                                                  }
2221                                                  
2222                                                  sub _d {
2223  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2224  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2225  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2226                                                          @_;
2227  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2228                                                  }
2229                                                  
2230                                                  1;
2231                                                  
2232                                                  # ###########################################################################
2233                                                  # End KeySize package
2234                                                  # ###########################################################################
2235                                                  
2236                                                  # ###########################################################################
2237                                                  # DuplicateKeyFinder package 3920
2238                                                  # ###########################################################################
2239                                                  package DuplicateKeyFinder;
2240                                                  
2241           1                    1             8   use strict;
               1                                  2   
               1                                  9   
2242           1                    1             7   use warnings FATAL => 'all';
               1                                  3   
               1                                  5   
2243           1                    1            10   use English qw(-no_match_vars);
               1                                  3   
               1                                  5   
2244                                                  
2245           1                    1             7   use List::Util qw(min);
               1                                  3   
               1                                  6   
2246                                                  
2247           1                    1             6   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                  7   
2248                                                  
2249                                                  sub new {
2250  ***      0                    0             0      my ( $class, %args ) = @_;
2251  ***      0                                  0      my $self = {};
2252  ***      0                                  0      return bless $self, $class;
2253                                                  }
2254                                                  
2255                                                  sub get_duplicate_keys {
2256  ***      0                    0             0      my ( $self, $keys,  %args ) = @_;
2257  ***      0      0                           0      die "I need a keys argument" unless $keys;
2258  ***      0                                  0      my %keys = %$keys;  # Copy keys because we remove non-duplicates.
2259  ***      0                                  0      my $primary_key;
2260  ***      0                                  0      my @unique_keys;
2261  ***      0                                  0      my @normal_keys;
2262  ***      0                                  0      my @fulltext_keys;
2263  ***      0                                  0      my @dupes;
2264                                                  
2265                                                     KEY:
2266  ***      0                                  0      foreach my $key ( values %keys ) {
2267  ***      0                                  0         $key->{real_cols} = $key->{colnames}; 
2268                                                  
2269  ***      0                                  0         $key->{len_cols}  = length $key->{colnames};
2270                                                  
2271  ***      0      0                           0         if ( $key->{name} eq 'PRIMARY' ) {
2272  ***      0                                  0            $primary_key = $key;
2273  ***      0                                  0            next KEY;
2274                                                        }
2275                                                  
2276  ***      0      0                           0         my $is_fulltext = $key->{type} eq 'FULLTEXT' ? 1 : 0;
2277  ***      0      0      0                    0         if ( $args{ignore_order} || $is_fulltext  ) {
2278  ***      0                                  0            my $ordered_cols = join(',', sort(split(/,/, $key->{colnames})));
2279  ***      0                                  0            MKDEBUG && _d('Reordered', $key->{name}, 'cols from',
2280                                                              $key->{colnames}, 'to', $ordered_cols); 
2281  ***      0                                  0            $key->{colnames} = $ordered_cols;
2282                                                        }
2283                                                  
2284  ***      0      0                           0         my $push_to = $key->{is_unique} ? \@unique_keys : \@normal_keys;
2285  ***      0      0                           0         if ( !$args{ignore_structure} ) {
2286  ***      0      0                           0            $push_to = \@fulltext_keys if $is_fulltext;
2287                                                        }
2288  ***      0                                  0         push @$push_to, $key; 
2289                                                     }
2290                                                  
2291  ***      0                                  0      push @normal_keys, $self->unconstrain_keys($primary_key, \@unique_keys);
2292                                                  
2293  ***      0      0                           0      if ( $primary_key ) {
2294  ***      0                                  0         MKDEBUG && _d('Comparing PRIMARY KEY to UNIQUE keys');
2295  ***      0                                  0         push @dupes,
2296                                                           $self->remove_prefix_duplicates([$primary_key], \@unique_keys, %args);
2297                                                  
2298  ***      0                                  0         MKDEBUG && _d('Comparing PRIMARY KEY to normal keys');
2299  ***      0                                  0         push @dupes,
2300                                                           $self->remove_prefix_duplicates([$primary_key], \@normal_keys, %args);
2301                                                     }
2302                                                  
2303  ***      0                                  0      MKDEBUG && _d('Comparing UNIQUE keys to normal keys');
2304  ***      0                                  0      push @dupes,
2305                                                        $self->remove_prefix_duplicates(\@unique_keys, \@normal_keys, %args);
2306                                                  
2307  ***      0                                  0      MKDEBUG && _d('Comparing normal keys');
2308  ***      0                                  0      push @dupes,
2309                                                        $self->remove_prefix_duplicates(\@normal_keys, \@normal_keys, %args);
2310                                                  
2311  ***      0                                  0      MKDEBUG && _d('Comparing FULLTEXT keys');
2312  ***      0                                  0      push @dupes,
2313                                                        $self->remove_prefix_duplicates(\@fulltext_keys, \@fulltext_keys, %args, exact_duplicates => 1);
2314                                                  
2315                                                  
2316  ***      0      0      0                    0      if ( $primary_key
      ***                    0                        
      ***                    0                        
2317                                                          && $args{clustered}
2318                                                          && $args{tbl_info}->{engine}
2319                                                          && $args{tbl_info}->{engine} =~ m/^(?:InnoDB|solidDB)$/ )
2320                                                     {
2321  ***      0                                  0         MKDEBUG && _d('Removing UNIQUE dupes of clustered key');
2322  ***      0                                  0         push @dupes,
2323                                                           $self->remove_clustered_duplicates($primary_key, \@unique_keys, %args);
2324                                                  
2325  ***      0                                  0         MKDEBUG && _d('Removing ordinary dupes of clustered key');
2326  ***      0                                  0         push @dupes,
2327                                                           $self->remove_clustered_duplicates($primary_key, \@normal_keys, %args);
2328                                                     }
2329                                                  
2330  ***      0                                  0      return \@dupes;
2331                                                  }
2332                                                  
2333                                                  sub get_duplicate_fks {
2334  ***      0                    0             0      my ( $self, $fks, %args ) = @_;
2335  ***      0      0                           0      die "I need a fks argument" unless $fks;
2336  ***      0                                  0      my @fks = values %$fks;
2337  ***      0                                  0      my @dupes;
2338                                                  
2339  ***      0                                  0      foreach my $i ( 0..$#fks - 1 ) {
2340  ***      0      0                           0         next unless $fks[$i];
2341  ***      0                                  0         foreach my $j ( $i+1..$#fks ) {
2342  ***      0      0                           0            next unless $fks[$j];
2343                                                  
2344  ***      0                                  0            my $i_cols  = join(',', sort @{$fks[$i]->{cols}} );
      ***      0                                  0   
2345  ***      0                                  0            my $j_cols  = join(',', sort @{$fks[$j]->{cols}} );
      ***      0                                  0   
2346  ***      0                                  0            my $i_pcols = join(',', sort @{$fks[$i]->{parent_cols}} );
      ***      0                                  0   
2347  ***      0                                  0            my $j_pcols = join(',', sort @{$fks[$j]->{parent_cols}} );
      ***      0                                  0   
2348                                                  
2349  ***      0      0      0                    0            if ( $fks[$i]->{parent_tbl} eq $fks[$j]->{parent_tbl}
      ***                    0                        
2350                                                                && $i_cols  eq $j_cols
2351                                                                && $i_pcols eq $j_pcols ) {
2352  ***      0                                  0               my $dupe = {
2353                                                                 key               => $fks[$j]->{name},
2354                                                                 cols              => $fks[$j]->{colnames},
2355                                                                 duplicate_of      => $fks[$i]->{name},
2356                                                                 duplicate_of_cols => $fks[$i]->{colnames},
2357                                                                 reason       =>
2358                                                                      "FOREIGN KEY $fks[$j]->{name} ($fks[$j]->{colnames}) "
2359                                                                    . "REFERENCES $fks[$j]->{parent_tbl} "
2360                                                                    . "($fks[$j]->{parent_colnames}) "
2361                                                                    . 'is a duplicate of '
2362                                                                    . "FOREIGN KEY $fks[$i]->{name} ($fks[$i]->{colnames}) "
2363                                                                    . "REFERENCES $fks[$i]->{parent_tbl} "
2364                                                                    ."($fks[$i]->{parent_colnames})"
2365                                                              };
2366  ***      0                                  0               push @dupes, $dupe;
2367  ***      0                                  0               delete $fks[$j];
2368  ***      0      0                           0               $args{callback}->($dupe, %args) if $args{callback};
2369                                                           }
2370                                                        }
2371                                                     }
2372  ***      0                                  0      return \@dupes;
2373                                                  }
2374                                                  
2375                                                  sub remove_prefix_duplicates {
2376  ***      0                    0             0      my ( $self, $left_keys, $right_keys, %args ) = @_;
2377  ***      0                                  0      my @dupes;
2378  ***      0                                  0      my $right_offset;
2379  ***      0                                  0      my $last_left_key;
2380  ***      0                                  0      my $last_right_key = scalar(@$right_keys) - 1;
2381                                                  
2382                                                  
2383  ***      0      0                           0      if ( $right_keys != $left_keys ) {
2384                                                  
2385  ***      0                                  0         @$left_keys = sort { $a->{colnames} cmp $b->{colnames} }
      ***      0                                  0   
2386  ***      0                                  0                       grep { defined $_; }
2387                                                                      @$left_keys;
2388  ***      0                                  0         @$right_keys = sort { $a->{colnames} cmp $b->{colnames} }
      ***      0                                  0   
2389  ***      0                                  0                        grep { defined $_; }
2390                                                                      @$right_keys;
2391                                                  
2392  ***      0                                  0         $last_left_key = scalar(@$left_keys) - 1;
2393                                                  
2394  ***      0                                  0         $right_offset = 0;
2395                                                     }
2396                                                     else {
2397                                                  
2398  ***      0                                  0         @$left_keys = reverse sort { $a->{colnames} cmp $b->{colnames} }
      ***      0                                  0   
2399  ***      0                                  0                       grep { defined $_; }
2400                                                                      @$left_keys;
2401                                                        
2402  ***      0                                  0         $last_left_key = scalar(@$left_keys) - 2;
2403                                                  
2404  ***      0                                  0         $right_offset = 1;
2405                                                     }
2406                                                  
2407                                                     LEFT_KEY:
2408  ***      0                                  0      foreach my $left_index ( 0..$last_left_key ) {
2409  ***      0      0                           0         next LEFT_KEY unless defined $left_keys->[$left_index];
2410                                                  
2411                                                        RIGHT_KEY:
2412  ***      0                                  0         foreach my $right_index ( $left_index+$right_offset..$last_right_key ) {
2413  ***      0      0                           0            next RIGHT_KEY unless defined $right_keys->[$right_index];
2414                                                  
2415  ***      0                                  0            my $left_name      = $left_keys->[$left_index]->{name};
2416  ***      0                                  0            my $left_cols      = $left_keys->[$left_index]->{colnames};
2417  ***      0                                  0            my $left_len_cols  = $left_keys->[$left_index]->{len_cols};
2418  ***      0                                  0            my $right_name     = $right_keys->[$right_index]->{name};
2419  ***      0                                  0            my $right_cols     = $right_keys->[$right_index]->{colnames};
2420  ***      0                                  0            my $right_len_cols = $right_keys->[$right_index]->{len_cols};
2421                                                  
2422  ***      0                                  0            MKDEBUG && _d('Comparing left', $left_name, '(',$left_cols,')',
2423                                                              'to right', $right_name, '(',$right_cols,')');
2424                                                  
2425  ***      0      0                           0            if (    substr($left_cols,  0, $right_len_cols)
2426                                                                eq substr($right_cols, 0, $right_len_cols) ) {
2427                                                  
2428  ***      0      0      0                    0               if ( $args{exact_duplicates} && ($right_len_cols<$left_len_cols) ) {
2429  ***      0                                  0                  MKDEBUG && _d($right_name, 'not exact duplicate of', $left_name);
2430  ***      0                                  0                  next RIGHT_KEY;
2431                                                              }
2432                                                  
2433  ***      0      0                           0               if ( exists $right_keys->[$right_index]->{unique_col} ) {
2434  ***      0                                  0                  MKDEBUG && _d('Cannot remove', $right_name,
2435                                                                    'because is constrains col',
2436                                                                    $right_keys->[$right_index]->{cols}->[0]);
2437  ***      0                                  0                  next RIGHT_KEY;
2438                                                              }
2439                                                  
2440  ***      0                                  0               MKDEBUG && _d('Remove', $right_name);
2441  ***      0                                  0               my $reason;
2442  ***      0      0                           0               if ( $right_keys->[$right_index]->{unconstrained} ) {
2443  ***      0                                  0                  $reason .= "Uniqueness of $right_name ignored because "
2444                                                                    . $right_keys->[$right_index]->{constraining_key}->{name}
2445                                                                    . " is a stronger constraint\n"; 
2446                                                              }
2447  ***      0      0                           0               $reason .= $right_name
2448                                                                       . ($right_len_cols<$left_len_cols ? ' is a left-prefix of '
2449                                                                                                         : ' is a duplicate of ')
2450                                                                       . $left_name;
2451  ***      0                                  0               my $dupe = {
2452                                                                 key               => $right_name,
2453                                                                 cols              => $right_keys->[$right_index]->{real_cols},
2454                                                                 duplicate_of      => $left_name,
2455                                                                 duplicate_of_cols => $left_keys->[$left_index]->{real_cols},
2456                                                                 reason            => $reason,
2457                                                              };
2458  ***      0                                  0               push @dupes, $dupe;
2459  ***      0                                  0               delete $right_keys->[$right_index];
2460                                                  
2461  ***      0      0                           0               $args{callback}->($dupe, %args) if $args{callback};
2462                                                           }
2463                                                           else {
2464  ***      0                                  0               MKDEBUG && _d($right_name, 'not left-prefix of', $left_name);
2465  ***      0                                  0               next LEFT_KEY;
2466                                                           }
2467                                                        } # RIGHT_KEY
2468                                                     } # LEFT_KEY
2469  ***      0                                  0      MKDEBUG && _d('No more keys');
2470                                                  
2471  ***      0                                  0      @$left_keys  = grep { defined $_; } @$left_keys;
      ***      0                                  0   
2472  ***      0                                  0      @$right_keys = grep { defined $_; } @$right_keys;
      ***      0                                  0   
2473                                                  
2474  ***      0                                  0      return @dupes;
2475                                                  }
2476                                                  
2477                                                  sub remove_clustered_duplicates {
2478  ***      0                    0             0      my ( $self, $primary_key, $keys, %args ) = @_;
2479  ***      0      0                           0      die "I need a primary_key argument" unless $primary_key;
2480  ***      0      0                           0      die "I need a keys argument"        unless $keys;
2481  ***      0                                  0      my $pkcols = $primary_key->{colnames};
2482  ***      0                                  0      my @dupes;
2483                                                  
2484                                                     KEY:
2485  ***      0                                  0      for my $i ( 0 .. @$keys - 1 ) {
2486  ***      0                                  0         my $suffix = $keys->[$i]->{colnames};
2487                                                        SUFFIX:
2488  ***      0                                  0         while ( $suffix =~ s/`[^`]+`,// ) {
2489  ***      0                                  0            my $len = min(length($pkcols), length($suffix));
2490  ***      0      0                           0            if ( substr($suffix, 0, $len) eq substr($pkcols, 0, $len) ) {
2491  ***      0                                  0               my $dupe = {
2492                                                                 key               => $keys->[$i]->{name},
2493                                                                 cols              => $keys->[$i]->{real_cols},
2494                                                                 duplicate_of      => $primary_key->{name},
2495                                                                 duplicate_of_cols => $primary_key->{real_cols},
2496                                                                 reason            => "Key $keys->[$i]->{name} ends with a "
2497                                                                                    . "prefix of the clustered index",
2498                                                              };
2499  ***      0                                  0               push @dupes, $dupe;
2500  ***      0                                  0               delete $keys->[$i];
2501  ***      0      0                           0               $args{callback}->($dupe, %args) if $args{callback};
2502  ***      0                                  0               last SUFFIX;
2503                                                           }
2504                                                        }
2505                                                     }
2506  ***      0                                  0      MKDEBUG && _d('No more keys');
2507                                                  
2508  ***      0                                  0      @$keys = grep { defined $_; } @$keys;
      ***      0                                  0   
2509                                                  
2510  ***      0                                  0      return @dupes;
2511                                                  }
2512                                                  
2513                                                  sub unconstrain_keys {
2514  ***      0                    0             0      my ( $self, $primary_key, $unique_keys ) = @_;
2515  ***      0      0                           0      die "I need a unique_keys argument" unless $unique_keys;
2516  ***      0                                  0      my %unique_cols;
2517  ***      0                                  0      my @unique_sets;
2518  ***      0                                  0      my %unconstrain;
2519  ***      0                                  0      my @unconstrained_keys;
2520                                                  
2521  ***      0                                  0      MKDEBUG && _d('Unconstraining redundantly unique keys');
2522                                                  
2523                                                     UNIQUE_KEY:
2524  ***      0                                  0      foreach my $unique_key ( $primary_key, @$unique_keys ) {
2525  ***      0      0                           0         next unless $unique_key; # primary key may be undefined
2526  ***      0                                  0         my $cols = $unique_key->{cols};
2527  ***      0      0                           0         if ( @$cols == 1 ) {
2528  ***      0                                  0            MKDEBUG && _d($unique_key->{name},'defines unique column:',$cols->[0]);
2529  ***      0      0                           0            if ( !exists $unique_cols{$cols->[0]} ) {
2530  ***      0                                  0               $unique_cols{$cols->[0]}  = $unique_key;
2531  ***      0                                  0               $unique_key->{unique_col} = 1;
2532                                                           }
2533                                                        }
2534                                                        else {
2535  ***      0                                  0            local $LIST_SEPARATOR = '-';
2536  ***      0                                  0            MKDEBUG && _d($unique_key->{name}, 'defines unique set:', @$cols);
2537  ***      0                                  0            push @unique_sets, { cols => $cols, key => $unique_key };
2538                                                        }
2539                                                     }
2540                                                  
2541                                                     UNIQUE_SET:
2542  ***      0                                  0      foreach my $unique_set ( @unique_sets ) {
2543  ***      0                                  0         my $n_unique_cols = 0;
2544  ***      0                                  0         COL:
2545  ***      0                                  0         foreach my $col ( @{$unique_set->{cols}} ) {
2546  ***      0      0                           0            if ( exists $unique_cols{$col} ) {
2547  ***      0                                  0               MKDEBUG && _d('Unique set', $unique_set->{key}->{name},
2548                                                                 'has unique col', $col);
2549  ***      0      0                           0               last COL if ++$n_unique_cols > 1;
2550  ***      0                                  0               $unique_set->{constraining_key} = $unique_cols{$col};
2551                                                           }
2552                                                        }
2553  ***      0      0      0                    0         if ( $n_unique_cols && $unique_set->{key}->{name} ne 'PRIMARY' ) {
2554  ***      0                                  0            MKDEBUG && _d('Will unconstrain unique set',
2555                                                              $unique_set->{key}->{name},
2556                                                              'because it is redundantly constrained by key',
2557                                                              $unique_set->{constraining_key}->{name},
2558                                                              '(',$unique_set->{constraining_key}->{colnames},')');
2559  ***      0                                  0            $unconstrain{$unique_set->{key}->{name}}
2560                                                              = $unique_set->{constraining_key};
2561                                                        }
2562                                                     }
2563                                                  
2564  ***      0                                  0      for my $i ( 0..(scalar @$unique_keys-1) ) {
2565  ***      0      0                           0         if ( exists $unconstrain{$unique_keys->[$i]->{name}} ) {
2566  ***      0                                  0            MKDEBUG && _d('Unconstraining', $unique_keys->[$i]->{name});
2567  ***      0                                  0            $unique_keys->[$i]->{unconstrained} = 1;
2568  ***      0                                  0            $unique_keys->[$i]->{constraining_key}
2569                                                              = $unconstrain{$unique_keys->[$i]->{name}};
2570  ***      0                                  0            push @unconstrained_keys, $unique_keys->[$i];
2571  ***      0                                  0            delete $unique_keys->[$i];
2572                                                        }
2573                                                     }
2574                                                  
2575  ***      0                                  0      MKDEBUG && _d('No more keys');
2576  ***      0                                  0      return @unconstrained_keys;
2577                                                  }
2578                                                  
2579                                                  sub _d {
2580  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2581  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2582  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2583                                                          @_;
2584  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2585                                                  }
2586                                                  
2587                                                  1;
2588                                                  # ###########################################################################
2589                                                  # End DuplicateKeyFinder package
2590                                                  # ###########################################################################
2591                                                  
2592                                                  # ###########################################################################
2593                                                  # Transformers package 3407
2594                                                  # ###########################################################################
2595                                                  
2596                                                  package Transformers;
2597                                                  
2598           1                    1             8   use strict;
               1                                  2   
               1                                  7   
2599           1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                  6   
2600           1                    1             7   use English qw(-no_match_vars);
               1                                  2   
               1                                  5   
2601           1                    1            16   use Time::Local qw(timelocal);
               1                                  3   
               1                                  9   
2602           1                    1             7   use Digest::MD5 qw(md5_hex);
               1                                  2   
               1                                  8   
2603                                                  
2604           1                    1             7   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  4   
               1                                  7   
2605                                                  
2606                                                  require Exporter;
2607                                                  our @ISA         = qw(Exporter);
2608                                                  our %EXPORT_TAGS = ();
2609                                                  our @EXPORT      = ();
2610                                                  our @EXPORT_OK   = qw(
2611                                                     micro_t
2612                                                     percentage_of
2613                                                     secs_to_time
2614                                                     shorten
2615                                                     ts
2616                                                     parse_timestamp
2617                                                     unix_timestamp
2618                                                     make_checksum
2619                                                  );
2620                                                  
2621                                                  sub micro_t {
2622  ***      0                    0             0      my ( $t, %args ) = @_;
2623  ***      0      0                           0      my $p_ms = defined $args{p_ms} ? $args{p_ms} : 0;  # precision for ms vals
2624  ***      0      0                           0      my $p_s  = defined $args{p_s}  ? $args{p_s}  : 0;  # precision for s vals
2625  ***      0                                  0      my $f;
2626                                                  
2627  ***      0      0                           0      $t = 0 if $t < 0;
2628                                                  
2629  ***      0      0                           0      $t = sprintf('%.17f', $t) if $t =~ /e/;
2630                                                  
2631  ***      0                                  0      $t =~ s/\.(\d{1,6})\d*/\.$1/;
2632                                                  
2633  ***      0      0      0                    0      if ($t > 0 && $t <= 0.000999) {
      ***             0      0                        
      ***             0                               
2634  ***      0                                  0         $f = ($t * 1000000) . 'us';
2635                                                     }
2636                                                     elsif ($t >= 0.001000 && $t <= 0.999999) {
2637  ***      0                                  0         $f = sprintf("%.${p_ms}f", $t * 1000);
2638  ***      0                                  0         $f = ($f * 1) . 'ms'; # * 1 to remove insignificant zeros
2639                                                     }
2640                                                     elsif ($t >= 1) {
2641  ***      0                                  0         $f = sprintf("%.${p_s}f", $t);
2642  ***      0                                  0         $f = ($f * 1) . 's'; # * 1 to remove insignificant zeros
2643                                                     }
2644                                                     else {
2645  ***      0                                  0         $f = 0;  # $t should = 0 at this point
2646                                                     }
2647                                                  
2648  ***      0                                  0      return $f;
2649                                                  }
2650                                                  
2651                                                  sub percentage_of {
2652  ***      0                    0             0      my ( $is, $of, %args ) = @_;
2653  ***      0             0                    0      my $p   = $args{p} || 0; # float precision
2654  ***      0      0                           0      my $fmt = $p ? "%.${p}f" : "%d";
2655  ***      0             0                    0      return sprintf $fmt, ($is * 100) / ($of ||= 1);
2656                                                  }
2657                                                  
2658                                                  sub secs_to_time {
2659  ***      0                    0             0      my ( $secs, $fmt ) = @_;
2660  ***      0             0                    0      $secs ||= 0;
2661  ***      0      0                           0      return '00:00' unless $secs;
2662                                                  
2663  ***      0      0      0                    0      $fmt ||= $secs >= 86_400 ? 'd'
      ***             0                               
2664                                                            : $secs >= 3_600  ? 'h'
2665                                                            :                   'm';
2666                                                  
2667                                                     return
2668  ***      0      0                           0         $fmt eq 'd' ? sprintf(
      ***             0                               
2669                                                           "%d+%02d:%02d:%02d",
2670                                                           int($secs / 86_400),
2671                                                           int(($secs % 86_400) / 3_600),
2672                                                           int(($secs % 3_600) / 60),
2673                                                           $secs % 60)
2674                                                        : $fmt eq 'h' ? sprintf(
2675                                                           "%02d:%02d:%02d",
2676                                                           int(($secs % 86_400) / 3_600),
2677                                                           int(($secs % 3_600) / 60),
2678                                                           $secs % 60)
2679                                                        : sprintf(
2680                                                           "%02d:%02d",
2681                                                           int(($secs % 3_600) / 60),
2682                                                           $secs % 60);
2683                                                  }
2684                                                  
2685                                                  sub shorten {
2686  ***      0                    0             0      my ( $num, %args ) = @_;
2687  ***      0      0                           0      my $p = defined $args{p} ? $args{p} : 2;     # float precision
2688  ***      0      0                           0      my $d = defined $args{d} ? $args{d} : 1_024; # divisor
2689  ***      0                                  0      my $n = 0;
2690  ***      0                                  0      my @units = ('', qw(k M G T P E Z Y));
2691  ***      0             0                    0      while ( $num >= $d && $n < @units - 1 ) {
2692  ***      0                                  0         $num /= $d;
2693  ***      0                                  0         ++$n;
2694                                                     }
2695  ***      0      0      0                    0      return sprintf(
2696                                                        $num =~ m/\./ || $n
2697                                                           ? "%.${p}f%s"
2698                                                           : '%d',
2699                                                        $num, $units[$n]);
2700                                                  }
2701                                                  
2702                                                  sub ts {
2703  ***      0                    0             0      my ( $time ) = @_;
2704  ***      0                                  0      my ( $sec, $min, $hour, $mday, $mon, $year )
2705                                                        = localtime($time);
2706  ***      0                                  0      $mon  += 1;
2707  ***      0                                  0      $year += 1900;
2708  ***      0                                  0      return sprintf("%d-%02d-%02dT%02d:%02d:%02d",
2709                                                        $year, $mon, $mday, $hour, $min, $sec);
2710                                                  }
2711                                                  
2712                                                  sub parse_timestamp {
2713  ***      0                    0             0      my ( $val ) = @_;
2714  ***      0      0                           0      if ( my($y, $m, $d, $h, $i, $s, $f)
2715                                                           = $val =~ m/^(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)(\.\d+)?$/ )
2716                                                     {
2717  ***      0      0                           0         return sprintf "%d-%02d-%02d %02d:%02d:"
      ***             0                               
2718                                                                       . (defined $f ? '%02.6f' : '%02d'),
2719                                                                       $y + 2000, $m, $d, $h, $i, (defined $f ? $s + $f : $s);
2720                                                     }
2721  ***      0                                  0      return $val;
2722                                                  }
2723                                                  
2724                                                  sub unix_timestamp {
2725  ***      0                    0             0      my ( $val ) = @_;
2726  ***      0      0                           0      if ( my($y, $m, $d, $h, $i, $s)
2727                                                           = $val =~ m/^(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)$/ )
2728                                                     {
2729  ***      0                                  0         return timelocal($s, $i, $h, $d, $m - 1, $y);
2730                                                     }
2731  ***      0                                  0      return $val;
2732                                                  }
2733                                                  
2734                                                  sub make_checksum {
2735  ***      0                    0             0      my ( $val ) = @_;
2736  ***      0                                  0      my $checksum = uc substr(md5_hex($val), -16);
2737  ***      0                                  0      MKDEBUG && _d($checksum, 'checksum for', $val);
2738  ***      0                                  0      return $checksum;
2739                                                  }
2740                                                  
2741                                                  sub _d {
2742  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2743  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2744  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2745                                                          @_;
2746  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2747                                                  }
2748                                                  
2749                                                  1;
2750                                                  
2751                                                  # ###########################################################################
2752                                                  # End Transformers package
2753                                                  # ###########################################################################
2754                                                  
2755                                                  # #############################################################################
2756                                                  # This is a combination of modules and programs in one -- a runnable module.
2757                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
2758                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
2759                                                  #
2760                                                  # Check at the end of this package for the call to main() which actually runs
2761                                                  # the program.
2762                                                  # #############################################################################
2763                                                  package mk_duplicate_key_checker;
2764                                                  
2765           1                    1             8   use English qw(-no_match_vars);
               1                                  3   
               1                                  6   
2766           1                    1             7   use Getopt::Long;
               1                                  2   
               1                                  7   
2767           1                    1             7   use List::Util qw(max);
               1                                  2   
               1                                  5   
2768                                                  
2769                                                  Transformers->import(qw(shorten));
2770                                                  
2771           1                    1             7   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                  8   
2772                                                  
2773                                                  $OUTPUT_AUTOFLUSH = 1;
2774                                                  
2775                                                  my $max_width = 74;
2776                                                  my $hdr_width = $max_width - 2;  # for '# '
2777                                                  my $hdr_fmt   = "# %-${hdr_width}s\n";
2778                                                  
2779                                                  my %summary = ( 'Total Keys' => 0 );
2780                                                  my %seen_tbl;
2781                                                  
2782                                                  my $q  = new Quoter();
2783                                                  my $tp = new TableParser();
2784                                                  
2785                                                  sub main {
2786  ***      0                    0             0      @ARGV = @_;  # set global ARGV for this package
2787                                                  
2788                                                     # #######################################################################
2789                                                     # Get configuration information and parse command line options.
2790                                                     # #######################################################################
2791  ***      0                                  0      my $o  = new OptionParser(
2792                                                        description  => q{examines MySQL tables for duplicate or redundant }
2793                                                                      . q{indexes and foreign keys.  Connection options }
2794                                                                      . q{are read from MySQL option files.},
2795                                                     );
2796  ***      0                                  0      $o->get_specs();
2797  ***      0                                  0      $o->get_opts();
2798  ***      0                                  0      $o->usage_or_errors();
2799                                                  
2800                                                     # #######################################################################
2801                                                     # Get ready to do the main work.
2802                                                     # #######################################################################
2803  ***      0      0                           0      my $get_keys = $o->get('key-types') =~ m/k/ ? 1 : 0;
2804  ***      0      0                           0      my $get_fks  = $o->get('key-types') =~ m/f/ ? 1 : 0;
2805  ***      0                                  0      my %opts     = $o->opts();
2806                                                  
2807                                                     # Connect to the database
2808  ***      0      0      0                    0      if ( $o->got('ask-pass') && !$o->got('password') ) {
2809  ***      0                                  0         $o->set('password', OptionParser::prompt_noecho("Enter password: "));
2810                                                     }
2811  ***      0                                  0      my $dp = new DSNParser;
2812  ***      0                                  0      $dp->prop('setvars', $o->get('set-vars'));
2813  ***      0                                  0      my $dbh = $dp->get_dbh($dp->get_cxn_params({$o->opt_values()}), {AutoCommit=>1});
2814                                                  
2815  ***      0                                  0      my $vp = new VersionParser();
2816  ***      0                                  0      my $version = $vp->parse($dbh->selectrow_array('SELECT VERSION()'));
2817                                                  
2818  ***      0      0                           0      my $ks = $o->get('summary') ? new KeySize(q=>$q) : undef;
2819  ***      0                                  0      my $dk = new DuplicateKeyFinder();
2820  ***      0                                  0      my $du = new MySQLDump();
2821                                                  
2822  ***      0                                  0      my %tp_opts = (
2823                                                        ignore_type  => $o->get('all-structs'),
2824                                                        ignore_order => $o->get('ignore-order'),
2825                                                        clustered    => $o->get('clustered'),
2826                                                     );
2827                                                  
2828  ***      0                                  0      my $finder = new MySQLFind(
2829                                                        quoter    => $q,
2830                                                        useddl    => 1,
2831                                                        parser    => $tp,
2832                                                        dumper    => $du,
2833                                                        databases => {
2834                                                           permit => $o->get('databases'),
2835                                                           reject => $o->get('ignore-databases'),
2836                                                        },
2837                                                        tables => {
2838                                                           permit => $o->get('tables'),
2839                                                           reject => $o->get('ignore-tables'),
2840                                                        },
2841                                                        engines => {
2842                                                           views  => 0,
2843                                                           permit => $o->get('engines'),
2844                                                           reject => $o->get('ignore-engines'),
2845                                                        },
2846                                                     );
2847                                                  
2848                                                     # #######################################################################
2849                                                     # Do the main work.
2850                                                     # #######################################################################
2851                                                  
2852                                                     DATABASE:
2853  ***      0                                  0      foreach my $database ( $finder->find_databases($dbh) ) {
2854                                                        TABLE:
2855  ***      0                                  0         foreach my $table ( $finder->find_tables($dbh, database => $database) ) {
2856  ***      0                                  0            my $ddl      = $du->get_create_table($dbh, $q, $database, $table)->[1];
2857  ***      0             0                    0            my $engine   = $tp->get_engine($ddl) || next TABLE;
2858  ***      0                                  0            my $tbl_info = {
2859                                                              db     => $database,
2860                                                              tbl    => $table,
2861                                                              engine => $engine,
2862                                                              ddl    => $ddl,
2863                                                           };
2864                                                  
2865  ***      0      0                           0            my $keys = $tp->get_keys($ddl, {version => $version })  if $get_keys;
2866  ***      0      0                           0            my $fks  = $tp->get_fks($ddl,  {database => $database}) if $get_fks;
2867                                                  
2868  ***      0      0      0                    0            next TABLE unless %$keys || %$fks;
2869                                                  
2870  ***      0      0                           0            if ( $o->got('verbose') ) {
2871  ***      0      0                           0               print_all_keys($keys, $tbl_info) if $keys;
2872  ***      0      0                           0               print_all_keys($fks,  $tbl_info) if $fks;
2873                                                           }
2874                                                           else {
2875  ***      0      0                           0               $dk->get_duplicate_keys(
2876                                                                 $keys,
2877                                                                 tbl_info => $tbl_info,
2878                                                                 callback => \&print_duplicate_key,
2879                                                                 %tp_opts,
2880                                                                 # get_duplicate_keys() ignores these args but passes them
2881                                                                 # to the callback:
2882                                                                    dbh   => $dbh,
2883                                                                    is_fk => 0,
2884                                                                    o     => $o,
2885                                                                    ks    => $ks,
2886                                                              ) if $keys;
2887                                                  
2888  ***      0      0                           0               $dk->get_duplicate_fks(
2889                                                                 $fks,
2890                                                                 tbl_info => $tbl_info,
2891                                                                 callback => \&print_duplicate_key,
2892                                                                 %tp_opts,
2893                                                                 # get_duplicate_keys() ignores these args but passes them
2894                                                                 # to the callback:
2895                                                                    dbh   => $dbh,
2896                                                                    is_fk => 1,
2897                                                                    o     => $o,
2898                                                                    ks    => $ks,
2899                                                              ) if $fks;
2900                                                           }
2901                                                  
2902                                                           # Always count Total Keys so print_key_summary won't die
2903                                                           # because %summary is empty.
2904  ***      0                                  0            $summary{'Total Keys'} += (scalar keys %$keys) + (scalar keys %$fks)
2905                                                        }
2906                                                     }
2907                                                  
2908  ***      0      0                           0      print_key_summary(%summary) if $o->get('summary');
2909                                                  
2910  ***      0                                  0      return 0;
2911                                                  }
2912                                                  
2913                                                  # ##########################################################################
2914                                                  # Subroutines
2915                                                  # ##########################################################################
2916                                                  
2917                                                  sub print_all_keys {
2918  ***      0                    0             0      my ( $keys, $tbl_info ) = @_;
2919  ***      0      0                           0      return unless $keys;
2920  ***      0                                  0      my $db  = $tbl_info->{db};
2921  ***      0                                  0      my $tbl = $tbl_info->{tbl};
2922  ***      0      0                           0      if ( !$seen_tbl{"$db$tbl"}++ ) {
2923  ***      0                                  0         printf $hdr_fmt, ('#' x $hdr_width);
2924  ***      0                                  0         printf $hdr_fmt, "$db.$tbl";
2925  ***      0                                  0         printf $hdr_fmt, ('#' x $hdr_width);
2926                                                     }
2927  ***      0                                  0      foreach my $key ( values %$keys ) {
2928  ***      0                                  0         print "\n# $key->{name} ($key->{colnames})";
2929                                                     }
2930  ***      0                                  0      print "\n";
2931  ***      0                                  0      return;
2932                                                  }
2933                                                  
2934                                                  sub print_duplicate_key {
2935  ***      0                    0             0      my ( $dupe, %args ) = @_;
2936  ***      0      0                           0      return unless $dupe;
2937  ***      0                                  0      foreach my $arg ( qw(tbl_info dbh is_fk o ks) ) {
2938  ***      0      0                           0         die "I need a $arg argument" unless exists $args{$arg};
2939                                                     }
2940  ***      0                                  0      my $db     = $args{tbl_info}->{db};
2941  ***      0                                  0      my $tbl    = $args{tbl_info}->{tbl};
2942  ***      0                                  0      my $dbh    = $args{dbh};
2943  ***      0                                  0      my $o      = $args{o};
2944  ***      0                                  0      my $ks     = $args{ks};
2945  ***      0                                  0      my $struct = $tp->parse($args{tbl_info}->{ddl});
2946                                                  
2947  ***      0      0                           0      if ( !$seen_tbl{"$db$tbl"}++ ) {
2948  ***      0                                  0         printf $hdr_fmt, ('#' x $hdr_width);
2949  ***      0                                  0         printf $hdr_fmt, "$db.$tbl";
2950  ***      0                                  0         printf $hdr_fmt, ('#' x $hdr_width);
2951  ***      0                                  0         print "\n";
2952                                                     }
2953                                                  
2954  ***      0                                  0      $dupe->{reason} =~ s/\n/\n# /g;
2955  ***      0                                  0      print "# $dupe->{reason}\n";
2956                                                  
2957  ***      0                                  0      print "# Column types:\n";
2958  ***      0                                  0      my %seen_col;
2959  ***      0      0                           0      my @cols = map { s/`//g; $_; }
      ***      0                                  0   
      ***      0                                  0   
2960  ***      0                                  0                 grep { $_ if !$seen_col{$_}++; }
2961                                                                split(',', "$dupe->{cols},$dupe->{duplicate_of_cols}");
2962  ***      0                                  0      foreach my $col ( @cols ) {
2963  ***      0                                  0         MKDEBUG && _d('col', $col);
2964  ***      0                                  0         print "#\t" . $struct->{defs}->{lc $col} . "\n";
2965                                                     }
2966                                                  
2967  ***      0      0                           0      print "# To remove this duplicate key, execute:\n"
2968                                                        . 'ALTER TABLE '.$q->quote($db, $tbl)." DROP KEY `$dupe->{key}`;\n"
2969                                                           if $o->get('sql');
2970  ***      0                                  0      print "\n";
2971                                                  
2972  ***      0      0                           0      if ( $o->get('summary') ) {
2973  ***      0                                  0         $summary{'Total Duplicate Keys'} += 1;
2974  ***      0                                  0         my ($size, $chosen_key) = $ks->get_key_size(
2975                                                           name        => $dupe->{key},
2976                                                           cols        => [ split(',', $dupe->{cols}) ],
2977                                                           tbl_name    => $q->quote($db, $tbl),
2978                                                           tbl_struct  => $struct,
2979                                                           dbh         => $dbh,
2980                                                        );
2981  ***      0      0                           0         if ( $args{is_fk} ) {
2982                                                           # Foreign keys have no size because they're just constraints.
2983  ***      0                                  0            print "# MySQL uses the $chosen_key key for this "
2984                                                              . "foreign key constraint\n\n";
2985                                                        }
2986                                                        else {
2987  ***      0             0                    0            $size ||= 0;
2988                                                  
2989                                                           # Create Size Duplicate Keys summary even if there's no valid keys.
2990  ***      0                                  0            $summary{'Size Duplicate Keys'} += $size;
2991                                                  
2992  ***      0      0                           0            if ( $size ) {
2993  ***      0      0      0                    0               if ( $chosen_key && $chosen_key ne $dupe->{key} ) {
2994                                                                 # This shouldn't happen. But in case it does, we should know.
2995  ***      0                                  0                  print "# MySQL chose the $chosen_key key despite FORCE INDEX\n\n";
2996                                                              }
2997                                                           }
2998                                                        }
2999                                                     }
3000  ***      0                                  0      return;
3001                                                  }
3002                                                  
3003                                                  # TODO: would be nice to shorten/format some of these values.
3004                                                  sub print_key_summary {
3005  ***      0                    0             0      my ( %summary ) = @_;
3006  ***      0                                  0      printf $hdr_fmt, ('#' x $hdr_width);
3007  ***      0                                  0      printf $hdr_fmt, 'Summary of keys';
3008  ***      0                                  0      printf $hdr_fmt, ('#' x $hdr_width);
3009  ***      0                                  0      print "\n";
3010  ***      0                                  0      my $max_item = max(map { length($_) } keys %summary);
      ***      0                                  0   
3011  ***      0                                  0      my $line_fmt = "# %-${max_item}s  %-s\n";
3012  ***      0                                  0      foreach my $item ( sort keys %summary ) {
3013  ***      0                                  0         printf $line_fmt, $item, $summary{$item};
3014                                                     }
3015  ***      0                                  0      return;
3016                                                  }
3017                                                  
3018                                                  sub _d {
3019           1                    1             8      my ($package, undef, $line) = caller 0;
3020  ***      1     50                           8      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
               1                                  5   
               1                                 40   
3021           1                                  6           map { defined $_ ? $_ : 'undef' }
3022                                                          @_;
3023           1                                  3      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3024                                                  }
3025                                                  
3026                                                  # ############################################################################
3027                                                  # Run the program.
3028                                                  # ############################################################################
3029                                                  if ( !caller ) { exit main(@ARGV); }
3030                                                  
3031                                                  1; # Because this is a module as well as a script.
3032                                                  
3033                                                  # ############################################################################
3034                                                  # Documentation
3035                                                  # ############################################################################
3036                                                  
3037                                                  =pod
3038                                                  
3039                                                  =head1 NAME
3040                                                  
3041                                                  mk-duplicate-key-checker - Find duplicate keys and foreign keys on MySQL tables.
3042                                                  
3043                                                  =head1 SYNOPSIS
3044                                                  
3045                                                     mk-duplicate-key-checker --host host1
3046                                                  
3047                                                  =head1 DESCRIPTION
3048                                                  
3049                                                  This program examines the output of SHOW CREATE TABLE on MySQL tables, and if
3050                                                  it finds indexes that cover the same columns as another index in the same
3051                                                  order, or cover an exact leftmost prefix of another index, it prints out
3052                                                  the suspicious indexes.  By default, indexes must be of the same type, so a
3053                                                  BTREE index is not a duplicate of a FULLTEXT index, even if they have the same
3054                                                  colums.  You can override this.
3055                                                  
3056                                                  It also looks for duplicate foreign keys.  A duplicate foreign key covers the
3057                                                  same columns as another in the same table, and references the same parent
3058                                                  table.
3059                                                  
3060                                                  =head1 DOWNLOADING
3061                                                  
3062                                                  You can download Maatkit from Google Code at
3063                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
3064                                                  easily with a command like the following:
3065                                                  
3066                                                     wget http://www.maatkit.org/get/toolname
3067                                                     or
3068                                                     wget http://www.maatkit.org/trunk/toolname
3069                                                  
3070                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
3071                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
3072                                                  needed.  The first URL gets the latest released version of the tool, and the
3073                                                  second gets the latest trunk code from Subversion.
3074                                                  
3075                                                  =head1 OPTIONS
3076                                                  
3077                                                  =over
3078                                                  
3079                                                  =item --all-structs
3080                                                  
3081                                                  Compare indexes with different structs (BTREE, HASH, etc).
3082                                                  
3083                                                  By default this is disabled, because a BTREE index that covers the same columns
3084                                                  as a FULLTEXT index is not really a duplicate, for example.
3085                                                  
3086                                                  =item --ask-pass
3087                                                  
3088                                                  Prompt for a password when connecting to MySQL.
3089                                                  
3090                                                  =item --charset
3091                                                  
3092                                                  short form: -A; type: string
3093                                                  
3094                                                  Default character set.  If the value is utf8, sets Perl's binmode on
3095                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and runs SET
3096                                                  NAMES UTF8 after connecting to MySQL.  Any other value sets binmode on STDOUT
3097                                                  without the utf8 layer, and runs SET NAMES after connecting to MySQL.
3098                                                  
3099                                                  =item --[no]clustered
3100                                                  
3101                                                  default: yes
3102                                                  
3103                                                  PK columns appended to secondary key is duplicate.
3104                                                  
3105                                                  Detects when a suffix of a secondary key is a leftmost prefix of the primary
3106                                                  key, and treats it as a duplicate key.  Only detects this condition on storage
3107                                                  engines whose primary keys are clustered (currently InnoDB and solidDB).
3108                                                  
3109                                                  Clustered storage engines append the primary key columns to the leaf nodes of
3110                                                  all secondary keys anyway, so you might consider it redundant to have them
3111                                                  appear in the internal nodes as well.  Of course, you may also want them in the
3112                                                  internal nodes, because just having them at the leaf nodes won't help for some
3113                                                  queries.  It does help for covering index queries, however.
3114                                                  
3115                                                  Here's an example of a key that is considered redundant with this option:
3116                                                  
3117                                                    PRIMARY KEY  (`a`)
3118                                                    KEY `b` (`b`,`a`)
3119                                                  
3120                                                  The use of such indexes is rather subtle.  For example, suppose you have the
3121                                                  following query:
3122                                                  
3123                                                    SELECT ... WHERE b=1 ORDER BY a;
3124                                                  
3125                                                  This query will do a filesort if we remove the index on C<b,a>.  But if we
3126                                                  shorten the index on C<b,a> to just C<a> and also remove the ORDER BY, the query
3127                                                  should return the same results.
3128                                                  
3129                                                  Currently, the tool suggests removing these indexes, but it should suggest
3130                                                  shortening them instead.  This is filed as a feature request (issue 295).
3131                                                  
3132                                                  =item --config
3133                                                  
3134                                                  type: Array
3135                                                  
3136                                                  Read this comma-separated list of config files; if specified, this must be the
3137                                                  first option on the command line.
3138                                                  
3139                                                  =item --databases
3140                                                  
3141                                                  short form: -d; type: hash
3142                                                  
3143                                                  Check only this comma-separated list of databases.
3144                                                  
3145                                                  =item --defaults-file
3146                                                  
3147                                                  short form: -F; type: string
3148                                                  
3149                                                  Only read mysql options from the given file.  You must give an absolute pathname.
3150                                                  
3151                                                  =item --engines
3152                                                  
3153                                                  short form: -e; type: hash
3154                                                  
3155                                                  Check only tables whose storage engine is in this comma-separated list.
3156                                                  
3157                                                  =item --help
3158                                                  
3159                                                  Show help and exit.
3160                                                  
3161                                                  =item --host
3162                                                  
3163                                                  short form: -h; type: string
3164                                                  
3165                                                  Connect to host.
3166                                                  
3167                                                  =item --ignore-databases
3168                                                  
3169                                                  type: Hash
3170                                                  
3171                                                  Ignore this comma-separated list of databases.
3172                                                  
3173                                                  =item --ignore-engines
3174                                                  
3175                                                  type: Hash
3176                                                  
3177                                                  Ignore this comma-separated list of storage engines.
3178                                                  
3179                                                  =item --ignore-order
3180                                                  
3181                                                  Ignore index order so KEY(a,b) duplicates KEY(b,a).
3182                                                  
3183                                                  =item --ignore-tables
3184                                                  
3185                                                  type: Hash
3186                                                  
3187                                                  Ignore this comma-separated list of tables.  Table names may be qualified with
3188                                                  the database name.
3189                                                  
3190                                                  =item --key-types
3191                                                  
3192                                                  type: string; default: fk
3193                                                  
3194                                                  Check for duplicate f=foreign keys, k=keys or fk=both.
3195                                                  
3196                                                  =item --password
3197                                                  
3198                                                  short form: -p; type: string
3199                                                  
3200                                                  Password to use when connecting.
3201                                                  
3202                                                  =item --port
3203                                                  
3204                                                  short form: -P; type: int
3205                                                  
3206                                                  Port number to use for connection.
3207                                                  
3208                                                  =item --set-vars
3209                                                  
3210                                                  type: string; default: wait_timeout=10000
3211                                                  
3212                                                  Set these MySQL variables.  Immediately after connecting to MySQL, this string
3213                                                  will be appended to SET and executed.
3214                                                  
3215                                                  =item --socket
3216                                                  
3217                                                  short form: -S; type: string
3218                                                  
3219                                                  Socket file to use for connection.
3220                                                  
3221                                                  =item --[no]sql
3222                                                  
3223                                                  default: yes
3224                                                  
3225                                                  Print DROP KEY statement for each duplicate key.  By default an ALTER TABLE
3226                                                  DROP KEY statement is printed below each duplicate key so that, if you want to
3227                                                  remove the duplicate key, you can copy-paste the statement into MySQL.
3228                                                  
3229                                                  To disable printing these statements, specify --nosql.
3230                                                  
3231                                                  =item --[no]summary
3232                                                  
3233                                                  default: yes
3234                                                  
3235                                                  Print summary of indexes at end of output.
3236                                                  
3237                                                  =item --tables
3238                                                  
3239                                                  short form: -t; type: hash
3240                                                  
3241                                                  Check only this comma-separated list of tables.
3242                                                  
3243                                                  Table names may be qualified with the database name.
3244                                                  
3245                                                  =item --user
3246                                                  
3247                                                  short form: -u; type: string
3248                                                  
3249                                                  User for login if not current user.
3250                                                  
3251                                                  =item --verbose
3252                                                  
3253                                                  short form: -v
3254                                                  
3255                                                  Output all keys and/or foreign keys found, not just redundant ones.
3256                                                  
3257                                                  =item --version
3258                                                  
3259                                                  Show version and exit.
3260                                                  
3261                                                  =back
3262                                                  
3263                                                  =head1 ENVIRONMENT
3264                                                  
3265                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
3266                                                  the Maatkit tools:
3267                                                  
3268                                                     MKDEBUG=1 mk-....
3269                                                  
3270                                                  =head1 SYSTEM REQUIREMENTS
3271                                                  
3272                                                  You need the following Perl modules: DBI and DBD::mysql.
3273                                                  
3274                                                  =head1 BUGS
3275                                                  
3276                                                  Please use Google Code Issues and Groups to report bugs or request support:
3277                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
3278                                                  discuss Maatkit.
3279                                                  
3280                                                  Please include the complete command-line used to reproduce the problem you are
3281                                                  seeing, the version of all MySQL servers involved, the complete output of the
3282                                                  tool when run with L<"--version">, and if possible, debugging output produced by
3283                                                  running with the C<MKDEBUG=1> environment variable.
3284                                                  
3285                                                  =head1 LICENSE
3286                                                  
3287                                                  This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
3288                                                  Feedback and improvements are welcome.
3289                                                  
3290                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
3291                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
3292                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
3293                                                  
3294                                                  This program is free software; you can redistribute it and/or modify it under
3295                                                  the terms of the GNU General Public License as published by the Free Software
3296                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
3297                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
3298                                                  licenses.
3299                                                  
3300                                                  You should have received a copy of the GNU General Public License along with
3301                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
3302                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
3303                                                  
3304                                                  =head1 AUTHOR
3305                                                  
3306                                                  Baron Schwartz, Daniel Nichter
3307                                                  
3308                                                  =head1 VERSION
3309                                                  
3310                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 3924 $.
3311                                                  
3312                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
56    ***      0      0      0   if (not $$self{$dbh})
60    ***      0      0      0   $$self{$dbh} ge $self->parse($target) ? :
67    ***      0      0      0   defined $_ ? :
108   ***      0      0      0   if (defined $_) { }
110   ***      0      0      0   $_ eq '' || $_ =~ /^0|\D/ ? :
123   ***      0      0      0   if (not $tbl)
156   ***      0      0      0   if (ref $ddl eq 'ARRAY')
157   ***      0      0      0   if (lc $$ddl[0] eq 'table') { }
167   ***      0      0      0   if (not $ddl =~ /CREATE (?:TEMPORARY )?TABLE `/)
188   ***      0      0      0   unless $type
190   ***      0      0      0   if ($type =~ /(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/)
194   ***      0      0      0   if (not $def =~ /NOT NULL/)
198   ***      0      0      0   $def =~ /AUTO_INCREMENT/i ? :
227   ***      0      0      0   unless ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
241   ***      0      0      0   if ($index)
244   ***      0      0      0   if (not $best)
245   ***      0      0      0   if ($index) { }
258   ***      0      0      0   unless $where
264   ***      0      0      0   if ($$expl{'possible_keys'}) { }
268   ***      0      0      0   if ($$expl{'key'})
294   ***      0      0      0   if ($can_insert) { }
322   ***      0      0      0   if $key =~ /FOREIGN/
326   ***      0      0      0   if (not $engine =~ /MEMORY|HEAP/)
333   ***      0      0      0   if ($$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i)
340   ***      0      0      0   $key =~ /PRIMARY|UNIQUE/ ? :
378   ***      0      0      0   if (not $parent =~ /\./ and $$opts{'database'})
403   ***      0      0      0   defined $_ ? :
453   ***      0      0      0   unless defined $args{'cache'}
461   ***      0      0      0   if ($what eq 'table') { }
      ***      0      0      0   elsif ($what eq 'triggers') { }
      ***      0      0      0   elsif ($what eq 'view') { }
463   ***      0      0      0   if ($$ddl[0] eq 'table') { }
477   ***      0      0      0   if ($trgs and @$trgs) { }
480   ***      0      0      0   if ($$trg{'sql_mode'})
484   ***      0      0      0   if ($$trg{'definer'})
516   ***      0      0      0   if (not $new)
523   ***      0      0      0   if ($curr and $new and $curr eq $new)
535   ***      0      0      0   if (not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl})
553   ***      0      0      0   if ($key) { }
569   ***      0      0      0   if (not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl})
599   ***      0      0      0   if (not $$self{'cache'} or not $$self{'triggers'}{$db})
612   ***      0      0      0   if ($sth->rows)
625   ***      0      0      0   if ($tbl)
633   ***      0      0      0   if (not $$self{'cache'} or not $$self{'databases'} or $like)
636   ***      0      0      0   if ($like)
644   ***      0      0      0   unless $like
652   ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_status'}{$db} or $like)
655   ***      0      0      0   if ($like)
670   ***      0      0      0   unless $like
678   ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_list'}{$db} or $like)
681   ***      0      0      0   if ($like)
689   ***      0      0      0   ($$_[1] || '') eq 'VIEW' ? :
696   ***      0      0      0   unless $like
704   ***      0      0      0   defined $_ ? :
735   ***      0      0      0   unless $args{$arg}
737   ***      0      0      0   if $args{'dbh'}
739   ***      0      0      0   $$self{'engines'}{'permit'} || $$self{'engines'}{'reject'} || $$self{'engines'}{'regexp'} ? :
743   ***      0      0      0   if $$self{'need_engine'} and not defined $args{'parser'}
746   ***      0      0      0   unless defined $$self{'engines'}{'views'}
747   ***      0      0      0   unless defined $$self{'tables'}{'status'}
748   ***      0      0      0   if ($args{'useddl'})
756   ***      0      0      0   if $$self{'timestamp'}{$dbh}{'now'}
781   ***      0      0      0   if ($$self{'need_engine'})
783   ***      0      0      0   if $$tbl{'engine'}
816   ***      0      0      0   if (not $new)
823   ***      0      0      0   if ($curr and $new and $curr eq $new)
835   ***      0      0      0   unless $args{'database'}
840   ***      0      0      0   if (scalar @{$$self{'tables'}{'status'};}) { }
856   ***      0      0      0   unless $$self{'engines'}{'views'}
877   ***      0      0      0   unless defined $val
878   ***      0      0      0   if ($thing eq 'tables') { }
880   ***      0      0      0   if !$reject || !$$reject{$val} && !$$reject{$tbl} and !$permit || $$permit{$val} || $$permit{$tbl}
885   ***      0      0      0   if !$reject || !$$reject{$val} and !$permit || $$permit{$val}
895   ***      0      0      0   if (not defined $$table{$prop})
900   ***      0      0      0   unless defined $num
915   ***      0      0      0   defined $_ ? :
998   ***     50      0      4   if (@_ > 2)
1007  ***     50      0      1   if (not $dsn)
1020  ***     50      2      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
      ***      0      0      0   elsif ($prop_autokey) { }
1036  ***     50      0      8   if (not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'})
1042         100      6      2   if (not defined $final_props{$key})
1049  ***     50      0      2   unless exists $opts{$key}
1052  ***     50      0      1   if (my $required = $self->prop('required'))
1054  ***      0      0      0   unless $final_props{$key}
1063  ***      0      0      0   unless ref $o eq 'OptionParser'
1066  ***      0      0      0   if $o->has($_)
1076  ***      0      0      0   unless ref $dsn
1077  ***      0      0      0   $_ eq 'p' ? :
1078  ***      0      0      0   if defined $$dsn{$_}
1091  ***      0      0      0   $opts{$key}{'copy'} ? :
1096  ***      0      0      0   if (my $key = $self->prop('autokey'))
1107  ***     50      0      1   if ($driver eq 'Pg') { }
1139  ***     50      0      1   $cxn_string =~ /charset=utf8/ ? :
1156  ***     50      1      0   if ($cxn_string =~ /mysql/i)
1164  ***     50      0      1   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
1169  ***      0      0      0   if ($charset eq 'utf8') { }
1170  ***      0      0      0   unless binmode STDOUT, ':utf8'
1174  ***      0      0      0   unless binmode STDOUT
1178  ***     50      0      1   if ($self->prop('setvars'))
1185  ***     50      0      1   if (not $dbh and $EVAL_ERROR)
1187  ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/)
1191  ***      0      0      0   if (not $tries)
1213  ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
1230  ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
1240  ***      0      0      0   unless $dsn_1
1241  ***      0      0      0   unless $dsn_2
1245  ***      0      0      0   if ($args{'overwrite'}) { }
1246  ***      0      0      0   defined $$dsn_1{$key} ? :
1249  ***      0      0      0   defined $$dsn_2{$key} ? :
1258  ***      0      0      0   defined $_ ? :
1289  ***      0      0      0   unless $args{$arg}
1294  ***      0      0      0   exists $args{'strict'} ? :
1337  ***      0      0      0   unless open my $fh, '<', $file
1357  ***      0      0      0   unless $para =~ /^=head1 OPTIONS/
1362  ***      0      0      0   if $para =~ /^=over/
1370  ***      0      0      0   unless $para
1373  ***      0      0      0   if (my($option) = $para =~ /^=item --(.*)/)
1380  ***      0      0      0   if ($para =~ /: /) { }
1383  ***      0      0      0   if ($attribs{'short form'})
1399  ***      0      0      0   if $para =~ /^=item/
1401  ***      0      0      0   if (my($base_option) = $option =~ /^\[no\](.*)/)
1406  ***      0      0      0   $attribs{'short form'} ? :
      ***      0      0      0   $attribs{'negatable'} ? :
      ***      0      0      0   $attribs{'cumulative'} ? :
      ***      0      0      0   $attribs{'type'} ? :
      ***      0      0      0   $attribs{'default'} ? :
      ***      0      0      0   $attribs{'group'} ? :
1418  ***      0      0      0   unless $para
1421  ***      0      0      0   if ($para =~ /^=head1/)
1425  ***      0      0      0   if $para =~ /^=item --/
1429  ***      0      0      0   unless @specs
1440  ***      0      0      0   if (ref $opt) { }
1445  ***      0      0      0   if (not $long)
1450  ***      0      0      0   if exists $$self{'opts'}{$long}
1453  ***      0      0      0   if (length $long == 1)
1458  ***      0      0      0   if ($short) { }
1459  ***      0      0      0   if exists $$self{'short_opts'}{$short}
1468  ***      0      0      0   $$opt{'spec'} =~ /!/ ? :
1469  ***      0      0      0   $$opt{'spec'} =~ /\+/ ? :
1470  ***      0      0      0   $$opt{'desc'} =~ /required/ ? :
1482  ***      0      0      0   if ($type and $type eq 'd' and not $$self{'dp'})
1487  ***      0      0      0   if $type and $type =~ /[HhAadzm]/
1489  ***      0      0      0   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
1490  ***      0      0      0   if ($$opt{'is_negatable'})
1491  ***      0      0      0   $def eq 'no' ? :
      ***      0      0      0   $def eq 'yes' ? :
1495  ***      0      0      0   defined $def ? :
1499  ***      0      0      0   if ($long eq 'config')
1503  ***      0      0      0   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
1516  ***      0      0      0   if ($opt =~ /mutually exclusive|one and only one/)
1521  ***      0      0      0   if ($opt =~ /at least one|one and only one/)
1526  ***      0      0      0   if ($opt =~ /default to/)
1531  ***      0      0      0   if ($opt =~ /restricted to option groups/)
1541  ***      0      0      0   unless $rule_ok
1558  ***      0      0      0   unless exists $$self{'opts'}{$long}
1574  ***      0      0      0   $$self{'opts'}{$_}{'short'} ? :
1592  ***      0      0      0   unless exists $$self{'opts'}{$long}
1612  ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***      0      0      0   exists $$self{'opts'}{$opt} ? :
1617  ***      0      0      0   if ($$opt{'is_cumulative'}) { }
1632  ***      0      0      0   $$self{'opts'}{$long}{'is_cumulative'} ? :
      ***      0      0      0   exists $$self{'defaults'}{$long} ? :
1641  ***      0      0      0   if (@ARGV and $ARGV[0] eq '--config')
1645  ***      0      0      0   if ($self->has('config'))
1651  ***      0      0      0   if ($EVAL_ERROR)
1652  ***      0      0      0   $self->got('config') ? :
1667  ***      0      0      0   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
1670  ***      0      0      0   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
1671  ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
1677  ***      0      0      0   if (@ARGV and $$self{'strict'})
1683  ***      0      0      0   if (@set > 1)
1694  ***      0      0      0   if (@set == 0)
1704  ***      0      0      0   if ($$opt{'got'}) { }
      ***      0      0      0   elsif ($$opt{'is_required'}) { }
1705  ***      0      0      0   if (exists $$self{'disables'}{$long})
1712  ***      0      0      0   if (exists $$self{'allowed_groups'}{$long})
1724  ***      0      0      0   if $restricted_opt eq $long
1725  ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
1730  ***      0      0      0   if (@restricted_opts)
1732  ***      0      0      0   if (@restricted_opts == 1) { }
1761  ***      0      0      0   unless $opt and $$opt{'type'}
1764  ***      0      0      0   if ($val and $$opt{'type'} eq 'm') { }
      ***      0      0      0   elsif ($val and $$opt{'type'} eq 'd') { }
      ***      0      0      0   elsif ($val and $$opt{'type'} eq 'z') { }
      ***      0      0      0   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
      ***      0      0      0   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
1767  ***      0      0      0   if (not $suffix)
1773  ***      0      0      0   if ($suffix =~ /[smhd]/) { }
1774  ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
1789  ***      0      0      0   if ($from_key)
1800  ***      0      0      0   if (defined $num) { }
1801  ***      0      0      0   if ($factor)
1828  ***      0      0      0   length $opt == 1 ? :
1829  ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
1836  ***      0      0      0   length $opt == 1 ? :
1837  ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
1844  ***      0      0      0   length $opt == 1 ? :
1845  ***      0      0      0   defined $long ? :
1850  ***      0      0      0   length $opt == 1 ? :
1851  ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
1885  ***      0      0      0   if ($$self{'opts'}{'help'}{'got'}) { }
      ***      0      0      0   elsif (scalar @{$$self{'errors'};}) { }
1886  ***      0      0      0   unless print $self->print_usage
1890  ***      0      0      0   unless print $self->print_errors
1899  ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
1908  ***      0      0      0   unless $$self{'got_opts'}
1911  ***      0      0      0   $$_{'is_negatable'} ? :
1915  ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
1931  ***      0      0      0   $group eq 'default' ? :
1937  ***      0      0      0   $$opt{'is_negatable'} ? :
1940  ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
1949  ***      0      0      0   if ($short) { }
1958  ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
1962  ***      0      0      0   if ($$self{'dp'})
1970  ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
1982  ***      0      0      0   if ref $_[0] eq 'OptionParser'
1985  ***      0      0      0   unless print $prompt
1993  ***      0      0      0   unless print "\n"
1996  ***      0      0      0   if ($EVAL_ERROR)
2018  ***      0      0      0   unless open my $fh, '<', $filename
2026  ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
2029  ***      0      0      0   if ($line eq '--')
2034  ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
2052  ***      0      0      0   unless open my $fh, '<', $file
2056  ***      0      0      0   unless $para =~ /^=pod$/m
2060  ***      0      0      0   unless $para =~ /$regex/
2065  ***      0      0      0   unless close $fh
2079  ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
2094  ***      0      0      0   defined $_ ? :
2127  ***      0      0      0   unless $args{$arg}
2137  ***      0      0      0   if (@cols == 0)
2146  ***      0      0      0   $key_exists ? :
2154  ***      0      0      0   if (scalar @cols == 1)
2164  ***      0      0      0   if ($EVAL_ERROR)
2178  ***      0      0      0   if ($key_len and $rows) { }
2179  ***      0      0      0   if ($chosen_key =~ /,/ and $key_len =~ /,/)
2191  ***      0      0      0   wantarray ? :
2211  ***      0      0      0   exists $args{'tbl_struct'}{'keys'}{lc $args{'name'}} ? :
2216  ***      0      0      0   $$explain{$_} ? :
2224  ***      0      0      0   defined $_ ? :
2257  ***      0      0      0   unless $keys
2271  ***      0      0      0   if ($$key{'name'} eq 'PRIMARY')
2276  ***      0      0      0   $$key{'type'} eq 'FULLTEXT' ? :
2277  ***      0      0      0   if ($args{'ignore_order'} or $is_fulltext)
2284  ***      0      0      0   $$key{'is_unique'} ? :
2285  ***      0      0      0   if (not $args{'ignore_structure'})
2286  ***      0      0      0   if $is_fulltext
2293  ***      0      0      0   if ($primary_key)
2316  ***      0      0      0   if ($primary_key and $args{'clustered'} and $args{'tbl_info'}{'engine'} and $args{'tbl_info'}{'engine'} =~ /^(?:InnoDB|solidDB)$/)
2335  ***      0      0      0   unless $fks
2340  ***      0      0      0   unless $fks[$i]
2342  ***      0      0      0   unless $fks[$j]
2349  ***      0      0      0   if ($fks[$i]{'parent_tbl'} eq $fks[$j]{'parent_tbl'} and $i_cols eq $j_cols and $i_pcols eq $j_pcols)
2368  ***      0      0      0   if $args{'callback'}
2383  ***      0      0      0   if ($right_keys != $left_keys) { }
2409  ***      0      0      0   unless defined $$left_keys[$left_index]
2413  ***      0      0      0   unless defined $$right_keys[$right_index]
2425  ***      0      0      0   if (substr($left_cols, 0, $right_len_cols) eq substr($right_cols, 0, $right_len_cols)) { }
2428  ***      0      0      0   if ($args{'exact_duplicates'} and $right_len_cols < $left_len_cols)
2433  ***      0      0      0   if (exists $$right_keys[$right_index]{'unique_col'})
2442  ***      0      0      0   if ($$right_keys[$right_index]{'unconstrained'})
2447  ***      0      0      0   $right_len_cols < $left_len_cols ? :
2461  ***      0      0      0   if $args{'callback'}
2479  ***      0      0      0   unless $primary_key
2480  ***      0      0      0   unless $keys
2490  ***      0      0      0   if (substr($suffix, 0, $len) eq substr($pkcols, 0, $len))
2501  ***      0      0      0   if $args{'callback'}
2515  ***      0      0      0   unless $unique_keys
2525  ***      0      0      0   unless $unique_key
2527  ***      0      0      0   if (@$cols == 1) { }
2529  ***      0      0      0   if (not exists $unique_cols{$$cols[0]})
2546  ***      0      0      0   if (exists $unique_cols{$col})
2549  ***      0      0      0   if ++$n_unique_cols > 1
2553  ***      0      0      0   if ($n_unique_cols and $$unique_set{'key'}{'name'} ne 'PRIMARY')
2565  ***      0      0      0   if (exists $unconstrain{$$unique_keys[$i]{'name'}})
2581  ***      0      0      0   defined $_ ? :
2623  ***      0      0      0   defined $args{'p_ms'} ? :
2624  ***      0      0      0   defined $args{'p_s'} ? :
2627  ***      0      0      0   if $t < 0
2629  ***      0      0      0   if $t =~ /e/
2633  ***      0      0      0   if ($t > 0 and $t <= 0.000999) { }
      ***      0      0      0   elsif ($t >= 0.001 and $t <= 0.999999) { }
      ***      0      0      0   elsif ($t >= 1) { }
2654  ***      0      0      0   $p ? :
2661  ***      0      0      0   unless $secs
2663  ***      0      0      0   $secs >= 3600 ? :
      ***      0      0      0   $secs >= 86400 ? :
2668  ***      0      0      0   $fmt eq 'h' ? :
      ***      0      0      0   $fmt eq 'd' ? :
2687  ***      0      0      0   defined $args{'p'} ? :
2688  ***      0      0      0   defined $args{'d'} ? :
2695  ***      0      0      0   $num =~ /\./ || $n ? :
2714  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s, $f) = $val =~ /^(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)(\.\d+)?$/)
2717  ***      0      0      0   defined $f ? :
      ***      0      0      0   defined $f ? :
2726  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s) = $val =~ /^(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)$/)
2743  ***      0      0      0   defined $_ ? :
2803  ***      0      0      0   $o->get('key-types') =~ /k/ ? :
2804  ***      0      0      0   $o->get('key-types') =~ /f/ ? :
2808  ***      0      0      0   if ($o->got('ask-pass') and not $o->got('password'))
2818  ***      0      0      0   $o->get('summary') ? :
2865  ***      0      0      0   if $get_keys
2866  ***      0      0      0   if $get_fks
2868  ***      0      0      0   unless %$keys or %$fks
2870  ***      0      0      0   if ($o->got('verbose')) { }
2871  ***      0      0      0   if $keys
2872  ***      0      0      0   if $fks
2875  ***      0      0      0   if $keys
2888  ***      0      0      0   if $fks
2908  ***      0      0      0   if $o->get('summary')
2919  ***      0      0      0   unless $keys
2922  ***      0      0      0   if (not $seen_tbl{"$db$tbl"}++)
2936  ***      0      0      0   unless $dupe
2938  ***      0      0      0   unless exists $args{$arg}
2947  ***      0      0      0   if (not $seen_tbl{"$db$tbl"}++)
2959  ***      0      0      0   if not $seen_col{$_}++
2967  ***      0      0      0   if $o->get('sql')
2972  ***      0      0      0   if ($o->get('summary'))
2981  ***      0      0      0   if ($args{'is_fk'}) { }
2992  ***      0      0      0   if ($size)
2993  ***      0      0      0   if ($chosen_key and $chosen_key ne $$dupe{'key'})
3020  ***     50      1      0   defined $_ ? :


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
333   ***      0      0      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000'
      ***      0      0      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i
378   ***      0      0      0      0   not $parent =~ /\./ and $$opts{'database'}
477   ***      0      0      0      0   $trgs and @$trgs
523   ***      0      0      0      0   $curr and $new
      ***      0      0      0      0   $curr and $new and $curr eq $new
743   ***      0      0      0      0   $$self{'need_engine'} and not defined $args{'parser'}
823   ***      0      0      0      0   $curr and $new
      ***      0      0      0      0   $curr and $new and $curr eq $new
880   ***      0      0      0      0   !$$reject{$val} && !$$reject{$tbl}
      ***      0      0      0      0   !$reject || !$$reject{$val} && !$$reject{$tbl} and !$permit || $$permit{$val} || $$permit{$tbl}
885   ***      0      0      0      0   !$reject || !$$reject{$val} and !$permit || $$permit{$val}
908   ***      0      0      0      0   $equality eq '-' && $$table{$prop} gt $time
      ***      0      0      0      0   $equality eq '+' && $$table{$prop} lt $time
1036  ***     66      2      6      0   not defined $final_props{$key} and defined $$prev{$key}
      ***     33      8      0      0   not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'}
1149  ***     66      1      0      1   not $dbh and $tries--
1185  ***     33      1      0      0   not $dbh and $EVAL_ERROR
1482  ***      0      0      0      0   $type and $type eq 'd'
      ***      0      0      0      0   $type and $type eq 'd' and not $$self{'dp'}
1487  ***      0      0      0      0   $type and $type =~ /[HhAadzm]/
1641  ***      0      0      0      0   @ARGV and $ARGV[0] eq '--config'
1670  ***      0      0      0      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
1677  ***      0      0      0      0   @ARGV and $$self{'strict'}
1761  ***      0      0      0      0   $opt and $$opt{'type'}
1764  ***      0      0      0      0   $val and $$opt{'type'} eq 'm'
      ***      0      0      0      0   $val and $$opt{'type'} eq 'd'
      ***      0      0      0      0   $val and $$opt{'type'} eq 'z'
      ***      0      0      0      0   defined $val and $$opt{'type'} eq 'h'
      ***      0      0      0      0   defined $val and $$opt{'type'} eq 'a'
1829  ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
1837  ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
1851  ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
1940  ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
2034  ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
2178  ***      0      0      0      0   $key_len and $rows
2179  ***      0      0      0      0   $chosen_key =~ /,/ and $key_len =~ /,/
2316  ***      0      0      0      0   $primary_key and $args{'clustered'}
      ***      0      0      0      0   $primary_key and $args{'clustered'} and $args{'tbl_info'}{'engine'}
      ***      0      0      0      0   $primary_key and $args{'clustered'} and $args{'tbl_info'}{'engine'} and $args{'tbl_info'}{'engine'} =~ /^(?:InnoDB|solidDB)$/
2349  ***      0      0      0      0   $fks[$i]{'parent_tbl'} eq $fks[$j]{'parent_tbl'} and $i_cols eq $j_cols
      ***      0      0      0      0   $fks[$i]{'parent_tbl'} eq $fks[$j]{'parent_tbl'} and $i_cols eq $j_cols and $i_pcols eq $j_pcols
2428  ***      0      0      0      0   $args{'exact_duplicates'} and $right_len_cols < $left_len_cols
2553  ***      0      0      0      0   $n_unique_cols and $$unique_set{'key'}{'name'} ne 'PRIMARY'
2633  ***      0      0      0      0   $t > 0 and $t <= 0.000999
      ***      0      0      0      0   $t >= 0.001 and $t <= 0.999999
2691  ***      0      0      0      0   $num >= $d and $n < @units - 1
2808  ***      0      0      0      0   $o->got('ask-pass') and not $o->got('password')
2993  ***      0      0      0      0   $chosen_key and $chosen_key ne $$dupe{'key'}

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
295   ***      0      0      0   $$_{'Privileges'} || ''
311   ***      0      0      0   $engine || undef
332   ***      0      0      0   $type || $special || 'BTREE'
689   ***      0      0      0   $$_[1] || ''
1012  ***     50      0      1   $prev ||= {}
1013  ***     50      0      1   $defaults ||= {}
1091  ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
1106  ***     50      0      1   $self->prop('dbidriver') || ''
1110  ***      0      0      0   $$info{'D'} || ''
1116  ***     50      0      1   $$info{'D'} || ''
1138  ***     50      1      0   $opts ||= {}
1213  ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
1229  ***      0      0      0   $level ||= 0
1230  ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
1294  ***      0      0      0   $args{'prompt'} || '<options>'
      ***      0      0      0   $args{'dp'} || undef
1336  ***      0      0      0   $file ||= '../mk-duplicate-key-checker'
1472  ***      0      0      0   $$opt{'group'} ||= 'default'
1769  ***      0      0      0   $s || 's'
1806  ***      0      0      0   $pre || ''
1813  ***      0      0      0   $val || ''
1816  ***      0      0      0   $val || ''
1874  ***      0      0      0   $$self{'description'} || ''
1942  ***      0      0      0   $s ||= 's'
1968  ***      0      0      0   $$opt{'type'} || ''
2653  ***      0      0      0   $args{'p'} || 0
2655  ***      0      0      0   $of ||= 1
2660  ***      0      0      0   $secs ||= 0
2987  ***      0      0      0   $size ||= 0

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
110   ***      0      0      0      0   $_ eq '' || $_ =~ /^0|\D/
227   ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'}
      ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
332   ***      0      0      0      0   $type || $special
535   ***      0      0      0      0   not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl}
569   ***      0      0      0      0   not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl}
599   ***      0      0      0      0   not $$self{'cache'} or not $$self{'triggers'}{$db}
633   ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'} or $like
652   ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db} or $like
666   ***      0      0      0      0   $tbl{'type'} || $tbl{'comment'}
      ***      0      0      0      0   $tbl{'engine'} ||= $tbl{'type'} || $tbl{'comment'}
678   ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db} or $like
739   ***      0      0      0      0   $$self{'engines'}{'permit'} || $$self{'engines'}{'reject'}
      ***      0      0      0      0   $$self{'engines'}{'permit'} || $$self{'engines'}{'reject'} || $$self{'engines'}{'regexp'}
880   ***      0      0      0      0   not $regexp or $val =~ /$regexp/
      ***      0      0      0      0   !$reject || !$$reject{$val} && !$$reject{$tbl}
      ***      0      0      0      0   !$permit || $$permit{$val}
      ***      0      0      0      0   !$permit || $$permit{$val} || $$permit{$tbl}
885   ***      0      0      0      0   not $regexp or $val =~ /$regexp/
      ***      0      0      0      0   !$reject || !$$reject{$val}
      ***      0      0      0      0   !$permit || $$permit{$val}
905   ***      0      0      0      0   $$self{'timestamp'}{$dbh}{$num} ||= $dbh->selectrow_array($sql)
908   ***      0      0      0      0   $equality eq '-' && $$table{$prop} gt $time || $equality eq '+' && $$table{$prop} lt $time
      ***      0      0      0      0   $equality eq '-' && $$table{$prop} gt $time || $equality eq '+' && $$table{$prop} lt $time || $$table{$prop} eq $time
1129  ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
1130  ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
1131  ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
1132  ***      0      0      0      0   $$dsn{'u'} ||= $user
1133  ***      0      0      0      0   $$dsn{'D'} ||= $db
1292  ***      0      0      0      0   $program_name ||= $PROGRAM_NAME
1764  ***      0      0      0      0   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***      0      0      0      0   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
2277  ***      0      0      0      0   $args{'ignore_order'} or $is_fulltext
2663  ***      0      0      0      0   $fmt ||= $secs >= 86400 ? 'd' : ($secs >= 3600 ? 'h' : 'm')
2695  ***      0      0      0      0   $num =~ /\./ || $n
2857  ***      0      0      0      0   $tp->get_engine($ddl) || next TABLE
2868  ***      0      0      0      0   %$keys or %$fks


Covered Subroutines
-------------------

Subroutine                  Count Location                                                                       
--------------------------- ----- -------------------------------------------------------------------------------
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1275
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1276
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1278
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1279
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1280
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1282
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:141 
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:142 
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:143 
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:145 
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2111
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2112
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2113
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2114
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2116
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2241
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2242
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2243
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2245
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2247
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:23  
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:24  
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2598
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2599
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2600
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2601
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2602
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2604
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2765
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2766
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2767
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2771
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:35  
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:36  
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:38  
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:40  
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:420 
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:421 
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:423 
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:425 
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:721 
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:722 
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:724 
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:725 
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:729 
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:82  
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:83  
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:87  
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:89  
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:930 
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:931 
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:935 
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:936 
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:939 
BEGIN                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:941 
_d                              1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3019
get_cxn_params                  1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1103
get_dbh                         1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1137
new                             1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:148 
new                             1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:92  
new                             1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:944 
parse                           1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1006
prop                            4 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:997 

Uncovered Subroutines
---------------------

Subroutine                  Count Location                                                                       
--------------------------- ----- -------------------------------------------------------------------------------
__ANON__                        0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1665
__ANON__                        0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:767 
__ANON__                        0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:778 
__ANON__                        0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:790 
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1257
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2093
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2223
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2580
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2742
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:402 
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:66  
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:703 
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:914 
_explain_to_text                0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2215
_fetch_tbl_list                 0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:834 
_filter                         0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:870 
_get_participants               0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1555
_key_exists                     0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2210
_parse_specs                    0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1436
_pod_to_specs                   0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1335
_read_config_file               0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2017
_set_option                     0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1611
_test_date                      0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:893 
_use_db                         0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:515 
_use_db                         0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:815 
_validate_type                  0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1760
as_string                       0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1075
clone                           0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2070
copy                            0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1239
descr                           0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1873
disconnect                      0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1222
dump                            0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:459 
error                           0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2205
errors                          0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1863
explain                         0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2200
fill_in_dsn                     0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1125
find_best_index                 0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:239 
find_databases                  0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:764 
find_possible_keys              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:257 
find_tables                     0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:775 
find_views                      0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:807 
get                             0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1827
get_columns                     0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:567 
get_create_table                0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:534 
get_databases                   0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:632 
get_defaults                    0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1601
get_defaults_files              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1330
get_duplicate_fks               0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2334
get_duplicate_keys              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2256
get_engine                      0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:308 
get_fks                         0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:368 
get_groups                      0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1606
get_hostname                    0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1212
get_key_size                    0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2125
get_keys                        0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:315 
get_opts                        0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1628
get_specs                       0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1323
get_table_list                  0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:677 
get_table_status                0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:651 
get_tmp_table                   0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:587 
get_triggers                    0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:598 
got                             0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1835
has                             0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1843
init_timestamp                  0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:755 
main                            0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2786
make_checksum                   0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2735
micro_t                         0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2622
new                             0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1287
new                             0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2119
new                             0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2250
new                             0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:43  
new                             0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:452 
new                             0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:733 
opt_values                      0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1573
opts                            0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1567
parse                           0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:154 
parse                           0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:48  
parse_options                   0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1062
parse_timestamp                 0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2713
percentage_of                   0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2652
print_active_handles            0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1228
print_all_keys                  0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2918
print_duplicate_key             0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2935
print_errors                    0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1897
print_key_summary               0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3005
print_usage                     0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1907
prompt                          0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1868
prompt_noecho                   0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1982
query                           0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2195
quote                           0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:97  
quote_val                       0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:105 
read_para_after                 0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2051
remove_auto_increment           0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:396 
remove_clustered_duplicates     0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2478
remove_prefix_duplicates        0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2376
save_error                      0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1858
secs_to_time                    0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2659
set                             0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1849
set_defaults                    0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1589
short_opts                      0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1583
shorten                         0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2686
sort_indexes                    0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:220 
split_unquote                   0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:120 
table_exists                    0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:285 
ts                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2703
unconstrain_keys                0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2514
unix_timestamp                  0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2725
usage                           0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1084
usage_or_errors                 0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1884
version_ge                      0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:55  


