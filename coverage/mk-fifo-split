---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...-fifo-split/mk-fifo-split    7.9    0.0    2.5   29.3    n/a    0.0    6.1
mk-fifo-split.t               100.0   50.0   33.3  100.0    n/a  100.0   90.8
Total                          14.3    1.1    3.3   35.9    n/a  100.0   10.5
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:22:11 2010
Finish:       Thu Jan 28 22:22:11 2010

Run:          ./mk-fifo-split.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:22:12 2010
Finish:       Thu Jan 28 22:22:15 2010

/home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
4                                                     # Feedback and improvements are welcome.
5                                                     #
6                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
7                                                     # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
8                                                     # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
9                                                     #
10                                                    # This program is free software; you can redistribute it and/or modify it under
11                                                    # the terms of the GNU General Public License as published by the Free Software
12                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
13                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
14                                                    # licenses.
15                                                    #
16                                                    # You should have received a copy of the GNU General Public License along with
17                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
18                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
19                                                    
20             1                    1            10   use strict;
               1                                  4   
               1                                 11   
21             1                    1            13   use warnings FATAL => 'all';
               1                                  2   
               1                                  7   
22                                                    
23                                                    our $VERSION = '@VERSION@';
24                                                    our $DISTRIB = '@DISTRIB@';
25                                                    our $SVN_REV = sprintf("%d", (q$Revision: 5425 $ =~ m/(\d+)/g, 0));
26                                                    
27                                                    # ###########################################################################
28                                                    # OptionParser package 5266
29                                                    # ###########################################################################
30                                                    package OptionParser;
31                                                    
32             1                    1             6   use strict;
               1                                  3   
               1                                  5   
33             1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                  5   
34                                                    
35             1                    1            12   use Getopt::Long;
               1                                  3   
               1                                  7   
36             1                    1             7   use List::Util qw(max);
               1                                  3   
               1                                 11   
37             1                    1             6   use English qw(-no_match_vars);
               1                                  3   
               1                                  7   
38                                                    
39    ***      1            50      1             8   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  9   
               1                                 17   
40                                                    
41                                                    my $POD_link_re = '[LC]<"?([^">]+)"?>';
42                                                    
43                                                    my %attributes = (
44                                                       'type'       => 1,
45                                                       'short form' => 1,
46                                                       'group'      => 1,
47                                                       'default'    => 1,
48                                                       'cumulative' => 1,
49                                                       'negatable'  => 1,
50                                                    );
51                                                    
52                                                    sub new {
53    ***      0                    0                    my ( $class, %args ) = @_;
54    ***      0                                         foreach my $arg ( qw(description) ) {
55    ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
56                                                       }
57    ***      0                                         my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
58    ***      0             0                           $program_name ||= $PROGRAM_NAME;
59    ***      0             0                           my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                    0                        
      ***                    0                        
60                                                    
61    ***      0      0      0                           my $self = {
      ***                    0                        
62                                                          description    => $args{description},
63                                                          prompt         => $args{prompt} || '<options>',
64                                                          strict         => (exists $args{strict} ? $args{strict} : 1),
65                                                          dp             => $args{dp}     || undef,
66                                                          program_name   => $program_name,
67                                                          opts           => {},
68                                                          got_opts       => 0,
69                                                          short_opts     => {},
70                                                          defaults       => {},
71                                                          groups         => {},
72                                                          allowed_groups => {},
73                                                          errors         => [],
74                                                          rules          => [],  # desc of rules for --help
75                                                          mutex          => [],  # rule: opts are mutually exclusive
76                                                          atleast1       => [],  # rule: at least one opt is required
77                                                          disables       => {},  # rule: opt disables other opts 
78                                                          defaults_to    => {},  # rule: opt defaults to value of other opt
79                                                          default_files  => [
80                                                             "/etc/maatkit/maatkit.conf",
81                                                             "/etc/maatkit/$program_name.conf",
82                                                             "$home/.maatkit.conf",
83                                                             "$home/.$program_name.conf",
84                                                          ],
85                                                       };
86    ***      0                                         return bless $self, $class;
87                                                    }
88                                                    
89                                                    sub get_specs {
90    ***      0                    0                    my ( $self, $file ) = @_;
91    ***      0                                         my @specs = $self->_pod_to_specs($file);
92    ***      0                                         $self->_parse_specs(@specs);
93    ***      0                                         return;
94                                                    }
95                                                    
96                                                    sub get_defaults_files {
97    ***      0                    0                    my ( $self ) = @_;
98    ***      0                                         return @{$self->{default_files}};
      ***      0                                      
99                                                    }
100                                                   
101                                                   sub _pod_to_specs {
102   ***      0                    0                    my ( $self, $file ) = @_;
103   ***      0             0                           $file ||= __FILE__;
104   ***      0      0                                  open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
105                                                   
106   ***      0                                         my %types = (
107                                                         string => 's', # standard Getopt type
108                                                         'int'  => 'i', # standard Getopt type
109                                                         float  => 'f', # standard Getopt type
110                                                         Hash   => 'H', # hash, formed from a comma-separated list
111                                                         hash   => 'h', # hash as above, but only if a value is given
112                                                         Array  => 'A', # array, similar to Hash
113                                                         array  => 'a', # array, similar to hash
114                                                         DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
115                                                         size   => 'z', # size with kMG suffix (powers of 2^10)
116                                                         'time' => 'm', # time, with an optional suffix of s/h/m/d
117                                                      );
118   ***      0                                         my @specs = ();
119   ***      0                                         my @rules = ();
120   ***      0                                         my $para;
121                                                   
122   ***      0                                         local $INPUT_RECORD_SEPARATOR = '';
123   ***      0                                         while ( $para = <$fh> ) {
124   ***      0      0                                     next unless $para =~ m/^=head1 OPTIONS/;
125   ***      0                                            last;
126                                                      }
127                                                   
128   ***      0                                         while ( $para = <$fh> ) {
129   ***      0      0                                     last if $para =~ m/^=over/;
130   ***      0                                            chomp $para;
131   ***      0                                            $para =~ s/\s+/ /g;
132   ***      0                                            $para =~ s/$POD_link_re/$1/go;
133   ***      0                                            MKDEBUG && _d('Option rule:', $para);
134   ***      0                                            push @rules, $para;
135                                                      }
136                                                   
137   ***      0      0                                  die 'POD has no OPTIONS section' unless $para;
138                                                   
139   ***      0                                         do {
140   ***      0      0                                     if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
141   ***      0                                               chomp $para;
142   ***      0                                               MKDEBUG && _d($para);
143   ***      0                                               my %attribs;
144                                                   
145   ***      0                                               $para = <$fh>; # read next paragraph, possibly attributes
146                                                   
147   ***      0      0                                        if ( $para =~ m/: / ) { # attributes
148   ***      0                                                  $para =~ s/\s+\Z//g;
149   ***      0                                                  %attribs = map {
150   ***      0                                                        my ( $attrib, $val) = split(/: /, $_);
151   ***      0      0                                                 die "Unrecognized attribute for --$option: $attrib"
152                                                                        unless $attributes{$attrib};
153   ***      0                                                        ($attrib, $val);
154                                                                  } split(/; /, $para);
155   ***      0      0                                           if ( $attribs{'short form'} ) {
156   ***      0                                                     $attribs{'short form'} =~ s/-//;
157                                                               }
158   ***      0                                                  $para = <$fh>; # read next paragraph, probably short help desc
159                                                            }
160                                                            else {
161   ***      0                                                  MKDEBUG && _d('Option has no attributes');
162                                                            }
163                                                   
164   ***      0                                               $para =~ s/\s+\Z//g;
165   ***      0                                               $para =~ s/\s+/ /g;
166   ***      0                                               $para =~ s/$POD_link_re/$1/go;
167                                                   
168   ***      0                                               $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
169   ***      0                                               MKDEBUG && _d('Short help:', $para);
170                                                   
171   ***      0      0                                        die "No description after option spec $option" if $para =~ m/^=item/;
172                                                   
173   ***      0      0                                        if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
174   ***      0                                                  $option = $base_option;
175   ***      0                                                  $attribs{'negatable'} = 1;
176                                                            }
177                                                   
178   ***      0      0                                        push @specs, {
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
179                                                               spec  => $option
180                                                                  . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
181                                                                  . ($attribs{'negatable'}  ? '!'                          : '' )
182                                                                  . ($attribs{'cumulative'} ? '+'                          : '' )
183                                                                  . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
184                                                               desc  => $para
185                                                                  . ($attribs{default} ? " (default $attribs{default})" : ''),
186                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
187                                                            };
188                                                         }
189   ***      0                                            while ( $para = <$fh> ) {
190   ***      0      0                                        last unless $para;
191                                                   
192                                                   
193   ***      0      0                                        if ( $para =~ m/^=head1/ ) {
194   ***      0                                                  $para = undef; # Can't 'last' out of a do {} block.
195   ***      0                                                  last;
196                                                            }
197   ***      0      0                                        last if $para =~ m/^=item --/;
198                                                         }
199                                                      } while ( $para );
200                                                   
201   ***      0      0                                  die 'No valid specs in POD OPTIONS' unless @specs;
202                                                   
203   ***      0                                         close $fh;
204   ***      0                                         return @specs, @rules;
205                                                   }
206                                                   
207                                                   sub _parse_specs {
208   ***      0                    0                    my ( $self, @specs ) = @_;
209   ***      0                                         my %disables; # special rule that requires deferred checking
210                                                   
211   ***      0                                         foreach my $opt ( @specs ) {
212   ***      0      0                                     if ( ref $opt ) { # It's an option spec, not a rule.
213                                                            MKDEBUG && _d('Parsing opt spec:',
214   ***      0                                                  map { ($_, '=>', $opt->{$_}) } keys %$opt);
215                                                   
216   ***      0                                               my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
217   ***      0      0                                        if ( !$long ) {
218   ***      0                                                  die "Cannot parse long option from spec $opt->{spec}";
219                                                            }
220   ***      0                                               $opt->{long} = $long;
221                                                   
222   ***      0      0                                        die "Duplicate long option --$long" if exists $self->{opts}->{$long};
223   ***      0                                               $self->{opts}->{$long} = $opt;
224                                                   
225   ***      0      0                                        if ( length $long == 1 ) {
226   ***      0                                                  MKDEBUG && _d('Long opt', $long, 'looks like short opt');
227   ***      0                                                  $self->{short_opts}->{$long} = $long;
228                                                            }
229                                                   
230   ***      0      0                                        if ( $short ) {
231   ***      0      0                                           die "Duplicate short option -$short"
232                                                                  if exists $self->{short_opts}->{$short};
233   ***      0                                                  $self->{short_opts}->{$short} = $long;
234   ***      0                                                  $opt->{short} = $short;
235                                                            }
236                                                            else {
237   ***      0                                                  $opt->{short} = undef;
238                                                            }
239                                                   
240   ***      0      0                                        $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
241   ***      0      0                                        $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
242   ***      0      0                                        $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
243                                                   
244   ***      0             0                                 $opt->{group} ||= 'default';
245   ***      0                                               $self->{groups}->{ $opt->{group} }->{$long} = 1;
246                                                   
247   ***      0                                               $opt->{value} = undef;
248   ***      0                                               $opt->{got}   = 0;
249                                                   
250   ***      0                                               my ( $type ) = $opt->{spec} =~ m/=(.)/;
251   ***      0                                               $opt->{type} = $type;
252   ***      0                                               MKDEBUG && _d($long, 'type:', $type);
253                                                   
254   ***      0      0      0                                 if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                    0                        
255   ***      0                                                  die "$opt->{long} is type DSN (d) but no dp argument "
256                                                                  . "was given when this OptionParser object was created";
257                                                            }
258                                                   
259   ***      0      0      0                                 $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
260                                                   
261   ***      0      0                                        if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
262   ***      0      0                                           $self->{defaults}->{$long} = defined $def ? $def : 1;
263   ***      0                                                  MKDEBUG && _d($long, 'default:', $def);
264                                                            }
265                                                   
266   ***      0      0                                        if ( $long eq 'config' ) {
267   ***      0                                                  $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
268                                                            }
269                                                   
270   ***      0      0                                        if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
271   ***      0                                                  $disables{$long} = $dis;
272   ***      0                                                  MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
273                                                            }
274                                                   
275   ***      0                                               $self->{opts}->{$long} = $opt;
276                                                         }
277                                                         else { # It's an option rule, not a spec.
278   ***      0                                               MKDEBUG && _d('Parsing rule:', $opt); 
279   ***      0                                               push @{$self->{rules}}, $opt;
      ***      0                                      
280   ***      0                                               my @participants = $self->_get_participants($opt);
281   ***      0                                               my $rule_ok = 0;
282                                                   
283   ***      0      0                                        if ( $opt =~ m/mutually exclusive|one and only one/ ) {
284   ***      0                                                  $rule_ok = 1;
285   ***      0                                                  push @{$self->{mutex}}, \@participants;
      ***      0                                      
286   ***      0                                                  MKDEBUG && _d(@participants, 'are mutually exclusive');
287                                                            }
288   ***      0      0                                        if ( $opt =~ m/at least one|one and only one/ ) {
289   ***      0                                                  $rule_ok = 1;
290   ***      0                                                  push @{$self->{atleast1}}, \@participants;
      ***      0                                      
291   ***      0                                                  MKDEBUG && _d(@participants, 'require at least one');
292                                                            }
293   ***      0      0                                        if ( $opt =~ m/default to/ ) {
294   ***      0                                                  $rule_ok = 1;
295   ***      0                                                  $self->{defaults_to}->{$participants[0]} = $participants[1];
296   ***      0                                                  MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
297                                                            }
298   ***      0      0                                        if ( $opt =~ m/restricted to option groups/ ) {
299   ***      0                                                  $rule_ok = 1;
300   ***      0                                                  my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
301   ***      0                                                  my @groups = split(',', $groups);
302   ***      0                                                  %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                      
303   ***      0                                                     s/\s+//;
304   ***      0                                                     $_ => 1;
305                                                               } @groups;
306                                                            }
307                                                   
308   ***      0      0                                        die "Unrecognized option rule: $opt" unless $rule_ok;
309                                                         }
310                                                      }
311                                                   
312   ***      0                                         foreach my $long ( keys %disables ) {
313   ***      0                                            my @participants = $self->_get_participants($disables{$long});
314   ***      0                                            $self->{disables}->{$long} = \@participants;
315   ***      0                                            MKDEBUG && _d('Option', $long, 'disables', @participants);
316                                                      }
317                                                   
318   ***      0                                         return; 
319                                                   }
320                                                   
321                                                   sub _get_participants {
322   ***      0                    0                    my ( $self, $str ) = @_;
323   ***      0                                         my @participants;
324   ***      0                                         foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
325   ***      0      0                                     die "Option --$long does not exist while processing rule $str"
326                                                            unless exists $self->{opts}->{$long};
327   ***      0                                            push @participants, $long;
328                                                      }
329   ***      0                                         MKDEBUG && _d('Participants for', $str, ':', @participants);
330   ***      0                                         return @participants;
331                                                   }
332                                                   
333                                                   sub opts {
334   ***      0                    0                    my ( $self ) = @_;
335   ***      0                                         my %opts = %{$self->{opts}};
      ***      0                                      
336   ***      0                                         return %opts;
337                                                   }
338                                                   
339                                                   sub short_opts {
340   ***      0                    0                    my ( $self ) = @_;
341   ***      0                                         my %short_opts = %{$self->{short_opts}};
      ***      0                                      
342   ***      0                                         return %short_opts;
343                                                   }
344                                                   
345                                                   sub set_defaults {
346   ***      0                    0                    my ( $self, %defaults ) = @_;
347   ***      0                                         $self->{defaults} = {};
348   ***      0                                         foreach my $long ( keys %defaults ) {
349   ***      0      0                                     die "Cannot set default for nonexistent option $long"
350                                                            unless exists $self->{opts}->{$long};
351   ***      0                                            $self->{defaults}->{$long} = $defaults{$long};
352   ***      0                                            MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
353                                                      }
354   ***      0                                         return;
355                                                   }
356                                                   
357                                                   sub get_defaults {
358   ***      0                    0                    my ( $self ) = @_;
359   ***      0                                         return $self->{defaults};
360                                                   }
361                                                   
362                                                   sub get_groups {
363   ***      0                    0                    my ( $self ) = @_;
364   ***      0                                         return $self->{groups};
365                                                   }
366                                                   
367                                                   sub _set_option {
368   ***      0                    0                    my ( $self, $opt, $val ) = @_;
369   ***      0      0                                  my $long = exists $self->{opts}->{$opt}       ? $opt
      ***             0                               
370                                                               : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
371                                                               : die "Getopt::Long gave a nonexistent option: $opt";
372                                                   
373   ***      0                                         $opt = $self->{opts}->{$long};
374   ***      0      0                                  if ( $opt->{is_cumulative} ) {
375   ***      0                                            $opt->{value}++;
376                                                      }
377                                                      else {
378   ***      0                                            $opt->{value} = $val;
379                                                      }
380   ***      0                                         $opt->{got} = 1;
381   ***      0                                         MKDEBUG && _d('Got option', $long, '=', $val);
382                                                   }
383                                                   
384                                                   sub get_opts {
385   ***      0                    0                    my ( $self ) = @_; 
386                                                   
387   ***      0                                         foreach my $long ( keys %{$self->{opts}} ) {
      ***      0                                      
388   ***      0                                            $self->{opts}->{$long}->{got} = 0;
389   ***      0      0                                     $self->{opts}->{$long}->{value}
      ***             0                               
390                                                            = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
391                                                            : $self->{opts}->{$long}->{is_cumulative} ? 0
392                                                            : undef;
393                                                      }
394   ***      0                                         $self->{got_opts} = 0;
395                                                   
396   ***      0                                         $self->{errors} = [];
397                                                   
398   ***      0      0      0                           if ( @ARGV && $ARGV[0] eq "--config" ) {
399   ***      0                                            shift @ARGV;
400   ***      0                                            $self->_set_option('config', shift @ARGV);
401                                                      }
402   ***      0      0                                  if ( $self->has('config') ) {
403   ***      0                                            my @extra_args;
404   ***      0                                            foreach my $filename ( split(',', $self->get('config')) ) {
405   ***      0                                               eval {
406   ***      0                                                  push @extra_args, $self->_read_config_file($filename);
407                                                            };
408   ***      0      0                                        if ( $EVAL_ERROR ) {
409   ***      0      0                                           if ( $self->got('config') ) {
410   ***      0                                                     die $EVAL_ERROR;
411                                                               }
412                                                               elsif ( MKDEBUG ) {
413                                                                  _d($EVAL_ERROR);
414                                                               }
415                                                            }
416                                                         }
417   ***      0                                            unshift @ARGV, @extra_args;
418                                                      }
419                                                   
420   ***      0                                         Getopt::Long::Configure('no_ignore_case', 'bundling');
421                                                      GetOptions(
422   ***      0                    0                       map    { $_->{spec} => sub { $self->_set_option(@_); } }
      ***      0                                      
      ***      0                                      
423   ***      0                                            grep   { $_->{long} ne 'config' } # --config is handled specially above.
424   ***      0      0                                     values %{$self->{opts}}
425                                                      ) or $self->save_error('Error parsing options');
426                                                   
427   ***      0      0      0                           if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
428   ***      0      0                                     printf("%s  Ver %s Distrib %s Changeset %s\n",
429                                                            $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
430                                                               or die "Cannot print: $OS_ERROR";
431   ***      0                                            exit 0;
432                                                      }
433                                                   
434   ***      0      0      0                           if ( @ARGV && $self->{strict} ) {
435   ***      0                                            $self->save_error("Unrecognized command-line options @ARGV");
436                                                      }
437                                                   
438   ***      0                                         foreach my $mutex ( @{$self->{mutex}} ) {
      ***      0                                      
439   ***      0                                            my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                      
440   ***      0      0                                     if ( @set > 1 ) {
441   ***      0                                               my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                      
442   ***      0                                                            @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
443                                                                    . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
444                                                                    . ' are mutually exclusive.';
445   ***      0                                               $self->save_error($err);
446                                                         }
447                                                      }
448                                                   
449   ***      0                                         foreach my $required ( @{$self->{atleast1}} ) {
      ***      0                                      
450   ***      0                                            my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                      
451   ***      0      0                                     if ( @set == 0 ) {
452   ***      0                                               my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                      
453   ***      0                                                            @{$required}[ 0 .. scalar(@$required) - 2] )
454                                                                    .' or --'.$self->{opts}->{$required->[-1]}->{long};
455   ***      0                                               $self->save_error("Specify at least one of $err");
456                                                         }
457                                                      }
458                                                   
459   ***      0                                         foreach my $long ( keys %{$self->{opts}} ) {
      ***      0                                      
460   ***      0                                            my $opt = $self->{opts}->{$long};
461   ***      0      0                                     if ( $opt->{got} ) {
      ***             0                               
462   ***      0      0                                        if ( exists $self->{disables}->{$long} ) {
463   ***      0                                                  my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                      
464   ***      0                                                  map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                      
465   ***      0                                                  MKDEBUG && _d('Unset options', @disable_opts,
466                                                                  'because', $long,'disables them');
467                                                            }
468                                                   
469   ***      0      0                                        if ( exists $self->{allowed_groups}->{$long} ) {
470                                                   
471   ***      0                                                  my @restricted_groups = grep {
472   ***      0                                                     !exists $self->{allowed_groups}->{$long}->{$_}
473   ***      0                                                  } keys %{$self->{groups}};
474                                                   
475   ***      0                                                  my @restricted_opts;
476   ***      0                                                  foreach my $restricted_group ( @restricted_groups ) {
477   ***      0                                                     RESTRICTED_OPT:
478   ***      0                                                     foreach my $restricted_opt (
479                                                                     keys %{$self->{groups}->{$restricted_group}} )
480                                                                  {
481   ***      0      0                                                 next RESTRICTED_OPT if $restricted_opt eq $long;
482   ***      0      0                                                 push @restricted_opts, $restricted_opt
483                                                                        if $self->{opts}->{$restricted_opt}->{got};
484                                                                  }
485                                                               }
486                                                   
487   ***      0      0                                           if ( @restricted_opts ) {
488   ***      0                                                     my $err;
489   ***      0      0                                              if ( @restricted_opts == 1 ) {
490   ***      0                                                        $err = "--$restricted_opts[0]";
491                                                                  }
492                                                                  else {
493   ***      0                                                        $err = join(', ',
494   ***      0                                                                  map { "--$self->{opts}->{$_}->{long}" }
495   ***      0                                                                  grep { $_ } 
496                                                                               @restricted_opts[0..scalar(@restricted_opts) - 2]
497                                                                            )
498                                                                          . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
499                                                                  }
500   ***      0                                                     $self->save_error("--$long is not allowed with $err");
501                                                               }
502                                                            }
503                                                   
504                                                         }
505                                                         elsif ( $opt->{is_required} ) { 
506   ***      0                                               $self->save_error("Required option --$long must be specified");
507                                                         }
508                                                   
509   ***      0                                            $self->_validate_type($opt);
510                                                      }
511                                                   
512   ***      0                                         $self->{got_opts} = 1;
513   ***      0                                         return;
514                                                   }
515                                                   
516                                                   sub _validate_type {
517   ***      0                    0                    my ( $self, $opt ) = @_;
518   ***      0      0      0                           return unless $opt && $opt->{type};
519   ***      0                                         my $val = $opt->{value};
520                                                   
521   ***      0      0      0                           if ( $val && $opt->{type} eq 'm' ) {  # type time
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***                    0                        
      ***                    0                        
522   ***      0                                            MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
523   ***      0                                            my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
524   ***      0      0                                     if ( !$suffix ) {
525   ***      0                                               my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
526   ***      0             0                                 $suffix = $s || 's';
527   ***      0                                               MKDEBUG && _d('No suffix given; using', $suffix, 'for',
528                                                               $opt->{long}, '(value:', $val, ')');
529                                                         }
530   ***      0      0                                     if ( $suffix =~ m/[smhd]/ ) {
531   ***      0      0                                        $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***             0                               
532                                                                 : $suffix eq 'm' ? $num * 60       # Minutes
533                                                                 : $suffix eq 'h' ? $num * 3600     # Hours
534                                                                 :                  $num * 86400;   # Days
535   ***      0             0                                 $opt->{value} = ($prefix || '') . $val;
536   ***      0                                               MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
537                                                         }
538                                                         else {
539   ***      0                                               $self->save_error("Invalid time suffix for --$opt->{long}");
540                                                         }
541                                                      }
542                                                      elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
543   ***      0                                            MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
544   ***      0                                            my $prev = {};
545   ***      0                                            my $from_key = $self->{defaults_to}->{ $opt->{long} };
546   ***      0      0                                     if ( $from_key ) {
547   ***      0                                               MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
548   ***      0                                               $prev = $self->{opts}->{$from_key}->{value};
549                                                         }
550   ***      0                                            my $defaults = $self->{dp}->parse_options($self);
551   ***      0                                            $opt->{value} = $self->{dp}->parse($val, $prev, $defaults);
552                                                      }
553                                                      elsif ( $val && $opt->{type} eq 'z' ) {  # type size
554   ***      0                                            MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
555   ***      0                                            my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
556   ***      0                                            my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
557   ***      0      0                                     if ( defined $num ) {
558   ***      0      0                                        if ( $factor ) {
559   ***      0                                                  $num *= $factor_for{$factor};
560   ***      0                                                  MKDEBUG && _d('Setting option', $opt->{y},
561                                                                  'to num', $num, '* factor', $factor);
562                                                            }
563   ***      0             0                                 $opt->{value} = ($pre || '') . $num;
564                                                         }
565                                                         else {
566   ***      0                                               $self->save_error("Invalid size for --$opt->{long}");
567                                                         }
568                                                      }
569                                                      elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
570   ***      0             0                              $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
      ***      0                                      
571                                                      }
572                                                      elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
573   ***      0             0                              $opt->{value} = [ split(/(?<!\\),/, ($val || '')) ];
574                                                      }
575                                                      else {
576   ***      0                                            MKDEBUG && _d('Nothing to validate for option',
577                                                            $opt->{long}, 'type', $opt->{type}, 'value', $val);
578                                                      }
579                                                   
580   ***      0                                         return;
581                                                   }
582                                                   
583                                                   sub get {
584   ***      0                    0                    my ( $self, $opt ) = @_;
585   ***      0      0                                  my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
586   ***      0      0      0                           die "Option $opt does not exist"
587                                                         unless $long && exists $self->{opts}->{$long};
588   ***      0                                         return $self->{opts}->{$long}->{value};
589                                                   }
590                                                   
591                                                   sub got {
592   ***      0                    0                    my ( $self, $opt ) = @_;
593   ***      0      0                                  my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
594   ***      0      0      0                           die "Option $opt does not exist"
595                                                         unless $long && exists $self->{opts}->{$long};
596   ***      0                                         return $self->{opts}->{$long}->{got};
597                                                   }
598                                                   
599                                                   sub has {
600   ***      0                    0                    my ( $self, $opt ) = @_;
601   ***      0      0                                  my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
602   ***      0      0                                  return defined $long ? exists $self->{opts}->{$long} : 0;
603                                                   }
604                                                   
605                                                   sub set {
606   ***      0                    0                    my ( $self, $opt, $val ) = @_;
607   ***      0      0                                  my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
608   ***      0      0      0                           die "Option $opt does not exist"
609                                                         unless $long && exists $self->{opts}->{$long};
610   ***      0                                         $self->{opts}->{$long}->{value} = $val;
611   ***      0                                         return;
612                                                   }
613                                                   
614                                                   sub save_error {
615   ***      0                    0                    my ( $self, $error ) = @_;
616   ***      0                                         push @{$self->{errors}}, $error;
      ***      0                                      
617                                                   }
618                                                   
619                                                   sub errors {
620   ***      0                    0                    my ( $self ) = @_;
621   ***      0                                         return $self->{errors};
622                                                   }
623                                                   
624                                                   sub prompt {
625   ***      0                    0                    my ( $self ) = @_;
626   ***      0                                         return "Usage: $PROGRAM_NAME $self->{prompt}\n";
627                                                   }
628                                                   
629                                                   sub descr {
630   ***      0                    0                    my ( $self ) = @_;
631   ***      0             0                           my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
632                                                                 . "  For more details, please use the --help option, "
633                                                                 . "or try 'perldoc $PROGRAM_NAME' "
634                                                                 . "for complete documentation.";
635   ***      0                                         $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g);
636   ***      0                                         $descr =~ s/ +$//mg;
637   ***      0                                         return $descr;
638                                                   }
639                                                   
640                                                   sub usage_or_errors {
641   ***      0                    0                    my ( $self ) = @_;
642   ***      0      0                                  if ( $self->{opts}->{help}->{got} ) {
      ***      0      0                               
643   ***      0      0                                     print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
644   ***      0                                            exit 0;
645                                                      }
646                                                      elsif ( scalar @{$self->{errors}} ) {
647   ***      0      0                                     print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
648   ***      0                                            exit 0;
649                                                      }
650   ***      0                                         return;
651                                                   }
652                                                   
653                                                   sub print_errors {
654   ***      0                    0                    my ( $self ) = @_;
655   ***      0                                         my $usage = $self->prompt() . "\n";
656   ***      0      0                                  if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                      
657   ***      0                                            $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
658                                                                 . "\n";
659                                                      }
660   ***      0                                         return $usage . "\n" . $self->descr();
661                                                   }
662                                                   
663                                                   sub print_usage {
664   ***      0                    0                    my ( $self ) = @_;
665   ***      0      0                                  die "Run get_opts() before print_usage()" unless $self->{got_opts};
666   ***      0                                         my @opts = values %{$self->{opts}};
      ***      0                                      
667                                                   
668   ***      0      0                                  my $maxl = max(
669   ***      0                                            map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
670                                                         @opts);
671                                                   
672   ***      0      0                                  my $maxs = max(0,
673   ***      0                                            map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
674   ***      0                                            values %{$self->{short_opts}});
675                                                   
676   ***      0                                         my $lcol = max($maxl, ($maxs + 3));
677   ***      0                                         my $rcol = 80 - $lcol - 6;
678   ***      0                                         my $rpad = ' ' x ( 80 - $rcol );
679                                                   
680   ***      0                                         $maxs = max($lcol - 3, $maxs);
681                                                   
682   ***      0                                         my $usage = $self->descr() . "\n" . $self->prompt();
683                                                   
684   ***      0                                         my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                      
      ***      0                                      
685   ***      0                                         push @groups, 'default';
686                                                   
687   ***      0                                         foreach my $group ( reverse @groups ) {
688   ***      0      0                                     $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
689   ***      0                                            foreach my $opt (
      ***      0                                      
690   ***      0                                               sort { $a->{long} cmp $b->{long} }
691                                                            grep { $_->{group} eq $group }
692                                                            @opts )
693                                                         {
694   ***      0      0                                        my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
695   ***      0                                               my $short = $opt->{short};
696   ***      0                                               my $desc  = $opt->{desc};
697   ***      0      0      0                                 if ( $opt->{type} && $opt->{type} eq 'm' ) {
698   ***      0                                                  my ($s) = $desc =~ m/\(suffix (.)\)/;
699   ***      0             0                                    $s    ||= 's';
700   ***      0                                                  $desc =~ s/\s+\(suffix .\)//;
701   ***      0                                                  $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
702                                                                      . "d=days; if no suffix, $s is used.";
703                                                            }
704   ***      0                                               $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                      
705   ***      0                                               $desc =~ s/ +$//mg;
706   ***      0      0                                        if ( $short ) {
707   ***      0                                                  $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
708                                                            }
709                                                            else {
710   ***      0                                                  $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
711                                                            }
712                                                         }
713                                                      }
714                                                   
715   ***      0      0                                  if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                      
716   ***      0                                            $usage .= "\nRules:\n\n";
717   ***      0                                            $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                      
718                                                      }
719   ***      0      0                                  if ( $self->{dp} ) {
720   ***      0                                            $usage .= "\n" . $self->{dp}->usage();
721                                                      }
722   ***      0                                         $usage .= "\nOptions and values after processing arguments:\n\n";
723   ***      0                                         foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                      
724   ***      0                                            my $val   = $opt->{value};
725   ***      0             0                              my $type  = $opt->{type} || '';
726   ***      0                                            my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
727   ***      0      0                                     $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
728                                                                   : !defined $val             ? '(No value)'
729                                                                   : $type eq 'd'              ? $self->{dp}->as_string($val)
730                                                                   : $type =~ m/H|h/           ? join(',', sort keys %$val)
731                                                                   : $type =~ m/A|a/           ? join(',', @$val)
732                                                                   :                             $val;
733   ***      0                                            $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
734                                                      }
735   ***      0                                         return $usage;
736                                                   }
737                                                   
738                                                   sub prompt_noecho {
739   ***      0      0             0                    shift @_ if ref $_[0] eq __PACKAGE__;
740   ***      0                                         my ( $prompt ) = @_;
741   ***      0                                         local $OUTPUT_AUTOFLUSH = 1;
742   ***      0      0                                  print $prompt
743                                                         or die "Cannot print: $OS_ERROR";
744   ***      0                                         my $response;
745   ***      0                                         eval {
746   ***      0                                            require Term::ReadKey;
747   ***      0                                            Term::ReadKey::ReadMode('noecho');
748   ***      0                                            chomp($response = <STDIN>);
749   ***      0                                            Term::ReadKey::ReadMode('normal');
750   ***      0      0                                     print "\n"
751                                                            or die "Cannot print: $OS_ERROR";
752                                                      };
753   ***      0      0                                  if ( $EVAL_ERROR ) {
754   ***      0                                            die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
755                                                      }
756   ***      0                                         return $response;
757                                                   }
758                                                   
759                                                   if ( MKDEBUG ) {
760                                                      print '# ', $^X, ' ', $], "\n";
761                                                      my $uname = `uname -a`;
762                                                      if ( $uname ) {
763                                                         $uname =~ s/\s+/ /g;
764                                                         print "# $uname\n";
765                                                      }
766                                                      printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
767                                                         $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
768                                                         ($main::SVN_REV || ''), __LINE__);
769                                                      print('# Arguments: ',
770                                                         join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
771                                                   }
772                                                   
773                                                   sub _read_config_file {
774   ***      0                    0                    my ( $self, $filename ) = @_;
775   ***      0      0                                  open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
776   ***      0                                         my @args;
777   ***      0                                         my $prefix = '--';
778   ***      0                                         my $parse  = 1;
779                                                   
780                                                      LINE:
781   ***      0                                         while ( my $line = <$fh> ) {
782   ***      0                                            chomp $line;
783   ***      0      0                                     next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
784   ***      0                                            $line =~ s/\s+#.*$//g;
785   ***      0                                            $line =~ s/^\s+|\s+$//g;
786   ***      0      0                                     if ( $line eq '--' ) {
787   ***      0                                               $prefix = '';
788   ***      0                                               $parse  = 0;
789   ***      0                                               next LINE;
790                                                         }
791   ***      0      0      0                              if ( $parse
      ***             0                               
792                                                            && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
793                                                         ) {
794   ***      0                                               push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                      
795                                                         }
796                                                         elsif ( $line =~ m/./ ) {
797   ***      0                                               push @args, $line;
798                                                         }
799                                                         else {
800   ***      0                                               die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
801                                                         }
802                                                      }
803   ***      0                                         close $fh;
804   ***      0                                         return @args;
805                                                   }
806                                                   
807                                                   sub read_para_after {
808   ***      0                    0                    my ( $self, $file, $regex ) = @_;
809   ***      0      0                                  open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
810   ***      0                                         local $INPUT_RECORD_SEPARATOR = '';
811   ***      0                                         my $para;
812   ***      0                                         while ( $para = <$fh> ) {
813   ***      0      0                                     next unless $para =~ m/^=pod$/m;
814   ***      0                                            last;
815                                                      }
816   ***      0                                         while ( $para = <$fh> ) {
817   ***      0      0                                     next unless $para =~ m/$regex/;
818   ***      0                                            last;
819                                                      }
820   ***      0                                         $para = <$fh>;
821   ***      0                                         chomp($para);
822   ***      0      0                                  close $fh or die "Can't close $file: $OS_ERROR";
823   ***      0                                         return $para;
824                                                   }
825                                                   
826                                                   sub clone {
827   ***      0                    0                    my ( $self ) = @_;
828                                                   
829   ***      0                                         my %clone = map {
830   ***      0                                            my $hashref  = $self->{$_};
831   ***      0                                            my $val_copy = {};
832   ***      0                                            foreach my $key ( keys %$hashref ) {
833   ***      0                                               my $ref = ref $hashref->{$key};
834   ***      0                                               $val_copy->{$key} = !$ref           ? $hashref->{$key}
835   ***      0                                                                 : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
836   ***      0      0                                                          : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
837                                                                              : $hashref->{$key};
838                                                         }
839   ***      0                                            $_ => $val_copy;
840                                                      } qw(opts short_opts defaults);
841                                                   
842   ***      0                                         foreach my $scalar ( qw(got_opts) ) {
843   ***      0                                            $clone{$scalar} = $self->{$scalar};
844                                                      }
845                                                   
846   ***      0                                         return bless \%clone;     
847                                                   }
848                                                   
849                                                   sub _d {
850   ***      0                    0                    my ($package, undef, $line) = caller 0;
851   ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
852   ***      0                                              map { defined $_ ? $_ : 'undef' }
853                                                           @_;
854   ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
855                                                   }
856                                                   
857                                                   1;
858                                                   
859                                                   # ###########################################################################
860                                                   # End OptionParser package
861                                                   # ###########################################################################
862                                                   
863                                                   # ###########################################################################
864                                                   # Daemon package 5266
865                                                   # ###########################################################################
866                                                   
867                                                   package Daemon;
868                                                   
869            1                    1            15   use strict;
               1                                  5   
               1                                  8   
870            1                    1             7   use warnings FATAL => 'all';
               1                                  2   
               1                                  7   
871                                                   
872            1                    1             7   use POSIX qw(setsid);
               1                                  6   
               1                                  7   
873            1                    1             7   use English qw(-no_match_vars);
               1                                  2   
               1                                  7   
874                                                   
875   ***      1            50      1             7   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  3   
               1                                 15   
876                                                   
877                                                   sub new {
878   ***      0                    0                    my ( $class, %args ) = @_;
879   ***      0                                         foreach my $arg ( qw(o) ) {
880   ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
881                                                      }
882   ***      0                                         my $o = $args{o};
883   ***      0      0                                  my $self = {
      ***             0                               
884                                                         o        => $o,
885                                                         log_file => $o->has('log') ? $o->get('log') : undef,
886                                                         PID_file => $o->has('pid') ? $o->get('pid') : undef,
887                                                      };
888                                                   
889   ***      0                                         check_PID_file(undef, $self->{PID_file});
890                                                   
891   ***      0                                         MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
892   ***      0                                         return bless $self, $class;
893                                                   }
894                                                   
895                                                   sub daemonize {
896   ***      0                    0                    my ( $self ) = @_;
897                                                   
898   ***      0                                         MKDEBUG && _d('About to fork and daemonize');
899   ***      0      0                                  defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
900   ***      0      0                                  if ( $pid ) {
901   ***      0                                            MKDEBUG && _d('I am the parent and now I die');
902   ***      0                                            exit;
903                                                      }
904                                                   
905   ***      0                                         $self->{child} = 1;
906                                                   
907   ***      0      0                                  POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
908   ***      0      0                                  chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
909                                                   
910   ***      0                                         $self->_make_PID_file();
911                                                   
912   ***      0                                         $OUTPUT_AUTOFLUSH = 1;
913                                                   
914   ***      0      0                                  if ( -t STDIN ) {
915   ***      0                                            close STDIN;
916   ***      0      0                                     open  STDIN, '/dev/null'
917                                                            or die "Cannot reopen STDIN to /dev/null: $OS_ERROR";
918                                                      }
919                                                   
920   ***      0      0                                  if ( $self->{log_file} ) {
921   ***      0                                            close STDOUT;
922   ***      0      0                                     open  STDOUT, '>>', $self->{log_file}
923                                                            or die "Cannot open log file $self->{log_file}: $OS_ERROR";
924                                                   
925   ***      0                                            close STDERR;
926   ***      0      0                                     open  STDERR, ">&STDOUT"
927                                                            or die "Cannot dupe STDERR to STDOUT: $OS_ERROR"; 
928                                                      }
929                                                      else {
930   ***      0      0                                     if ( -t STDOUT ) {
931   ***      0                                               close STDOUT;
932   ***      0      0                                        open  STDOUT, '>', '/dev/null'
933                                                               or die "Cannot reopen STDOUT to /dev/null: $OS_ERROR";
934                                                         }
935   ***      0      0                                     if ( -t STDERR ) {
936   ***      0                                               close STDERR;
937   ***      0      0                                        open  STDERR, '>', '/dev/null'
938                                                               or die "Cannot reopen STDERR to /dev/null: $OS_ERROR";
939                                                         }
940                                                      }
941                                                   
942   ***      0                                         MKDEBUG && _d('I am the child and now I live daemonized');
943   ***      0                                         return;
944                                                   }
945                                                   
946                                                   sub check_PID_file {
947   ***      0                    0                    my ( $self, $file ) = @_;
948   ***      0      0                                  my $PID_file = $self ? $self->{PID_file} : $file;
949   ***      0                                         MKDEBUG && _d('Checking PID file', $PID_file);
950   ***      0      0      0                           if ( $PID_file && -f $PID_file ) {
951   ***      0                                            my $pid;
952   ***      0                                            eval { chomp($pid = `cat $PID_file`); };
      ***      0                                      
953   ***      0      0                                     die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
954   ***      0                                            MKDEBUG && _d('PID file exists; it contains PID', $pid);
955   ***      0      0                                     if ( $pid ) {
956   ***      0                                               my $pid_is_alive = kill 0, $pid;
957   ***      0      0                                        if ( $pid_is_alive ) {
958   ***      0                                                  die "The PID file $PID_file already exists "
959                                                                  . " and the PID that it contains, $pid, is running";
960                                                            }
961                                                            else {
962   ***      0                                                  warn "Overwriting PID file $PID_file because the PID that it "
963                                                                  . "contains, $pid, is not running";
964                                                            }
965                                                         }
966                                                         else {
967   ***      0                                               die "The PID file $PID_file already exists but it does not "
968                                                               . "contain a PID";
969                                                         }
970                                                      }
971                                                      else {
972   ***      0                                            MKDEBUG && _d('No PID file');
973                                                      }
974   ***      0                                         return;
975                                                   }
976                                                   
977                                                   sub make_PID_file {
978   ***      0                    0                    my ( $self ) = @_;
979   ***      0      0                                  if ( exists $self->{child} ) {
980   ***      0                                            die "Do not call Daemon::make_PID_file() for daemonized scripts";
981                                                      }
982   ***      0                                         $self->_make_PID_file();
983   ***      0                                         $self->{rm_PID_file} = 1;
984   ***      0                                         return;
985                                                   }
986                                                   
987                                                   sub _make_PID_file {
988   ***      0                    0                    my ( $self ) = @_;
989                                                   
990   ***      0                                         my $PID_file = $self->{PID_file};
991   ***      0      0                                  if ( !$PID_file ) {
992   ***      0                                            MKDEBUG && _d('No PID file to create');
993   ***      0                                            return;
994                                                      }
995                                                   
996   ***      0                                         $self->check_PID_file();
997                                                   
998   ***      0      0                                  open my $PID_FH, '>', $PID_file
999                                                         or die "Cannot open PID file $PID_file: $OS_ERROR";
1000  ***      0      0                                  print $PID_FH $PID
1001                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
1002  ***      0      0                                  close $PID_FH
1003                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
1004                                                  
1005  ***      0                                         MKDEBUG && _d('Created PID file:', $self->{PID_file});
1006  ***      0                                         return;
1007                                                  }
1008                                                  
1009                                                  sub _remove_PID_file {
1010  ***      0                    0                    my ( $self ) = @_;
1011  ***      0      0      0                           if ( $self->{PID_file} && -f $self->{PID_file} ) {
1012  ***      0      0                                     unlink $self->{PID_file}
1013                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
1014  ***      0                                            MKDEBUG && _d('Removed PID file');
1015                                                     }
1016                                                     else {
1017  ***      0                                            MKDEBUG && _d('No PID to remove');
1018                                                     }
1019  ***      0                                         return;
1020                                                  }
1021                                                  
1022                                                  sub DESTROY {
1023  ***      0                    0                    my ( $self ) = @_;
1024  ***      0      0      0                           $self->_remove_PID_file() if $self->{child} || $self->{rm_PID_file};
1025  ***      0                                         return;
1026                                                  }
1027                                                  
1028                                                  sub _d {
1029  ***      0                    0                    my ($package, undef, $line) = caller 0;
1030  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
1031  ***      0                                              map { defined $_ ? $_ : 'undef' }
1032                                                          @_;
1033  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1034                                                  }
1035                                                  
1036                                                  1;
1037                                                  
1038                                                  # ###########################################################################
1039                                                  # End Daemon package
1040                                                  # ###########################################################################
1041                                                  
1042                                                  # ###########################################################################
1043                                                  # This is a combination of modules and programs in one -- a runnable module.
1044                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
1045                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
1046                                                  #
1047                                                  # Check at the end of this package for the call to main() which actually runs
1048                                                  # the program.
1049                                                  # ###########################################################################
1050                                                  package mk_fifo_split;
1051                                                  
1052           1                    1             7   use English qw(-no_match_vars);
               1                                  4   
               1                                  5   
1053           1                    1             7   use POSIX qw(mkfifo);
               1                                  2   
               1                                  6   
1054           1                    1             6   use IO::File;
               1                                  3   
               1                                 13   
1055                                                  
1056  ***      1            50      1             7   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  3   
               1                                 14   
1057                                                  
1058                                                  sub main {
1059  ***      0                    0                    @ARGV = @_;  # set global ARGV for this package
1060                                                  
1061                                                     # ########################################################################
1062                                                     # Get configuration information.
1063                                                     # ########################################################################
1064  ***      0                                         my $o = new OptionParser(
1065                                                        strict      => 0,
1066                                                        prompt      => '[options] [FILE ...]',
1067                                                        description => q{splits FILE and pipes lines to a fifo.  With no FILE, }
1068                                                                     . q{or when FILE is -, read standard input.},
1069                                                     );
1070  ***      0                                         $o->get_specs();
1071  ***      0                                         $o->get_opts();
1072                                                  
1073  ***      0      0      0                           if ( !$o->get('lines') || $o->get('lines') <= 0 ) {
1074  ***      0                                            $o->save_error('--lines must be a positive integer');
1075                                                     }
1076  ***      0                                         $o->usage_or_errors();
1077                                                  
1078                                                     # ########################################################################
1079                                                     # If --pid, check it first since we'll die if it already exits.
1080                                                     # ########################################################################
1081  ***      0                                         my $daemon;
1082  ***      0      0                                  if ( $o->get('pid') ) {
1083                                                        # We're not daemoninzing, it just handles PID stuff.  Keep $daemon
1084                                                        # in the the scope of main() because when it's destroyed it automatically
1085                                                        # removes the PID file.
1086  ***      0                                            $daemon = new Daemon(o=>$o);
1087  ***      0                                            $daemon->make_PID_file();
1088                                                     }
1089                                                  
1090  ***      0                                         my $file = $o->get('fifo');
1091                                                  
1092  ***      0      0      0                           if ( $o->get('force') && -e $file ) {
1093  ***      0      0                                     unlink($file) or die "Can't unlink $file: $OS_ERROR";
1094                                                     }
1095  ***      0      0                                  mkfifo($file, 0777) or die "Can't make fifo $file: $OS_ERROR";
1096                                                  
1097  ***      0                                         my $fh;
1098                                                  
1099  ***      0      0                                  $fh = IO::File->new($file, '>') or die "Can't open $file: $OS_ERROR";
1100  ***      0                                         $fh->autoflush(1);
1101                                                  
1102  ***      0      0                                  if ( $o->get('statistics') ) {
1103  ***      0                                            printf("%5s %9s %5s %8s %8s\n", qw(chunks lines time overall current));
1104                                                     }
1105                                                  
1106                                                     # This is for runtime efficiency.
1107  ***      0                                         my $OFFSET = $o->get('offset');
1108  ***      0                                         my $LINES  = $o->get('lines');
1109                                                  
1110  ***      0                                         my $lines  = 0;
1111  ***      0                                         my $chunks = 0;
1112  ***      0                                         my $start  = time();
1113  ***      0                                         my $cstart = time();
1114  ***      0                                         while ( my $line = <> ) {
1115  ***      0                                            $lines++;
1116  ***      0      0      0                              next if $OFFSET && $lines < $OFFSET;
1117  ***      0      0                                     if ( $lines % $LINES == 0 ) {
1118  ***      0      0                                        close $fh or die "Can't close: $OS_ERROR";
1119                                                  
1120  ***      0      0                                        unlink($file) or die "Can't unlink $file: $OS_ERROR";
1121  ***      0      0                                        mkfifo($file, 0777) or die "Can't make fifo $file: $OS_ERROR";
1122                                                  
1123  ***      0      0                                        $fh = IO::File->new($file, '>') or die "Can't open $file: $OS_ERROR";
1124  ***      0                                               $fh->autoflush(1);
1125                                                  
1126  ***      0                                               $chunks++;
1127  ***      0                                               my $end = time();
1128  ***      0      0                                        if ( $o->get('statistics') ) {
1129  ***      0             0                                    my $overall = ($end - $start)  || 1;
1130  ***      0             0                                    my $current = ($end - $cstart) || 1;
1131  ***      0                                                  printf("%5d %9d %5d %5.2f %5.2f\n", $chunks, $lines, ($end - $start),
1132                                                                 ($lines / $overall), ($LINES / $current));
1133                                                           }
1134  ***      0                                               $cstart = $end;
1135                                                        }
1136  ***      0      0                                     print $fh $line or die "Can't print: $OS_ERROR";
1137                                                     }
1138  ***      0      0                                  close $fh or die "Can't close: $OS_ERROR";
1139                                                  
1140  ***      0      0                                  unlink($file) or die "Can't unlink $file: $OS_ERROR";
1141                                                  
1142  ***      0                                         return 0;
1143                                                  }
1144                                                  
1145                                                  sub _d {
1146  ***      0                    0                    my ($package, undef, $line) = caller 0;
1147  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
1148  ***      0                                              map { defined $_ ? $_ : 'undef' }
1149                                                          @_;
1150  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1151                                                  }
1152                                                  
1153                                                  # ############################################################################
1154                                                  # Run the program.
1155                                                  # ############################################################################
1156                                                  if ( !caller ) { exit main(@ARGV); }
1157                                                  
1158                                                  1; # Because this is a module as well as a script.
1159                                                  
1160                                                  # ############################################################################
1161                                                  # Documentation
1162                                                  # ############################################################################
1163                                                  =pod
1164                                                  
1165                                                  =head1 NAME
1166                                                  
1167                                                  mk-fifo-split - Split files and pipe lines to a fifo without really splitting.
1168                                                  
1169                                                  =head1 SYNOPSIS
1170                                                  
1171                                                  Read hugefile.txt in chunks of a million lines without physically splitting it:
1172                                                  
1173                                                   mk-fifo-split --lines 1000000 hugefile.txt
1174                                                   while [ -e /tmp/mk-fifo-split ]; do cat /tmp/mk-fifo-split; done
1175                                                  
1176                                                  =head1 RISKS
1177                                                  
1178                                                  The following section is included to inform users about the potential risks,
1179                                                  whether known or unknown, of using this tool.  The two main categories of risks
1180                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
1181                                                  tools) and those created by bugs.
1182                                                  
1183                                                  mk-fifo-split creates and/or deletes the L<"--fifo"> file.  Otherwise, no other
1184                                                  files are modified, and it merely reads lines from the file given on the
1185                                                  command-line.  It should be very low-risk.
1186                                                  
1187                                                  At the time of this release, we know of no bugs that could cause serious harm to
1188                                                  users.
1189                                                  
1190                                                  The authoritative source for updated information is always the online issue
1191                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
1192                                                  see a list of such issues at the following URL:
1193                                                  L<http://www.maatkit.org/bugs/mk-fifo-split>.
1194                                                  
1195                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
1196                                                  
1197                                                  =head1 DESCRIPTION
1198                                                  
1199                                                  mk-fifo-split lets you read from a file as though it contains only some of the
1200                                                  lines in the file.  When you read from it again, it contains the next set of
1201                                                  lines; when you have gone all the way through it, the file disappears.  This
1202                                                  works only on Unix-like operating systems.
1203                                                  
1204                                                  You can specify multiple files on the command line.  If you don't specify any,
1205                                                  or if you use the special filename C<->, lines are read from standard input.
1206                                                  
1207                                                  =head1 OPTIONS
1208                                                  
1209                                                  =over
1210                                                  
1211                                                  =item --config
1212                                                  
1213                                                  type: Array
1214                                                  
1215                                                  Read this comma-separated list of config files; if specified, this must be the
1216                                                  first option on the command line.
1217                                                  
1218                                                  =item --fifo
1219                                                  
1220                                                  type: string; default: /tmp/mk-fifo-split
1221                                                  
1222                                                  The name of the fifo from which the lines can be read.
1223                                                  
1224                                                  =item --force
1225                                                  
1226                                                  Remove the fifo if it exists already, then create it again.
1227                                                  
1228                                                  =item --help
1229                                                  
1230                                                  Show help and exit.
1231                                                  
1232                                                  =item --lines
1233                                                  
1234                                                  type: int; default: 1000
1235                                                  
1236                                                  The number of lines to read in each chunk.
1237                                                  
1238                                                  =item --offset
1239                                                  
1240                                                  type: int; default: 0
1241                                                  
1242                                                  Begin at the Nth line.  If the argument is 0, all lines are printed to the fifo.
1243                                                  If 1, then beginning at the first line, lines are printed (exactly the same as
1244                                                  0).  If 2, the first line is skipped, and the 2nd and subsequent lines are
1245                                                  printed to the fifo.
1246                                                  
1247                                                  =item --pid
1248                                                  
1249                                                  type: string
1250                                                  
1251                                                  Create the given PID file.  The file contains the process ID of the script.
1252                                                  The PID file is removed when the script exits.  Before starting, the script
1253                                                  checks if the PID file already exists.  If it does not, then the script creates
1254                                                  and writes its own PID to it.  If it does, then the script checks the following:
1255                                                  if the file contains a PID and a process is running with that PID, then
1256                                                  the script dies; or, if there is no process running with that PID, then the
1257                                                  script overwrites the file with its own PID and starts; else, if the file
1258                                                  contains no PID, then the script dies.
1259                                                  
1260                                                  =item --statistics
1261                                                  
1262                                                  Print out statistics between chunks.  The statistics are the number of chunks,
1263                                                  the number of lines, elapsed time, and lines per second overall and during the
1264                                                  last chunk.
1265                                                  
1266                                                  =item --version
1267                                                  
1268                                                  Show version and exit.
1269                                                  
1270                                                  =back
1271                                                  
1272                                                  =head1 DOWNLOADING
1273                                                  
1274                                                  You can download Maatkit from Google Code at
1275                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
1276                                                  easily with a command like the following:
1277                                                  
1278                                                     wget http://www.maatkit.org/get/toolname
1279                                                     or
1280                                                     wget http://www.maatkit.org/trunk/toolname
1281                                                  
1282                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
1283                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
1284                                                  needed.  The first URL gets the latest released version of the tool, and the
1285                                                  second gets the latest trunk code from Subversion.
1286                                                  
1287                                                  =head1 ENVIRONMENT
1288                                                  
1289                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
1290                                                  the Maatkit tools:
1291                                                  
1292                                                     MKDEBUG=1 mk-....
1293                                                  
1294                                                  =head1 SYSTEM REQUIREMENTS
1295                                                  
1296                                                  You need Perl, DBI, DBD::mysql, and some core packages that ought to be
1297                                                  installed in any reasonably new version of Perl.
1298                                                  
1299                                                  =head1 BUGS
1300                                                  
1301                                                  For list of known bugs see L<http://www.maatkit.org/bugs/mk-fifo-split>.
1302                                                  
1303                                                  Please use Google Code Issues and Groups to report bugs or request support:
1304                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
1305                                                  discuss Maatkit.
1306                                                  
1307                                                  Please include the complete command-line used to reproduce the problem you are
1308                                                  seeing, the version of all MySQL servers involved, the complete output of the
1309                                                  tool when run with L<"--version">, and if possible, debugging output produced by
1310                                                  running with the C<MKDEBUG=1> environment variable.
1311                                                  
1312                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
1313                                                  
1314                                                  This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
1315                                                  Feedback and improvements are welcome.
1316                                                  
1317                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
1318                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
1319                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
1320                                                  
1321                                                  This program is free software; you can redistribute it and/or modify it under
1322                                                  the terms of the GNU General Public License as published by the Free Software
1323                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
1324                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
1325                                                  licenses.
1326                                                  
1327                                                  You should have received a copy of the GNU General Public License along with
1328                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
1329                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
1330                                                  
1331                                                  =head1 AUTHOR
1332                                                  
1333                                                  Baron Schwartz
1334                                                  
1335                                                  =head1 ABOUT MAATKIT
1336                                                  
1337                                                  This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
1338                                                  was created by Baron Schwartz; Baron and Daniel Nichter are the primary
1339                                                  code contributors.  Both are employed by Percona.  Financial support for
1340                                                  Maatkit development is primarily provided by Percona and its clients. 
1341                                                  
1342                                                  =head1 VERSION
1343                                                  
1344                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 5425 $.
1345                                                  
1346                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
55    ***      0      0      0   unless $args{$arg}
61    ***      0      0      0   exists $args{'strict'} ? :
104   ***      0      0      0   unless open my $fh, '<', $file
124   ***      0      0      0   unless $para =~ /^=head1 OPTIONS/
129   ***      0      0      0   if $para =~ /^=over/
137   ***      0      0      0   unless $para
140   ***      0      0      0   if (my($option) = $para =~ /^=item --(.*)/)
147   ***      0      0      0   if ($para =~ /: /) { }
151   ***      0      0      0   unless $attributes{$attrib}
155   ***      0      0      0   if ($attribs{'short form'})
171   ***      0      0      0   if $para =~ /^=item/
173   ***      0      0      0   if (my($base_option) = $option =~ /^\[no\](.*)/)
178   ***      0      0      0   $attribs{'short form'} ? :
      ***      0      0      0   $attribs{'negatable'} ? :
      ***      0      0      0   $attribs{'cumulative'} ? :
      ***      0      0      0   $attribs{'type'} ? :
      ***      0      0      0   $attribs{'default'} ? :
      ***      0      0      0   $attribs{'group'} ? :
190   ***      0      0      0   unless $para
193   ***      0      0      0   if ($para =~ /^=head1/)
197   ***      0      0      0   if $para =~ /^=item --/
201   ***      0      0      0   unless @specs
212   ***      0      0      0   if (ref $opt) { }
217   ***      0      0      0   if (not $long)
222   ***      0      0      0   if exists $$self{'opts'}{$long}
225   ***      0      0      0   if (length $long == 1)
230   ***      0      0      0   if ($short) { }
231   ***      0      0      0   if exists $$self{'short_opts'}{$short}
240   ***      0      0      0   $$opt{'spec'} =~ /!/ ? :
241   ***      0      0      0   $$opt{'spec'} =~ /\+/ ? :
242   ***      0      0      0   $$opt{'desc'} =~ /required/ ? :
254   ***      0      0      0   if ($type and $type eq 'd' and not $$self{'dp'})
259   ***      0      0      0   if $type and $type =~ /[HhAadzm]/
261   ***      0      0      0   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
262   ***      0      0      0   defined $def ? :
266   ***      0      0      0   if ($long eq 'config')
270   ***      0      0      0   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
283   ***      0      0      0   if ($opt =~ /mutually exclusive|one and only one/)
288   ***      0      0      0   if ($opt =~ /at least one|one and only one/)
293   ***      0      0      0   if ($opt =~ /default to/)
298   ***      0      0      0   if ($opt =~ /restricted to option groups/)
308   ***      0      0      0   unless $rule_ok
325   ***      0      0      0   unless exists $$self{'opts'}{$long}
349   ***      0      0      0   unless exists $$self{'opts'}{$long}
369   ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***      0      0      0   exists $$self{'opts'}{$opt} ? :
374   ***      0      0      0   if ($$opt{'is_cumulative'}) { }
389   ***      0      0      0   $$self{'opts'}{$long}{'is_cumulative'} ? :
      ***      0      0      0   exists $$self{'defaults'}{$long} ? :
398   ***      0      0      0   if (@ARGV and $ARGV[0] eq '--config')
402   ***      0      0      0   if ($self->has('config'))
408   ***      0      0      0   if ($EVAL_ERROR)
409   ***      0      0      0   $self->got('config') ? :
424   ***      0      0      0   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
427   ***      0      0      0   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
428   ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
434   ***      0      0      0   if (@ARGV and $$self{'strict'})
440   ***      0      0      0   if (@set > 1)
451   ***      0      0      0   if (@set == 0)
461   ***      0      0      0   if ($$opt{'got'}) { }
      ***      0      0      0   elsif ($$opt{'is_required'}) { }
462   ***      0      0      0   if (exists $$self{'disables'}{$long})
469   ***      0      0      0   if (exists $$self{'allowed_groups'}{$long})
481   ***      0      0      0   if $restricted_opt eq $long
482   ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
487   ***      0      0      0   if (@restricted_opts)
489   ***      0      0      0   if (@restricted_opts == 1) { }
518   ***      0      0      0   unless $opt and $$opt{'type'}
521   ***      0      0      0   if ($val and $$opt{'type'} eq 'm') { }
      ***      0      0      0   elsif ($val and $$opt{'type'} eq 'd') { }
      ***      0      0      0   elsif ($val and $$opt{'type'} eq 'z') { }
      ***      0      0      0   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
      ***      0      0      0   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
524   ***      0      0      0   if (not $suffix)
530   ***      0      0      0   if ($suffix =~ /[smhd]/) { }
531   ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
546   ***      0      0      0   if ($from_key)
557   ***      0      0      0   if (defined $num) { }
558   ***      0      0      0   if ($factor)
585   ***      0      0      0   length $opt == 1 ? :
586   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
593   ***      0      0      0   length $opt == 1 ? :
594   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
601   ***      0      0      0   length $opt == 1 ? :
602   ***      0      0      0   defined $long ? :
607   ***      0      0      0   length $opt == 1 ? :
608   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
642   ***      0      0      0   if ($$self{'opts'}{'help'}{'got'}) { }
      ***      0      0      0   elsif (scalar @{$$self{'errors'};}) { }
643   ***      0      0      0   unless print $self->print_usage
647   ***      0      0      0   unless print $self->print_errors
656   ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
665   ***      0      0      0   unless $$self{'got_opts'}
668   ***      0      0      0   $$_{'is_negatable'} ? :
672   ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
688   ***      0      0      0   $group eq 'default' ? :
694   ***      0      0      0   $$opt{'is_negatable'} ? :
697   ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
706   ***      0      0      0   if ($short) { }
715   ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
719   ***      0      0      0   if ($$self{'dp'})
727   ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
739   ***      0      0      0   if ref $_[0] eq 'OptionParser'
742   ***      0      0      0   unless print $prompt
750   ***      0      0      0   unless print "\n"
753   ***      0      0      0   if ($EVAL_ERROR)
775   ***      0      0      0   unless open my $fh, '<', $filename
783   ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
786   ***      0      0      0   if ($line eq '--')
791   ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
809   ***      0      0      0   unless open my $fh, '<', $file
813   ***      0      0      0   unless $para =~ /^=pod$/m
817   ***      0      0      0   unless $para =~ /$regex/
822   ***      0      0      0   unless close $fh
836   ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
851   ***      0      0      0   defined $_ ? :
880   ***      0      0      0   unless $args{$arg}
883   ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
899   ***      0      0      0   unless defined(my $pid = fork)
900   ***      0      0      0   if ($pid)
907   ***      0      0      0   unless POSIX::setsid()
908   ***      0      0      0   unless chdir '/'
914   ***      0      0      0   if (-t STDIN)
916   ***      0      0      0   unless open STDIN, '/dev/null'
920   ***      0      0      0   if ($$self{'log_file'}) { }
922   ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
926   ***      0      0      0   unless open STDERR, '>&STDOUT'
930   ***      0      0      0   if (-t STDOUT)
932   ***      0      0      0   unless open STDOUT, '>', '/dev/null'
935   ***      0      0      0   if (-t STDERR)
937   ***      0      0      0   unless open STDERR, '>', '/dev/null'
948   ***      0      0      0   $self ? :
950   ***      0      0      0   if ($PID_file and -f $PID_file) { }
953   ***      0      0      0   if $EVAL_ERROR
955   ***      0      0      0   if ($pid) { }
957   ***      0      0      0   if ($pid_is_alive) { }
979   ***      0      0      0   if (exists $$self{'child'})
991   ***      0      0      0   if (not $PID_file)
998   ***      0      0      0   unless open my $PID_FH, '>', $PID_file
1000  ***      0      0      0   unless print $PID_FH $PID
1002  ***      0      0      0   unless close $PID_FH
1011  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
1012  ***      0      0      0   unless unlink $$self{'PID_file'}
1024  ***      0      0      0   if $$self{'child'} or $$self{'rm_PID_file'}
1030  ***      0      0      0   defined $_ ? :
1073  ***      0      0      0   if (not $o->get('lines') or $o->get('lines') <= 0)
1082  ***      0      0      0   if ($o->get('pid'))
1092  ***      0      0      0   if ($o->get('force') and -e $file)
1093  ***      0      0      0   unless unlink $file
1095  ***      0      0      0   unless mkfifo($file, 511)
1099  ***      0      0      0   unless $fh = 'IO::File'->new($file, '>')
1102  ***      0      0      0   if ($o->get('statistics'))
1116  ***      0      0      0   if $OFFSET and $lines < $OFFSET
1117  ***      0      0      0   if ($lines % $LINES == 0)
1118  ***      0      0      0   unless close $fh
1120  ***      0      0      0   unless unlink $file
1121  ***      0      0      0   unless mkfifo($file, 511)
1123  ***      0      0      0   unless $fh = 'IO::File'->new($file, '>')
1128  ***      0      0      0   if ($o->get('statistics'))
1136  ***      0      0      0   unless print $fh $line
1138  ***      0      0      0   unless close $fh
1140  ***      0      0      0   unless unlink $file
1147  ***      0      0      0   defined $_ ? :


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
254   ***      0      0      0      0   $type and $type eq 'd'
      ***      0      0      0      0   $type and $type eq 'd' and not $$self{'dp'}
259   ***      0      0      0      0   $type and $type =~ /[HhAadzm]/
398   ***      0      0      0      0   @ARGV and $ARGV[0] eq '--config'
427   ***      0      0      0      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
434   ***      0      0      0      0   @ARGV and $$self{'strict'}
518   ***      0      0      0      0   $opt and $$opt{'type'}
521   ***      0      0      0      0   $val and $$opt{'type'} eq 'm'
      ***      0      0      0      0   $val and $$opt{'type'} eq 'd'
      ***      0      0      0      0   $val and $$opt{'type'} eq 'z'
      ***      0      0      0      0   defined $val and $$opt{'type'} eq 'h'
      ***      0      0      0      0   defined $val and $$opt{'type'} eq 'a'
586   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
594   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
608   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
697   ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
791   ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
950   ***      0      0      0      0   $PID_file and -f $PID_file
1011  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
1092  ***      0      0      0      0   $o->get('force') and -e $file
1116  ***      0      0      0      0   $OFFSET and $lines < $OFFSET

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
39    ***     50      0      1   $ENV{'MKDEBUG'} || 0
59    ***      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
61    ***      0      0      0   $args{'prompt'} || '<options>'
      ***      0      0      0   $args{'dp'} || undef
103   ***      0      0      0   $file ||= '/home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split'
244   ***      0      0      0   $$opt{'group'} ||= 'default'
526   ***      0      0      0   $s || 's'
535   ***      0      0      0   $prefix || ''
563   ***      0      0      0   $pre || ''
570   ***      0      0      0   $val || ''
573   ***      0      0      0   $val || ''
631   ***      0      0      0   $$self{'description'} || ''
699   ***      0      0      0   $s ||= 's'
725   ***      0      0      0   $$opt{'type'} || ''
875   ***     50      0      1   $ENV{'MKDEBUG'} || 0
1056  ***     50      0      1   $ENV{'MKDEBUG'} || 0
1129  ***      0      0      0   $end - $start || 1
1130  ***      0      0      0   $end - $cstart || 1

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
58    ***      0      0      0      0   $program_name ||= $PROGRAM_NAME
59    ***      0      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***      0      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
521   ***      0      0      0      0   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***      0      0      0      0   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
1024  ***      0      0      0      0   $$self{'child'} or $$self{'rm_PID_file'}
1073  ***      0      0      0      0   not $o->get('lines') or $o->get('lines') <= 0


Covered Subroutines
-------------------

Subroutine         Count Location                                                 
------------------ ----- ---------------------------------------------------------
BEGIN                  1 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:1052
BEGIN                  1 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:1053
BEGIN                  1 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:1054
BEGIN                  1 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:1056
BEGIN                  1 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:20  
BEGIN                  1 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:21  
BEGIN                  1 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:32  
BEGIN                  1 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:33  
BEGIN                  1 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:35  
BEGIN                  1 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:36  
BEGIN                  1 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:37  
BEGIN                  1 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:39  
BEGIN                  1 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:869 
BEGIN                  1 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:870 
BEGIN                  1 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:872 
BEGIN                  1 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:873 
BEGIN                  1 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:875 

Uncovered Subroutines
---------------------

Subroutine         Count Location                                                 
------------------ ----- ---------------------------------------------------------
DESTROY                0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:1023
__ANON__               0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:422 
_d                     0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:1029
_d                     0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:1146
_d                     0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:850 
_get_participants      0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:322 
_make_PID_file         0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:988 
_parse_specs           0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:208 
_pod_to_specs          0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:102 
_read_config_file      0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:774 
_remove_PID_file       0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:1010
_set_option            0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:368 
_validate_type         0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:517 
check_PID_file         0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:947 
clone                  0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:827 
daemonize              0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:896 
descr                  0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:630 
errors                 0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:620 
get                    0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:584 
get_defaults           0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:358 
get_defaults_files     0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:97  
get_groups             0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:363 
get_opts               0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:385 
get_specs              0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:90  
got                    0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:592 
has                    0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:600 
main                   0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:1059
make_PID_file          0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:978 
new                    0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:53  
new                    0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:878 
opts                   0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:334 
print_errors           0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:654 
print_usage            0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:664 
prompt                 0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:625 
prompt_noecho          0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:739 
read_para_after        0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:808 
save_error             0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:615 
set                    0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:606 
set_defaults           0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:346 
short_opts             0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:340 
usage_or_errors        0 /home/daniel/dev/maatkit/mk-fifo-split/mk-fifo-split:641 


mk-fifo-split.t

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     BEGIN {
4     ***      1     50     33      1            31      die "The MAATKIT_TRUNK environment variable is not set.  See http://code.google.com/p/maatkit/wiki/Testing"
5                                                           unless $ENV{MAATKIT_TRUNK} && -d $ENV{MAATKIT_TRUNK};
6              1                                  8      unshift @INC, "$ENV{MAATKIT_TRUNK}/common";
7                                                     };
8                                                     
9              1                    1            12   use strict;
               1                                  2   
               1                                  5   
10             1                    1             6   use warnings FATAL => 'all';
               1                                  3   
               1                                  6   
11             1                    1            10   use English qw(-no_match_vars);
               1                                  2   
               1                                 26   
12             1                    1            10   use Test::More tests => 4;
               1                                  3   
               1                                 10   
13                                                    
14             1                    1            18   use MaatkitTest;
               1                                  4   
               1                                 11   
15             1                                 22   require "$trunk/mk-fifo-split/mk-fifo-split";
16                                                    
17             1                                 38   unlink('/tmp/mk-fifo-split');
18                                                    
19             1                                  6   my $cmd = "$trunk/mk-fifo-split/mk-fifo-split";
20                                                    
21             1                              76404   my $output = `$cmd --help`;
22             1                                 80   like($output, qr/Options and values/, 'It lives');
23                                                    
24             1                               6106   system("($cmd --lines 10000 $trunk/mk-fifo-split/mk-fifo-split > /dev/null 2>&1 < /dev/null)&");
25             1                             1000161   sleep(1);
26                                                    
27    ***      1     50                         348   open my $fh, '<', '/tmp/mk-fifo-split' or die $OS_ERROR;
28             1                                 14   my $contents = do { local $INPUT_RECORD_SEPARATOR; <$fh>; };
               1                                 35   
               1                              20633   
29             1                                 29   close $fh;
30                                                    
31    ***      1     50                          48   open my $fh2, '<', "$trunk/mk-fifo-split/mk-fifo-split" or die $OS_ERROR;
32             1                                  5   my $contents2 = do { local $INPUT_RECORD_SEPARATOR; <$fh2>; };
               1                                496   
               1                                168   
33             1                                 12   close $fh2;
34                                                    
35             1                                286   ok($contents eq $contents2, 'I read the file');
36                                                    
37             1                              10800   system("($cmd $trunk/mk-fifo-split/t/file_with_lines --offset 2 > /dev/null 2>&1 < /dev/null)&");
38             1                             1000163   sleep(1);
39                                                    
40    ***      1     50                         117   open $fh, '<', '/tmp/mk-fifo-split' or die $OS_ERROR;
41             1                                 17   $contents = do { local $INPUT_RECORD_SEPARATOR; <$fh>; };
               1                                 28   
               1                              23381   
42             1                                 19   close $fh;
43                                                    
44             1                                 41   is($contents, <<EOF
45                                                         2	hi
46                                                         3	there
47                                                         4	b
48                                                         5	c
49                                                         6	d
50                                                    EOF
51                                                    , 'Offset works');
52                                                    
53                                                    # #########################################################################
54                                                    # Issue 391: Add --pid option to all scripts
55                                                    # #########################################################################
56             1                               8648   `touch /tmp/mk-script.pid`;
57             1                             117680   $output = `$cmd --pid /tmp/mk-script.pid 2>&1`;
58             1                                 55   like(
59                                                       $output,
60                                                       qr{PID file /tmp/mk-script.pid already exists},
61                                                       'Dies if PID file already exists (issue 391)'
62                                                    );
63             1                               3204   `rm -rf /tmp/mk-script.pid`;
64                                                    
65                                                    # #############################################################################
66                                                    # Done.
67                                                    # #############################################################################
68             1                                 10   exit;


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
4     ***     50      0      1   unless $ENV{'MAATKIT_TRUNK'} and -d $ENV{'MAATKIT_TRUNK'}
27    ***     50      0      1   unless open my $fh, '<', '/tmp/mk-fifo-split'
31    ***     50      0      1   unless open my $fh2, '<', "$trunk/mk-fifo-split/mk-fifo-split"
40    ***     50      0      1   unless open $fh, '<', '/tmp/mk-fifo-split'


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
4     ***     33      0      0      1   $ENV{'MAATKIT_TRUNK'} and -d $ENV{'MAATKIT_TRUNK'}


Covered Subroutines
-------------------

Subroutine Count Location          
---------- ----- ------------------
BEGIN          1 mk-fifo-split.t:10
BEGIN          1 mk-fifo-split.t:11
BEGIN          1 mk-fifo-split.t:12
BEGIN          1 mk-fifo-split.t:14
BEGIN          1 mk-fifo-split.t:4 
BEGIN          1 mk-fifo-split.t:9 


