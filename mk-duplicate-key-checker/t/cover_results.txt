----------------------------------- ------ ------ ------ ------ ------ ------
File                                  stmt   bran   cond    sub   time  total
----------------------------------- ------ ------ ------ ------ ------ ------
...checker/mk-duplicate-key-checker   55.0   33.8   24.6   65.5  100.0   47.5
Total                                 55.0   33.8   24.6   65.5  100.0   47.5
----------------------------------- ------ ------ ------ ------ ------ ------


Run:          ../mk-duplicate-key-checker
Perl version: 5.8.8
OS:           linux
Start:        Sat Mar  7 22:42:15 2009
Finish:       Sat Mar  7 22:42:15 2009

Run:          ../mk-duplicate-key-checker
Perl version: 5.8.8
OS:           linux
Start:        Sat Mar  7 22:42:19 2009
Finish:       Sat Mar  7 22:42:19 2009

Run:          ../mk-duplicate-key-checker
Perl version: 5.8.8
OS:           linux
Start:        Sat Mar  7 22:42:22 2009
Finish:       Sat Mar  7 22:42:22 2009

Run:          ../mk-duplicate-key-checker
Perl version: 5.8.8
OS:           linux
Start:        Sat Mar  7 22:42:25 2009
Finish:       Sat Mar  7 22:42:25 2009

Run:          ../mk-duplicate-key-checker
Perl version: 5.8.8
OS:           linux
Start:        Sat Mar  7 22:42:28 2009
Finish:       Sat Mar  7 22:42:28 2009

Run:          ../mk-duplicate-key-checker
Perl version: 5.8.8
OS:           linux
Start:        Sat Mar  7 22:42:32 2009
Finish:       Sat Mar  7 22:42:32 2009

Run:          ../mk-duplicate-key-checker
Perl version: 5.8.8
OS:           linux
Start:        Sat Mar  7 22:42:35 2009
Finish:       Sat Mar  7 22:42:35 2009

/home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker

line  err   stmt   bran   cond    sub   time   code
1                                              #!/usr/bin/env perl
2                                              
3                                              # This is mk-duplicate-key-checker, a program to analyze MySQL tables for
4                                              # duplicated or redundant indexes and foreign key constraints.
5                                              # 
6                                              # This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
7                                              # Feedback and improvements are welcome.
8                                              #
9                                              # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
10                                             # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
11                                             # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
12                                             #
13                                             # This program is free software; you can redistribute it and/or modify it under
14                                             # the terms of the GNU General Public License as published by the Free Software
15                                             # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
16                                             # systems, you can issue `man perlgpl' or `man perlartistic' to read these
17                                             # licenses.
18                                             #
19                                             # You should have received a copy of the GNU General Public License along with
20                                             # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
21                                             # Place, Suite 330, Boston, MA  02111-1307  USA.
22                                             
23             7                    7    135   use strict;
               7                          21   
               7                          42   
24             7                    7     50   use warnings FATAL => 'all';
               7                          14   
               7                          45   
25                                             
26             7                          47   our $VERSION = '@VERSION@';
27             7                          29   our $DISTRIB = '@DISTRIB@';
28             7                         110   our $SVN_REV = sprintf("%d", (q$Revision: 3098 $ =~ m/(\d+)/g, 0));
29                                             
30                                             # ###########################################################################
31                                             # VersionParser package 2801
32                                             # ###########################################################################
33             7                    7     48   use strict;
               7                          16   
               7                          28   
34             7                    7     56   use warnings FATAL => 'all';
               7                          26   
               7                          33   
35                                             
36                                             package VersionParser;
37                                             
38             7                    7     98   use English qw(-no_match_vars);
               7                          21   
               7                          47   
39                                             
40             7                    7     65   use constant MKDEBUG => $ENV{MKDEBUG};
               7                          21   
               7                          63   
41                                             
42                                             sub new {
43             7                    7     33      my ( $class ) = @_;
44             7                          40      bless {}, $class;
45                                             }
46                                             
47                                             sub parse {
48             7                    7    944      my ( $self, $str ) = @_;
49             7                         113      my $result = sprintf('%03d%03d%03d', $str =~ m/(\d+)/g);
50             7                          25      MKDEBUG && _d("$str parses to $result");
51             7                          35      return $result;
52                                             }
53                                             
54                                             sub version_ge {
55    ***      0                    0      0      my ( $self, $dbh, $target ) = @_;
56    ***      0      0                    0      if ( !$self->{$dbh} ) {
57    ***      0                           0         $self->{$dbh} = $self->parse(
58                                                      $dbh->selectrow_array('SELECT VERSION()'));
59                                                }
60    ***      0      0                    0      my $result = $self->{$dbh} ge $self->parse($target) ? 1 : 0;
61    ***      0                           0      MKDEBUG && _d("$self->{$dbh} ge $target: $result");
62    ***      0                           0      return $result;
63                                             }
64                                             
65                                             sub _d {
66    ***      0                    0      0      my ($package, undef, $line) = caller 0;
67    ***      0      0                    0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                           0   
      ***      0                           0   
68    ***      0                           0           map { defined $_ ? $_ : 'undef' }
69                                                     @_;
70    ***      0                           0      print "# $package:$line $$ ", @_, "\n";
71                                             }
72                                             
73             7                          21   1;
74                                             
75                                             # ###########################################################################
76                                             # End VersionParser package
77                                             # ###########################################################################
78                                             
79                                             # ###########################################################################
80                                             # Quoter package 3085
81                                             # ###########################################################################
82             7                    7     51   use strict;
               7                          18   
               7                          45   
83             7                    7     46   use warnings FATAL => 'all';
               7                          16   
               7                          35   
84                                             
85                                             package Quoter;
86                                             
87             7                    7     43   use English qw(-no_match_vars);
               7                          19   
               7                          30   
88                                             
89             7                    7     48   use constant MKDEBUG => $ENV{MKDEBUG};
               7                          18   
               7                          41   
90                                             
91                                             sub new {
92             7                    7     28      my ( $class ) = @_;
93             7                          34      bless {}, $class;
94                                             }
95                                             
96                                             sub quote {
97            22                   22    108      my ( $self, @vals ) = @_;
98            22                          91      foreach my $val ( @vals ) {
99            32                         157         $val =~ s/`/``/g;
100                                               }
101           22                         101      return join('.', map { '`' . $_ . '`' } @vals);
              32                         218   
102                                            }
103                                            
104                                            sub quote_val {
105   ***      0                    0      0      my ( $self, @vals ) = @_;
106                                               return join(', ',
107                                                  map {
108   ***      0      0                    0            if ( defined $_ ) {
      ***      0                           0   
109   ***      0                           0               $_ =~ s/(['\\])/\\$1/g;
110   ***      0      0      0             0               $_ eq '' || $_ =~ m/^0|\D/ ? "'$_'" : $_;
111                                                     }
112                                                     else {
113   ***      0                           0               'NULL';
114                                                     }
115                                                  } @vals
116                                               );
117                                            }
118                                            
119                                            sub split_unquote {
120   ***      0                    0      0      my ( $self, $db_tbl, $default_db ) = @_;
121   ***      0                           0      $db_tbl =~ s/`//g;
122   ***      0                           0      my ( $db, $tbl ) = split(/[.]/, $db_tbl);
123   ***      0      0                    0      if ( !$tbl ) {
124   ***      0                           0         $tbl = $db;
125   ***      0                           0         $db  = $default_db;
126                                               }
127   ***      0                           0      return ($db, $tbl);
128                                            }
129                                            
130            7                          19   1;
131                                            
132                                            # ###########################################################################
133                                            # End Quoter package
134                                            # ###########################################################################
135                                            
136                                            # ###########################################################################
137                                            # TableParser package 3075
138                                            # ###########################################################################
139                                            package TableParser;
140                                            
141            7                    7     83   use strict;
               7                          24   
               7                          36   
142            7                    7     42   use warnings FATAL => 'all';
               7                          18   
               7                          30   
143            7                    7     43   use English qw(-no_match_vars);
               7                          15   
               7                          32   
144                                            
145            7                    7     48   use constant MKDEBUG => $ENV{MKDEBUG};
               7                          17   
               7                          42   
146                                            
147                                            sub new {
148            7                    7     28      my ( $class ) = @_;
149            7                          39      return bless {}, $class;
150                                            }
151                                            
152                                            
153                                            sub parse {
154            9                    9     43      my ( $self, $ddl, $opts ) = @_;
155                                            
156            9    100                   57      if ( ref $ddl eq 'ARRAY' ) {
157   ***      6     50                   38         if ( lc $ddl->[0] eq 'table' ) {
158            6                          26            $ddl = $ddl->[1];
159                                                  }
160                                                  else {
161                                                     return {
162   ***      0                           0               engine => 'VIEW',
163                                                     };
164                                                  }
165                                               }
166                                            
167   ***      9     50                   80      if ( $ddl !~ m/CREATE (?:TEMPORARY )?TABLE `/ ) {
168   ***      0                           0         die "Cannot parse table definition; is ANSI quoting "
169                                                     . "enabled or SQL_QUOTE_SHOW_CREATE disabled?";
170                                               }
171                                            
172            9                         253      $ddl =~ s/(`[^`]+`)/\L$1/g;
173                                            
174            9                          56      my $engine = $self->get_engine($ddl);
175                                            
176            9                         239      my @defs   = $ddl =~ m/^(\s+`.*?),?$/gm;
177            9                          37      my @cols   = map { $_ =~ m/`([^`]+)`/g } @defs;
              34                         161   
178            9                          30      MKDEBUG && _d('Columns: ' . join(', ', @cols));
179                                            
180            9                          24      my %def_for;
181            9                          60      @def_for{@cols} = @defs;
182                                            
183            9                          29      my (@nums, @null);
184            9                          30      my (%type_for, %is_nullable, %is_numeric, %is_autoinc);
185            9                          37      foreach my $col ( @cols ) {
186           34                         115         my $def = $def_for{$col};
187           34                         176         my ( $type ) = $def =~ m/`[^`]+`\s([a-z]+)/;
188   ***     34     50                  156         die "Can't determine column type for $def" unless $type;
189           34                         112         $type_for{$col} = $type;
190           34    100                  214         if ( $type =~ m/(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/ ) {
191           19                          62            push @nums, $col;
192           19                          67            $is_numeric{$col} = 1;
193                                                  }
194           34    100                  163         if ( $def !~ m/NOT NULL/ ) {
195           20                          64            push @null, $col;
196           20                          65            $is_nullable{$col} = 1;
197                                                  }
198   ***     34     50                  203         $is_autoinc{$col} = $def =~ m/AUTO_INCREMENT/i ? 1 : 0;
199                                               }
200                                            
201            9                          52      my $keys = $self->get_keys($ddl, $opts, \%is_nullable);
202                                            
203                                               return {
204           34                         163         cols           => \@cols,
205           34                         273         col_posn       => { map { $cols[$_] => $_ } 0..$#cols },
206            9                          75         is_col         => { map { $_ => 1 } @cols },
207                                                  null_cols      => \@null,
208                                                  is_nullable    => \%is_nullable,
209                                                  is_autoinc     => \%is_autoinc,
210                                                  keys           => $keys,
211                                                  defs           => \%def_for,
212                                                  numeric_cols   => \@nums,
213                                                  is_numeric     => \%is_numeric,
214                                                  engine         => $engine,
215                                                  type_for       => \%type_for,
216                                               };
217                                            }
218                                            
219                                            sub sort_indexes {
220   ***      0                    0      0      my ( $self, $tbl ) = @_;
221                                            
222                                               my @indexes
223   ***      0                           0         = sort {
224   ***      0                           0            (($a ne 'PRIMARY') <=> ($b ne 'PRIMARY'))
225                                                     || ( !$tbl->{keys}->{$a}->{is_unique} <=> !$tbl->{keys}->{$b}->{is_unique} )
226                                                     || ( $tbl->{keys}->{$a}->{is_nullable} <=> $tbl->{keys}->{$b}->{is_nullable} )
227   ***      0      0      0             0            || ( scalar(@{$tbl->{keys}->{$a}->{cols}}) <=> scalar(@{$tbl->{keys}->{$b}->{cols}}) )
      ***      0             0             0   
228                                                  }
229                                                  grep {
230   ***      0                           0            $tbl->{keys}->{$_}->{type} eq 'BTREE'
231                                                  }
232   ***      0                           0         sort keys %{$tbl->{keys}};
233                                            
234   ***      0                           0      MKDEBUG && _d('Indexes sorted best-first: ' . join(', ', @indexes));
235   ***      0                           0      return @indexes;
236                                            }
237                                            
238                                            sub find_best_index {
239   ***      0                    0      0      my ( $self, $tbl, $index ) = @_;
240   ***      0                           0      my $best;
241   ***      0      0                    0      if ( $index ) {
242   ***      0                           0         ($best) = grep { uc $_ eq uc $index } keys %{$tbl->{keys}};
      ***      0                           0   
      ***      0                           0   
243                                               }
244   ***      0      0                    0      if ( !$best ) {
245   ***      0      0                    0         if ( $index ) {
246   ***      0                           0            die "Index '$index' does not exist in table";
247                                                  }
248                                                  else {
249   ***      0                           0            ($best) = $self->sort_indexes($tbl);
250                                                  }
251                                               }
252   ***      0                           0      MKDEBUG && _d("Best index found is " . ($best || 'undef'));
253   ***      0                           0      return $best;
254                                            }
255                                            
256                                            sub find_possible_keys {
257   ***      0                    0      0      my ( $self, $dbh, $database, $table, $quoter, $where ) = @_;
258   ***      0      0                    0      return () unless $where;
259   ***      0                           0      my $sql = 'EXPLAIN SELECT * FROM ' . $quoter->quote($database, $table)
260                                                  . ' WHERE ' . $where;
261   ***      0                           0      MKDEBUG && _d($sql);
262   ***      0                           0      my $expl = $dbh->selectrow_hashref($sql);
263   ***      0                           0      $expl = { map { lc($_) => $expl->{$_} } keys %$expl };
      ***      0                           0   
264   ***      0      0                    0      if ( $expl->{possible_keys} ) {
265   ***      0                           0         MKDEBUG && _d("possible_keys=$expl->{possible_keys}");
266   ***      0                           0         my @candidates = split(',', $expl->{possible_keys});
267   ***      0                           0         my %possible   = map { $_ => 1 } @candidates;
      ***      0                           0   
268   ***      0      0                    0         if ( $expl->{key} ) {
269   ***      0                           0            MKDEBUG && _d("MySQL chose $expl->{key}");
270   ***      0                           0            unshift @candidates, grep { $possible{$_} } split(',', $expl->{key});
      ***      0                           0   
271   ***      0                           0            MKDEBUG && _d('Before deduping: ' . join(', ', @candidates));
272   ***      0                           0            my %seen;
273   ***      0                           0            @candidates = grep { !$seen{$_}++ } @candidates;
      ***      0                           0   
274                                                  }
275   ***      0                           0         MKDEBUG && _d('Final list: ' . join(', ', @candidates));
276   ***      0                           0         return @candidates;
277                                               }
278                                               else {
279   ***      0                           0         MKDEBUG && _d('No keys in possible_keys');
280   ***      0                           0         return ();
281                                               }
282                                            }
283                                            
284                                            sub table_exists {
285   ***      0                    0      0      my ( $self, $dbh, $db, $tbl, $q, $can_insert ) = @_;
286   ***      0                           0      my $db_tbl = $q->quote($db, $tbl);
287   ***      0      0                    0      my $sql    = $can_insert ? "REPLACE INTO $db_tbl " : '';
288   ***      0                           0      $sql      .= "SELECT * FROM $db_tbl LIMIT 0";
289   ***      0                           0      MKDEBUG && _d("table_exists check for $db_tbl: $sql");
290   ***      0                           0      eval { $dbh->do($sql); };
      ***      0                           0   
291   ***      0                           0      MKDEBUG && _d("eval error (if any): $EVAL_ERROR");
292   ***      0      0                    0      return 0 if $EVAL_ERROR;
293   ***      0                           0      return 1;
294                                            }
295                                            
296                                            sub get_engine {
297           30                   30    119      my ( $self, $ddl, $opts ) = @_;
298           30                         501      my ( $engine ) = $ddl =~ m/\).*?(?:ENGINE|TYPE)=(\w+)/;
299           30                          78      MKDEBUG && _d('Storage engine: ', $engine || 'unknown');
300   ***     30            50           192      return $engine || undef;
301                                            }
302                                            
303                                            sub get_keys {
304           15                   15     70      my ( $self, $ddl, $opts, $is_nullable ) = @_;
305           15                          57      my $engine = $self->get_engine($ddl);
306           15                          50      my $keys   = {};
307                                            
308                                               KEY:
309           15                         175      foreach my $key ( $ddl =~ m/^  ((?:[A-Z]+ )?KEY .*)$/gm ) {
310                                            
311   ***     26     50                  131         next KEY if $key =~ m/FOREIGN/;
312                                            
313           26                          60         MKDEBUG && _d("Parsed key: $key");
314                                            
315   ***     26     50                  152         if ( $engine !~ m/MEMORY|HEAP/ ) {
316           26                          84            $key =~ s/USING HASH/USING BTREE/;
317                                                  }
318                                            
319           26                         163         my ( $type, $cols ) = $key =~ m/(?:USING (\w+))? \((.+)\)/;
320           26                         171         my ( $special ) = $key =~ m/(FULLTEXT|SPATIAL)/;
321   ***     26            33           385         $type = $type || $special || 'BTREE';
      ***                   50                 
322   ***     26     50     33           230         if ( $opts->{mysql_version} && $opts->{mysql_version} lt '004001000'
      ***                   33                 
323                                                     && $engine =~ m/HEAP|MEMORY/i )
324                                                  {
325   ***      0                           0            $type = 'HASH'; # MySQL pre-4.1 supports only HASH indexes on HEAP
326                                                  }
327                                            
328           26                         138         my ($name) = $key =~ m/(PRIMARY|`[^`]*`)/;
329           26    100                  153         my $unique = $key =~ m/PRIMARY|UNIQUE/ ? 1 : 0;
330           26                          65         my @cols;
331           26                          68         my @col_prefixes;
332           26                         136         foreach my $col_def ( split(',', $cols) ) {
333           53                         283            my ($name, $prefix) = $col_def =~ m/`([^`]+)`(?:\((\d+)\))?/;
334           53                         185            push @cols, $name;
335           53                         210            push @col_prefixes, $prefix;
336                                                  }
337           26                         111         $name =~ s/`//g;
338                                            
339           26                          63         MKDEBUG && _d("Key $name cols: " . join(', ', @cols));
340                                            
341           53                         228         $keys->{$name} = {
342                                                     name         => $name,
343                                                     type         => $type,
344                                                     colnames     => $cols,
345                                                     cols         => \@cols,
346                                                     col_prefixes => \@col_prefixes,
347                                                     is_unique    => $unique,
348           53                         423            is_nullable  => scalar(grep { $is_nullable->{$_} } @cols),
349           26                         145            is_col       => { map { $_ => 1 } @cols },
350                                                  };
351                                               }
352                                            
353           15                          71      return $keys;
354                                            }
355                                            
356                                            sub get_fks {
357            6                    6     29      my ( $self, $ddl, $opts ) = @_;
358            6                          23      my $fks = {};
359                                            
360            6                          40      foreach my $fk (
361                                                  $ddl =~ m/CONSTRAINT .* FOREIGN KEY .* REFERENCES [^\)]*\)/mg )
362                                               {
363   ***      0                           0         my ( $name )   = $fk =~ m/CONSTRAINT `(.*?)`/;
364   ***      0                           0         my ( $fkcols ) = $fk =~ m/\(([^\)]+)\)/;
365   ***      0                           0         my ( $cols )   = $fk =~ m/REFERENCES.*?\(([^\)]+)\)/;
366   ***      0                           0         my ( $parent ) = $fk =~ m/REFERENCES (\S+) /;
367                                            
368   ***      0      0      0             0         if ( $parent !~ m/\./ && $opts->{database} ) {
369   ***      0                           0            $parent = "`$opts->{database}`.$parent";
370                                                  }
371                                            
372   ***      0                           0         $fks->{$name} = {
373                                                     name   => $name,
374                                                     parent => $parent,
375                                                     cols   => $cols,
376                                                     fkcols => $fkcols,
377                                                  };
378                                               }
379                                            
380            6                          24      return $fks;
381                                            }
382                                            
383                                            sub _d {
384   ***      0                    0      0      my ($package, undef, $line) = caller 0;
385   ***      0      0                    0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                           0   
      ***      0                           0   
386   ***      0                           0           map { defined $_ ? $_ : 'undef' }
387                                                    @_;
388   ***      0                           0      print "# $package:$line $$ ", @_, "\n";
389                                            }
390                                            
391            7                          18   1;
392                                            
393                                            # ###########################################################################
394                                            # End TableParser package
395                                            # ###########################################################################
396                                            
397                                            # ###########################################################################
398                                            # MySQLDump package 2889
399                                            # ###########################################################################
400                                            package MySQLDump;
401                                            
402            7                    7     61   use strict;
               7                          19   
               7                          37   
403            7                    7     52   use warnings FATAL => 'all';
               7                          41   
               7                          41   
404                                            
405            7                    7     45   use English qw(-no_match_vars);
               7                          16   
               7                          37   
406                                            
407            7                    7     52   use constant MKDEBUG => $ENV{MKDEBUG};
               7                          19   
               7                          52   
408                                            
409            7                          90   ( our $before = <<'EOF') =~ s/^   //gm;
410                                               /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
411                                               /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
412                                               /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
413                                               /*!40101 SET NAMES utf8 */;
414                                               /*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
415                                               /*!40103 SET TIME_ZONE='+00:00' */;
416                                               /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
417                                               /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
418                                               /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
419                                               /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
420                                            EOF
421                                            
422            7                          56   ( our $after = <<'EOF') =~ s/^   //gm;
423                                               /*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;
424                                               /*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
425                                               /*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
426                                               /*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
427                                               /*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
428                                               /*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
429                                               /*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
430                                               /*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
431                                            EOF
432                                            
433                                            sub new {
434            7                    7     31      my ( $class, %args ) = @_;
435   ***      7     50                   58      $args{cache} = 1 unless defined $args{cache};
436            7                          31      my $self = bless \%args, $class;
437            7                          35      return $self;
438                                            }
439                                            
440                                            sub dump {
441   ***      0                    0      0      my ( $self, $dbh, $quoter, $db, $tbl, $what ) = @_;
442                                            
443   ***      0      0                    0      if ( $what eq 'table' ) {
      ***             0                        
      ***             0                        
444   ***      0                           0         my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
445   ***      0      0                    0         if ( $ddl->[0] eq 'table' ) {
446   ***      0                           0            return $before
447                                                        . 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
448                                                        . $ddl->[1] . ";\n";
449                                                  }
450                                                  else {
451   ***      0                           0            return 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
452                                                        . '/*!50001 DROP VIEW IF EXISTS '
453                                                        . $quoter->quote($tbl) . "*/;\n/*!50001 "
454                                                        . $self->get_tmp_table($dbh, $quoter, $db, $tbl) . "*/;\n";
455                                                  }
456                                               }
457                                               elsif ( $what eq 'triggers' ) {
458   ***      0                           0         my $trgs = $self->get_triggers($dbh, $quoter, $db, $tbl);
459   ***      0      0      0             0         if ( $trgs && @$trgs ) {
460   ***      0                           0            my $result = $before . "\nDELIMITER ;;\n";
461   ***      0                           0            foreach my $trg ( @$trgs ) {
462   ***      0      0                    0               if ( $trg->{sql_mode} ) {
463   ***      0                           0                  $result .= "/*!50003 SET SESSION SQL_MODE=\"$trg->{sql_mode}\" */;;\n";
464                                                        }
465   ***      0                           0               $result .= "/*!50003 CREATE */ ";
466   ***      0      0                    0               if ( $trg->{definer} ) {
467   ***      0                           0                  my ( $user, $host )
468   ***      0                           0                     = map { s/'/''/g; "'$_'"; }
      ***      0                           0   
469                                                                split('@', $trg->{definer}, 2);
470   ***      0                           0                  $result .= "/*!50017 DEFINER=$user\@$host */ ";
471                                                        }
472   ***      0                           0               $result .= sprintf("/*!50003 TRIGGER %s %s %s ON %s\nFOR EACH ROW %s */;;\n\n",
473                                                           $quoter->quote($trg->{trigger}),
474   ***      0                           0                  @{$trg}{qw(timing event)},
475                                                           $quoter->quote($trg->{table}),
476                                                           $trg->{statement});
477                                                     }
478   ***      0                           0            $result .= "DELIMITER ;\n\n/*!50003 SET SESSION SQL_MODE=\@OLD_SQL_MODE */;\n\n";
479   ***      0                           0            return $result;
480                                                  }
481                                                  else {
482   ***      0                           0            return undef;
483                                                  }
484                                               }
485                                               elsif ( $what eq 'view' ) {
486   ***      0                           0         my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
487   ***      0                           0         return '/*!50001 DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
488                                                     . '/*!50001 DROP VIEW IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
489                                                     . '/*!50001 ' . $ddl->[1] . "*/;\n";
490                                               }
491                                               else {
492   ***      0                           0         die "You didn't say what to dump.";
493                                               }
494                                            }
495                                            
496                                            sub _use_db {
497           12                   12     62      my ( $self, $dbh, $quoter, $new ) = @_;
498   ***     12     50                   63      if ( !$new ) {
499   ***      0                           0         MKDEBUG && _d('No new DB to use');
500   ***      0                           0         return;
501                                               }
502           12                          37      my $sql = 'SELECT DATABASE()';
503           12                          38      MKDEBUG && _d($sql);
504           12                          57      my $curr = $dbh->selectrow_array($sql);
505   ***     12     50     33          1299      if ( $curr && $new && $curr eq $new ) {
      ***                   33                 
506           12                          33         MKDEBUG && _d('Current and new DB are the same');
507           12                          54         return $curr;
508                                               }
509   ***      0                           0      $sql = 'USE ' . $quoter->quote($new);
510   ***      0                           0      MKDEBUG && _d($sql);
511   ***      0                           0      $dbh->do($sql);
512   ***      0                           0      return $curr;
513                                            }
514                                            
515                                            sub get_create_table {
516           12                   12     58      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
517   ***     12    100     66           178      if ( !$self->{cache} || !$self->{tables}->{$db}->{$tbl} ) {
518            6                          26         my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
519                                                     . '@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, "ANSI_QUOTES", ""), ",,", ","), '
520                                                     . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
521                                                     . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
522            6                          14         MKDEBUG && _d($sql);
523            6                          18         eval { $dbh->do($sql); };
               6                         717   
524            6                          19         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
525            6                          37         my $curr_db = $self->_use_db($dbh, $quoter, $db);
526            6                          32         $sql = "SHOW CREATE TABLE " . $quoter->quote($db, $tbl);
527            6                          19         MKDEBUG && _d($sql);
528            6                          23         my $href = $dbh->selectrow_hashref($sql);
529            6                         280         $self->_use_db($dbh, $quoter, $curr_db);
530            6                          24         $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
531                                                     . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
532            6                          15         MKDEBUG && _d($sql);
533            6                         429         $dbh->do($sql);
534            6                          44         my ($key) = grep { m/create table/i } keys %$href;
              12                          73   
535   ***      6     50                   35         if ( $key ) {
536            6                          19            MKDEBUG && _d('This table is a base table');
537            6                          61            $self->{tables}->{$db}->{$tbl} = [ 'table', $href->{$key} ];
538                                                  }
539                                                  else {
540   ***      0                           0            MKDEBUG && _d('This table is a view');
541   ***      0                           0            ($key) = grep { m/create view/i } keys %$href;
      ***      0                           0   
542   ***      0                           0            $self->{tables}->{$db}->{$tbl} = [ 'view', $href->{$key} ];
543                                                  }
544                                               }
545           12                          93      return $self->{tables}->{$db}->{$tbl};
546                                            }
547                                            
548                                            sub get_columns {
549   ***      0                    0      0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
550   ***      0                           0      MKDEBUG && _d("Get columns for $db.$tbl");
551   ***      0      0      0             0      if ( !$self->{cache} || !$self->{columns}->{$db}->{$tbl} ) {
552   ***      0                           0         my $curr_db = $self->_use_db($dbh, $quoter, $db);
553   ***      0                           0         my $sql = "SHOW COLUMNS FROM " . $quoter->quote($db, $tbl);
554   ***      0                           0         MKDEBUG && _d($sql);
555   ***      0                           0         my $cols = $dbh->selectall_arrayref($sql, { Slice => {} });
556   ***      0                           0         $self->_use_db($dbh, $quoter, $curr_db);
557   ***      0                           0         $self->{columns}->{$db}->{$tbl} = [
558                                                     map {
559   ***      0                           0               my %row;
560   ***      0                           0               @row{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                           0   
561   ***      0                           0               \%row;
562                                                     } @$cols
563                                                  ];
564                                               }
565   ***      0                           0      return $self->{columns}->{$db}->{$tbl};
566                                            }
567                                            
568                                            sub get_tmp_table {
569   ***      0                    0      0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
570   ***      0                           0      my $result = 'CREATE TABLE ' . $quoter->quote($tbl) . " (\n";
571   ***      0                           0      $result .= join(",\n",
572   ***      0                           0         map { '  ' . $quoter->quote($_->{field}) . ' ' . $_->{type} }
573   ***      0                           0         @{$self->get_columns($dbh, $quoter, $db, $tbl)});
574   ***      0                           0      $result .= "\n)";
575   ***      0                           0      MKDEBUG && _d($result);
576   ***      0                           0      return $result;
577                                            }
578                                            
579                                            sub get_triggers {
580   ***      0                    0      0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
581   ***      0      0      0             0      if ( !$self->{cache} || !$self->{triggers}->{$db} ) {
582   ***      0                           0         $self->{triggers}->{$db} = {};
583   ***      0                           0         my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
584                                                     . '@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, "ANSI_QUOTES", ""), ",,", ","), '
585                                                     . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
586                                                     . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
587   ***      0                           0         MKDEBUG && _d($sql);
588   ***      0                           0         eval { $dbh->do($sql); };
      ***      0                           0   
589   ***      0                           0         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
590   ***      0                           0         $sql = "SHOW TRIGGERS FROM " . $quoter->quote($db);
591   ***      0                           0         MKDEBUG && _d($sql);
592   ***      0                           0         my $sth = $dbh->prepare($sql);
593   ***      0                           0         $sth->execute();
594   ***      0      0                    0         if ( $sth->rows ) {
595   ***      0                           0            my $trgs = $sth->fetchall_arrayref({});
596   ***      0                           0            foreach my $trg (@$trgs) {
597   ***      0                           0               my %trg;
598   ***      0                           0               @trg{ map { lc $_ } keys %$trg } = values %$trg;
      ***      0                           0   
599   ***      0                           0               push @{ $self->{triggers}->{$db}->{ $trg{table} } }, \%trg;
      ***      0                           0   
600                                                     }
601                                                  }
602   ***      0                           0         $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
603                                                     . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
604   ***      0                           0         MKDEBUG && _d($sql);
605   ***      0                           0         $dbh->do($sql);
606                                               }
607   ***      0      0                    0      if ( $tbl ) {
608   ***      0                           0         return $self->{triggers}->{$db}->{$tbl};
609                                               }
610   ***      0                           0      return values %{$self->{triggers}->{$db}};
      ***      0                           0   
611                                            }
612                                            
613                                            sub get_databases {
614            7                    7     42      my ( $self, $dbh, $quoter, $like ) = @_;
615   ***      7     50     33           120      if ( !$self->{cache} || !$self->{databases} || $like ) {
      ***                   33                 
616            7                          22         my $sql = 'SHOW DATABASES';
617            7                          22         my @params;
618   ***      7     50                   35         if ( $like ) {
619   ***      0                           0            $sql .= ' LIKE ?';
620   ***      0                           0            push @params, $like;
621                                                  }
622            7                          30         my $sth = $dbh->prepare($sql);
623            7                          34         MKDEBUG && _d($sql, @params);
624            7                        1792         $sth->execute( @params );
625            7                          36         my @dbs = map { $_->[0] } @{$sth->fetchall_arrayref()};
              19                         117   
               7                         265   
626   ***      7     50                  126         $self->{databases} = \@dbs unless $like;
627            7                         165         return @dbs;
628                                               }
629   ***      0                           0      return @{$self->{databases}};
      ***      0                           0   
630                                            }
631                                            
632                                            sub get_table_status {
633   ***      0                    0      0      my ( $self, $dbh, $quoter, $db, $like ) = @_;
634   ***      0      0      0             0      if ( !$self->{cache} || !$self->{table_status}->{$db} || $like ) {
      ***                    0                 
635   ***      0                           0         my $sql = "SHOW TABLE STATUS FROM " . $quoter->quote($db);
636   ***      0                           0         my @params;
637   ***      0      0                    0         if ( $like ) {
638   ***      0                           0            $sql .= ' LIKE ?';
639   ***      0                           0            push @params, $like;
640                                                  }
641   ***      0                           0         MKDEBUG && _d($sql, @params);
642   ***      0                           0         my $sth = $dbh->prepare($sql);
643   ***      0                           0         $sth->execute(@params);
644   ***      0                           0         my @tables = @{$sth->fetchall_arrayref({})};
      ***      0                           0   
645   ***      0                           0         @tables = map {
646   ***      0                           0            my %tbl; # Make a copy with lowercased keys
647   ***      0                           0            @tbl{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                           0   
648   ***      0             0             0            $tbl{engine} ||= $tbl{type} || $tbl{comment};
      ***                    0                 
649   ***      0                           0            delete $tbl{type};
650   ***      0                           0            \%tbl;
651                                                  } @tables;
652   ***      0      0                    0         $self->{table_status}->{$db} = \@tables unless $like;
653   ***      0                           0         return @tables;
654                                               }
655   ***      0                           0      return @{$self->{table_status}->{$db}};
      ***      0                           0   
656                                            }
657                                            
658                                            sub get_table_list {
659            6                    6     41      my ( $self, $dbh, $quoter, $db, $like ) = @_;
660   ***      6     50     33           124      if ( !$self->{cache} || !$self->{table_list}->{$db} || $like ) {
      ***                   33                 
661            6                          30         my $sql = "SHOW /*!50002 FULL*/ TABLES FROM " . $quoter->quote($db);
662            6                          21         my @params;
663   ***      6     50                   34         if ( $like ) {
664   ***      0                           0            $sql .= ' LIKE ?';
665   ***      0                           0            push @params, $like;
666                                                  }
667            6                          18         MKDEBUG && _d($sql, @params);
668            6                          25         my $sth = $dbh->prepare($sql);
669            6                        1556         $sth->execute(@params);
670            6                          25         my @tables = @{$sth->fetchall_arrayref()};
               6                         161   
671   ***     39     50     50           344         @tables = map {
672            6                          29            my %tbl = (
673                                                        name   => $_->[0],
674                                                        engine => ($_->[1] || '') eq 'VIEW' ? 'VIEW' : '',
675                                                     );
676           39                         153            \%tbl;
677                                                  } @tables;
678   ***      6     50                   51         $self->{table_list}->{$db} = \@tables unless $like;
679            6                         113         return @tables;
680                                               }
681   ***      0                           0      return @{$self->{table_list}->{$db}};
      ***      0                           0   
682                                            }
683                                            
684                                            sub _d {
685   ***      0                    0      0      my ($package, undef, $line) = caller 0;
686   ***      0      0                    0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                           0   
      ***      0                           0   
687   ***      0                           0           map { defined $_ ? $_ : 'undef' }
688                                                    @_;
689   ***      0                           0      print "# $package:$line $$ ", @_, "\n";
690                                            }
691                                            
692            7                          18   1;
693                                            
694                                            # ###########################################################################
695                                            # End MySQLDump package
696                                            # ###########################################################################
697                                            
698                                            # ###########################################################################
699                                            # MySQLFind package 3009
700                                            # ###########################################################################
701                                            package MySQLFind;
702                                            
703            7                    7     60   use strict;
               7                          17   
               7                          38   
704            7                    7     49   use warnings FATAL => 'all';
               7                          16   
               7                          37   
705                                            
706            7                    7     58   use English qw(-no_match_vars);
               7                          16   
               7                          35   
707            7                    7     84   use Data::Dumper;
               7                          21   
               7                          77   
708            7                          36   $Data::Dumper::Indent    = 0;
709            7                          29   $Data::Dumper::Quotekeys = 0;
710                                            
711            7                    7     82   use constant MKDEBUG => $ENV{MKDEBUG};
               7                          58   
               7                          59   
712                                            
713                                            
714                                            sub new {
715            7                    7     66      my ( $class, %args ) = @_;
716            7                          39      foreach my $arg ( qw(dumper quoter) ) {
717   ***     14     50                   93         die "I need a $arg argument" unless $args{$arg};
718                                               }
719   ***      7     50                   45      die "Do not pass me a dbh argument" if $args{dbh};
720            7                          31      my $self = bless \%args, $class;
721   ***      7     50     33           152      $self->{need_engine}
      ***                   33                 
722                                                  = (   $self->{engines}->{permit}
723                                                     || $self->{engines}->{reject}
724                                                     || $self->{engines}->{regexp} ? 1 : 0);
725   ***      7     50     33           102      die "I need a parser argument"
726                                                  if $self->{need_engine} && !defined $args{parser};
727            7                          29      MKDEBUG && _d('Need engine: ' , $self->{need_engine} ? 'yes' : 'no');
728   ***      7     50                   59      $self->{engines}->{views} = 1  unless defined $self->{engines}->{views};
729   ***      7     50                   64      $self->{tables}->{status} = [] unless defined $self->{tables}->{status};
730   ***      7     50                   50      if ( $args{useddl} ) {
731            7                          23         MKDEBUG && _d('Will prefer DDL');
732                                               }
733            7                          29      return $self;
734                                            }
735                                            
736                                            sub init_timestamp {
737   ***      0                    0      0      my ( $self, $dbh ) = @_;
738   ***      0      0                    0      return if $self->{timestamp}->{$dbh}->{now};
739   ***      0                           0      my $sql = 'SELECT CURRENT_TIMESTAMP';
740   ***      0                           0      MKDEBUG && _d($sql);
741   ***      0                           0      ($self->{timestamp}->{$dbh}->{now}) = $dbh->selectrow_array($sql);
742   ***      0                           0      MKDEBUG && _d("Current timestamp: $self->{timestamp}->{$dbh}->{now}");
743                                            }
744                                            
745                                            sub find_databases {
746            7                    7     31      my ( $self, $dbh ) = @_;
747            6                          39      return grep {
748                                                  $_ !~ m/^(information_schema|lost\+found)$/i
749           19                   19     75      }  $self->_filter('databases', sub { $_[0] },
750            7                          89            $self->{dumper}->get_databases(
751                                                        $dbh,
752                                                        $self->{quoter},
753                                                        $self->{databases}->{like}));
754                                            }
755                                            
756                                            sub find_tables {
757            6                    6     33      my ( $self, $dbh, %args ) = @_; 
758                                            
759                                               my @tables
760           39                   39    182         = $self->_filter('tables', sub { $_[0]->{name} },
761            6                          56            $self->_fetch_tbl_list($dbh, %args));
762                                            
763   ***      6     50                   58      if ( $self->{need_engine} ) {
764            6                          26         foreach my $tbl ( @tables ) {
765   ***      6     50                   34            next if $tbl->{engine};
766            6                          53            my ( $tbl_name ) = $tbl->{name} =~ m/\.(.+)$/;
767            6                          59            my $struct = $self->{parser}->parse(
768                                                        $self->{dumper}->get_create_table(
769                                                           $dbh, $self->{quoter}, $args{database}, $tbl_name));
770            6                         106            $tbl->{engine} = $struct->{engine};
771                                                  }
772            6                    6     41         @tables = $self->_filter('engines', sub { $_[0]->{engine} }, @tables);
               6                          30   
773                                               }
774                                            
775            6                          26      map { $_->{name} =~ s/^[^.]*\.// } @tables;
               6                          46   
776                                            
777            6                          22      foreach my $crit ( @{$self->{tables}->{status}} ) {
               6                          39   
778   ***      0                           0         my ($key, $test) = %$crit;
779                                                  @tables
780   ***      0                           0            = grep {
781   ***      0                           0               $self->_test_date($_, $key, $test, $dbh)
782                                                     } @tables;
783                                               }
784                                            
785            6                          25      return map { $_->{name} } @tables;
               6                          51   
786                                            }
787                                            
788                                            sub find_views {
789   ***      0                    0      0      my ( $self, $dbh, %args ) = @_;
790   ***      0                           0      my @tables = $self->_fetch_tbl_list($dbh, %args);
791   ***      0                           0      @tables = grep { $_->{engine} eq 'VIEW' } @tables;
      ***      0                           0   
792   ***      0                           0      map { $_->{name} =~ s/^[^.]*\.// } @tables; # <database>.<table> => <table> 
      ***      0                           0   
793   ***      0                           0      return map { $_->{name} } @tables;
      ***      0                           0   
794                                            }
795                                            
796                                            sub _use_db {
797           12                   12     53      my ( $self, $dbh, $new ) = @_;
798           12    100                   60      if ( !$new ) {
799            6                          18         MKDEBUG && _d('No new DB to use');
800            6                          20         return;
801                                               }
802            6                          23      my $sql = 'SELECT DATABASE()';
803            6                          19      MKDEBUG && _d($sql);
804            6                          29      my $curr = $dbh->selectrow_array($sql);
805   ***      6     50     33           806      if ( $curr && $new && $curr eq $new ) {
      ***                   33                 
806   ***      0                           0         MKDEBUG && _d('Current and new DB are the same');
807   ***      0                           0         return $curr;
808                                               }
809            6                          48      $sql = 'USE ' . $self->{quoter}->quote($new);
810            6                          18      MKDEBUG && _d($sql);
811            6                         430      $dbh->do($sql);
812            6                          30      return $curr;
813                                            }
814                                            
815                                            sub _fetch_tbl_list {
816            6                    6     32      my ( $self, $dbh, %args ) = @_;
817   ***      6     50                  258      die "database is required" unless $args{database};
818                                            
819            6                          39      my $curr_db = $self->_use_db($dbh, $args{database});
820                                            
821            6                          19      my @tables;
822   ***      6     50                   20      if ( scalar @{$self->{tables}->{status}} ) {
               6                          57   
823   ***      0                           0         @tables = $self->{dumper}->get_table_status(
824                                                     $dbh,
825                                                     $self->{quoter},
826                                                     $args{database},
827                                                     $self->{tables}->{like});
828                                               }
829                                               else {
830            6                          70         @tables = $self->{dumper}->get_table_list(
831                                                     $dbh,
832                                                     $self->{quoter},
833                                                     $args{database},
834                                                     $self->{tables}->{like});
835                                               }
836                                            
837           39                         179      @tables = map {
838   ***     39     50                  405         my %hash = %$_;
839           39                         194         $hash{name} = join('.', $args{database}, $hash{name});
840           39                         150         \%hash;
841                                               }
842                                               grep {
843            6                          34         ( $self->{engines}->{views} || ($_->{engine} ne 'VIEW') )
844                                               } @tables;
845                                            
846            6                          36      $self->_use_db($dbh, $curr_db);
847                                            
848            6                          43      return @tables;
849                                            }
850                                            
851                                            sub _filter {
852           19                   19    109      my ( $self, $thing, $sub, @vals ) = @_;
853           19                          54      MKDEBUG && _d("Filtering $thing list on ", Dumper($self->{$thing}));
854           19                          92      my $permit = $self->{$thing}->{permit};
855           19                          77      my $reject = $self->{$thing}->{reject};
856           19                          73      my $regexp = $self->{$thing}->{regexp};
857           64                         236      return grep {
858           19                          70         my $val = $sub->($_);
859   ***     64     50                  299         $val = '' unless defined $val;
860           64    100                  263         if ( $thing eq 'tables' ) {
861           39                         211            (my $tbl = $val) =~ s/^.*\.//;
862   ***     39    100     33          1233            ( !$reject || (!$reject->{$val} && !$reject->{$tbl}) )
      ***                   33                 
      ***                   33                 
      ***                   66                 
                           100                 
      ***                   66                 
863                                                        && ( !$permit || $permit->{$val} || $permit->{$tbl} )
864                                                        && ( !$regexp || $val =~ m/$regexp/ )
865                                                  }
866                                                  else {
867   ***     25    100     33           701            ( !$reject || !$reject->{$val} )
      ***                   33                 
                           100                 
      ***                   66                 
868                                                        && ( !$permit || $permit->{$val} )
869                                                        && ( !$regexp || $val =~ m/$regexp/ )
870                                                  }
871                                               } @vals;
872                                            }
873                                            
874                                            sub _test_date {
875   ***      0                    0      0      my ( $self, $table, $prop, $test, $dbh ) = @_;
876   ***      0                           0      $prop = lc $prop;
877   ***      0      0                    0      if ( !defined $table->{$prop} ) {
878   ***      0                           0         MKDEBUG && _d("$prop is not defined");
879   ***      0                           0         return $self->{nullpass};
880                                               }
881   ***      0                           0      my ( $equality, $num ) = $test =~ m/^([+-])?(\d+)$/;
882   ***      0      0                    0      die "Invalid date test $test for $prop" unless defined $num;
883   ***      0                           0      $self->init_timestamp($dbh);
884   ***      0                           0      my $sql = "SELECT DATE_SUB('$self->{timestamp}->{$dbh}->{now}', "
885                                                       . "INTERVAL $num SECOND)";
886   ***      0                           0      MKDEBUG && _d($sql);
887   ***      0             0             0      ($self->{timestamp}->{$dbh}->{$num}) ||= $dbh->selectrow_array($sql);
888   ***      0                           0      my $time = $self->{timestamp}->{$dbh}->{$num};
889                                               return 
890   ***      0             0             0            ( $equality eq '-' && $table->{$prop} gt $time )
      ***                    0                 
      ***                    0                 
      ***                    0                 
891                                                  || ( $equality eq '+' && $table->{$prop} lt $time )
892                                                  || (                     $table->{$prop} eq $time );
893                                            }
894                                            
895                                            sub _d {
896   ***      0                    0      0      my ($package, undef, $line) = caller 0;
897   ***      0      0                    0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                           0   
      ***      0                           0   
898   ***      0                           0           map { defined $_ ? $_ : 'undef' }
899                                                    @_;
900   ***      0                           0      print "# $package:$line $$ ", @_, "\n";
901                                            }
902                                            
903            7                          21   1;
904                                            
905                                            # ###########################################################################
906                                            # End MySQLFind package
907                                            # ###########################################################################
908                                            
909                                            # ###########################################################################
910                                            # DSNParser package 2971
911                                            # ###########################################################################
912            7                    7     60   use strict;
               7                          29   
               7                          39   
913            7                    7     51   use warnings FATAL => 'all';
               7                          17   
               7                          39   
914                                            
915                                            package DSNParser;
916                                            
917            7                    7     74   use DBI;
               7                          22   
               7                          86   
918            7                    7     63   use Data::Dumper;
               7                          17   
               7                          64   
919            7                          24   $Data::Dumper::Indent    = 0;
920            7                          23   $Data::Dumper::Quotekeys = 0;
921            7                    7     47   use English qw(-no_match_vars);
               7                          19   
               7                          56   
922                                            
923            7                    7     53   use constant MKDEBUG => $ENV{MKDEBUG};
               7                          16   
               7                          75   
924                                            
925                                            sub new {
926            7                    7     34      my ( $class, @opts ) = @_;
927            7                         264      my $self = {
928                                                  opts => {
929                                                     A => {
930                                                        desc => 'Default character set',
931                                                        dsn  => 'charset',
932                                                        copy => 1,
933                                                     },
934                                                     D => {
935                                                        desc => 'Database to use',
936                                                        dsn  => 'database',
937                                                        copy => 1,
938                                                     },
939                                                     F => {
940                                                        desc => 'Only read default options from the given file',
941                                                        dsn  => 'mysql_read_default_file',
942                                                        copy => 1,
943                                                     },
944                                                     h => {
945                                                        desc => 'Connect to host',
946                                                        dsn  => 'host',
947                                                        copy => 1,
948                                                     },
949                                                     p => {
950                                                        desc => 'Password to use when connecting',
951                                                        dsn  => 'password',
952                                                        copy => 1,
953                                                     },
954                                                     P => {
955                                                        desc => 'Port number to use for connection',
956                                                        dsn  => 'port',
957                                                        copy => 1,
958                                                     },
959                                                     S => {
960                                                        desc => 'Socket file to use for connection',
961                                                        dsn  => 'mysql_socket',
962                                                        copy => 1,
963                                                     },
964                                                     u => {
965                                                        desc => 'User for login if not current user',
966                                                        dsn  => 'user',
967                                                        copy => 1,
968                                                     },
969                                                  },
970                                               };
971            7                          35      foreach my $opt ( @opts ) {
972   ***      0                           0         MKDEBUG && _d('Adding extra property ' . $opt->{key});
973   ***      0                           0         $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
974                                               }
975            7                          35      return bless $self, $class;
976                                            }
977                                            
978                                            sub prop {
979           21                   21    101      my ( $self, $prop, $value ) = @_;
980           21    100                  124      if ( @_ > 2 ) {
981            7                          17         MKDEBUG && _d("Setting $prop property");
982            7                          28         $self->{$prop} = $value;
983                                               }
984           21                         146      return $self->{$prop};
985                                            }
986                                            
987                                            sub parse {
988   ***      0                    0      0      my ( $self, $dsn, $prev, $defaults ) = @_;
989   ***      0      0                    0      if ( !$dsn ) {
990   ***      0                           0         MKDEBUG && _d('No DSN to parse');
991   ***      0                           0         return;
992                                               }
993   ***      0                           0      MKDEBUG && _d("Parsing $dsn");
994   ***      0             0             0      $prev     ||= {};
995   ***      0             0             0      $defaults ||= {};
996   ***      0                           0      my %given_props;
997   ***      0                           0      my %final_props;
998   ***      0                           0      my %opts = %{$self->{opts}};
      ***      0                           0   
999   ***      0                           0      my $prop_autokey = $self->prop('autokey');
1000                                           
1001  ***      0                           0      foreach my $dsn_part ( split(/,/, $dsn) ) {
1002  ***      0      0                    0         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
      ***             0                        
1003  ***      0                           0            $given_props{$prop_key} = $prop_val;
1004                                                 }
1005                                                 elsif ( $prop_autokey ) {
1006  ***      0                           0            MKDEBUG && _d("Interpreting $dsn_part as $prop_autokey=$dsn_part");
1007  ***      0                           0            $given_props{$prop_autokey} = $dsn_part;
1008                                                 }
1009                                                 else {
1010  ***      0                           0            MKDEBUG && _d("Bad DSN part: $dsn_part");
1011                                                 }
1012                                              }
1013                                           
1014  ***      0                           0      foreach my $key ( keys %opts ) {
1015  ***      0                           0         MKDEBUG && _d("Finding value for $key");
1016  ***      0                           0         $final_props{$key} = $given_props{$key};
1017  ***      0      0      0             0         if (   !defined $final_props{$key}
      ***                    0                 
1018                                                      && defined $prev->{$key} && $opts{$key}->{copy} )
1019                                                 {
1020  ***      0                           0            $final_props{$key} = $prev->{$key};
1021  ***      0                           0            MKDEBUG && _d("Copying value for $key from previous DSN");
1022                                                 }
1023  ***      0      0                    0         if ( !defined $final_props{$key} ) {
1024  ***      0                           0            $final_props{$key} = $defaults->{$key};
1025  ***      0                           0            MKDEBUG && _d("Copying value for $key from defaults");
1026                                                 }
1027                                              }
1028                                           
1029  ***      0                           0      foreach my $key ( keys %given_props ) {
1030  ***      0      0                    0         die "Unrecognized DSN part '$key' in '$dsn'\n"
1031                                                    unless exists $opts{$key};
1032                                              }
1033  ***      0      0                    0      if ( (my $required = $self->prop('required')) ) {
1034  ***      0                           0         foreach my $key ( keys %$required ) {
1035  ***      0      0                    0            die "Missing DSN part '$key' in '$dsn'\n" unless $final_props{$key};
1036                                                 }
1037                                              }
1038                                           
1039  ***      0                           0      return \%final_props;
1040                                           }
1041                                           
1042                                           sub as_string {
1043  ***      0                    0      0      my ( $self, $dsn ) = @_;
1044  ***      0      0                    0      return $dsn unless ref $dsn;
1045  ***      0      0                    0      return join(',',
1046  ***      0      0                    0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
1047  ***      0                           0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
1048                                                 sort keys %$dsn );
1049                                           }
1050                                           
1051                                           sub usage {
1052  ***      0                    0      0      my ( $self ) = @_;
1053  ***      0                           0      my $usage
1054                                                 = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n"
1055                                                 . "  KEY  COPY  MEANING\n"
1056                                                 . "  ===  ====  =============================================\n";
1057  ***      0                           0      my %opts = %{$self->{opts}};
      ***      0                           0   
1058  ***      0                           0      foreach my $key ( sort keys %opts ) {
1059  ***      0      0      0             0         $usage .= "  $key    "
1060                                                        .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
1061                                                        .  ($opts{$key}->{desc} || '[No description]')
1062                                                        . "\n";
1063                                              }
1064  ***      0      0                    0      if ( (my $key = $self->prop('autokey')) ) {
1065  ***      0                           0         $usage .= "  If the DSN is a bareword, the word is treated as the '$key' key.\n";
1066                                              }
1067  ***      0                           0      return $usage;
1068                                           }
1069                                           
1070                                           sub get_cxn_params {
1071           7                    7     28      my ( $self, $info ) = @_;
1072           7                          20      my $dsn;
1073           7                          21      my %opts = %{$self->{opts}};
               7                          53   
1074  ***      7            50            37      my $driver = $self->prop('dbidriver') || '';
1075  ***      7     50                   36      if ( $driver eq 'Pg' ) {
1076  ***      0                           0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
1077  ***      0                           0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1078  ***      0             0             0                        grep { defined $info->{$_} }
1079                                                                qw(h P));
1080                                              }
1081                                              else {
1082           7                          65         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
1083          35                         135            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1084  ***      7            50            94                        grep { defined $info->{$_} }
1085                                                                qw(F h P S A))
1086                                                    . ';mysql_read_default_group=mysql';
1087                                              }
1088           7                          22      MKDEBUG && _d($dsn);
1089           7                          74      return ($dsn, $info->{u}, $info->{p});
1090                                           }
1091                                           
1092                                           sub fill_in_dsn {
1093  ***      0                    0      0      my ( $self, $dbh, $dsn ) = @_;
1094  ***      0                           0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
1095  ***      0                           0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
1096  ***      0                           0      $user =~ s/@.*//;
1097  ***      0             0             0      $dsn->{h} ||= $vars->{hostname}->{Value};
1098  ***      0             0             0      $dsn->{S} ||= $vars->{'socket'}->{Value};
1099  ***      0             0             0      $dsn->{P} ||= $vars->{port}->{Value};
1100  ***      0             0             0      $dsn->{u} ||= $user;
1101  ***      0             0             0      $dsn->{D} ||= $db;
1102                                           }
1103                                           
1104                                           sub get_dbh {
1105           7                    7     37      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
1106  ***      7            50            37      $opts ||= {};
1107  ***      7     50                   66      my $defaults = {
1108                                                 AutoCommit        => 0,
1109                                                 RaiseError        => 1,
1110                                                 PrintError        => 0,
1111                                                 mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
1112                                              };
1113           7                          37      @{$defaults}{ keys %$opts } = values %$opts;
               7                          27   
1114           7                          27      my $dbh;
1115           7                          20      my $tries = 2;
1116  ***      7            66            93      while ( !$dbh && $tries-- ) {
1117           7                          25         eval {
1118                                                    MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
1119           7                          16               join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
1120           7                          68            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
1121  ***      7     50                  237            if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
1122  ***      0                           0               my $sql = "/*!40101 SET NAMES $charset*/";
1123  ***      0                           0               MKDEBUG && _d("$dbh: $sql");
1124  ***      0                           0               $dbh->do($sql);
1125  ***      0                           0               MKDEBUG && _d('Enabling charset for STDOUT');
1126  ***      0      0                    0               if ( $charset eq 'utf8' ) {
1127  ***      0      0                    0                  binmode(STDOUT, ':utf8')
1128                                                             or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
1129                                                       }
1130                                                       else {
1131  ***      0      0                    0                  binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
1132                                                       }
1133                                                    }
1134                                                 };
1135  ***      7     50     33            97         if ( !$dbh && $EVAL_ERROR ) {
1136  ***      0                           0            MKDEBUG && _d($EVAL_ERROR);
1137  ***      0      0                    0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
1138  ***      0                           0               MKDEBUG && _d("Going to try again without utf8 support");
1139  ***      0                           0               delete $defaults->{mysql_enable_utf8};
1140                                                    }
1141  ***      0      0                    0            if ( !$tries ) {
1142  ***      0                           0               die $EVAL_ERROR;
1143                                                    }
1144                                                 }
1145                                              }
1146           7                          50      my $setvars = $self->prop('setvars');
1147  ***      7     50     33           129      if ( $cxn_string =~ m/mysql/i && $setvars ) {
1148           7                          36         my $sql = "SET $setvars";
1149           7                          20         MKDEBUG && _d("$dbh: $sql");
1150           7                          23         eval {
1151           7                         647            $dbh->do($sql);
1152                                                 };
1153  ***      7     50                   58         if ( $EVAL_ERROR ) {
1154  ***      0                           0            MKDEBUG && _d($EVAL_ERROR);
1155                                                 }
1156                                              }
1157           7                          20      MKDEBUG && _d('DBH info: ',
1158                                                 $dbh,
1159                                                 Dumper($dbh->selectrow_hashref(
1160                                                    'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
1161                                                 ' Connection info: ', ($dbh->{mysql_hostinfo} || 'undef'),
1162                                                 ' Character set info: ',
1163                                                 Dumper($dbh->selectall_arrayref(
1164                                                    'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
1165                                                 ' $DBD::mysql::VERSION: ', $DBD::mysql::VERSION,
1166                                                 ' $DBI::VERSION: ', $DBI::VERSION,
1167                                              );
1168           7                          44      return $dbh;
1169                                           }
1170                                           
1171                                           sub get_hostname {
1172  ***      0                    0      0      my ( $self, $dbh ) = @_;
1173  ***      0      0      0             0      if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
1174  ***      0                           0         return $host;
1175                                              }
1176  ***      0                           0      my ( $hostname, $one ) = $dbh->selectrow_array(
1177                                                 'SELECT /*!50038 @@hostname, */ 1');
1178  ***      0                           0      return $hostname;
1179                                           }
1180                                           
1181                                           sub disconnect {
1182  ***      0                    0      0      my ( $self, $dbh ) = @_;
1183  ***      0                           0      MKDEBUG && $self->print_active_handles($dbh);
1184  ***      0                           0      $dbh->disconnect;
1185                                           }
1186                                           
1187                                           sub print_active_handles {
1188  ***      0                    0      0      my ( $self, $thing, $level ) = @_;
1189  ***      0             0             0      $level ||= 0;
1190  ***      0      0      0             0      printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                 
      ***                    0                 
1191                                                 $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
1192                                                 or die "Cannot print: $OS_ERROR";
1193  ***      0                           0      foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                           0   
      ***      0                           0   
1194  ***      0                           0         $self->print_active_handles( $handle, $level + 1 );
1195                                              }
1196                                           }
1197                                           
1198                                           sub _d {
1199  ***      0                    0      0      my ($package, undef, $line) = caller 0;
1200  ***      0      0                    0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                           0   
      ***      0                           0   
1201  ***      0                           0           map { defined $_ ? $_ : 'undef' }
1202                                                   @_;
1203  ***      0                           0      print "# $package:$line $$ ", @_, "\n";
1204                                           }
1205                                           
1206           7                          18   1;
1207                                           
1208                                           # ###########################################################################
1209                                           # End DSNParser package
1210                                           # ###########################################################################
1211                                           
1212                                           # ###########################################################################
1213                                           # OptionParser package 3028
1214                                           # ###########################################################################
1215                                           package OptionParser;
1216                                           
1217           7                    7     56   use strict;
               7                          17   
               7                          42   
1218           7                    7     51   use warnings FATAL => 'all';
               7                          18   
               7                          58   
1219                                           
1220           7                    7     87   use Getopt::Long;
               7                          25   
               7                          53   
1221           7                    7     57   use List::Util qw(max);
               7                          17   
               7                          76   
1222           7                    7     46   use English qw(-no_match_vars);
               7                          20   
               7                          45   
1223                                           
1224           7                    7     54   use constant MKDEBUG => $ENV{MKDEBUG};
               7                          23   
               7                          75   
1225                                           
1226           7                          27   my $POD_link_re = '[LC]<"?([^">]+)"?>';
1227                                           
1228                                           sub pod_to_spec {
1229           7                    7     32      my ( $self, $file ) = @_;
1230  ***      7            50            46      $file ||= __FILE__;
1231  ***      7     50                  367      open my $fh, '<', $file or die "Can't open $file: $OS_ERROR";
1232                                           
1233           7                          84      my %types = (
1234                                                 string => 's', # standard Getopt type
1235                                                 'int'  => 'i', # standard Getopt type
1236                                                 float  => 'f', # standard Getopt type
1237                                                 Hash   => 'H', # hash, formed from a comma-separated list
1238                                                 hash   => 'h', # hash as above, but only if a value is given
1239                                                 Array  => 'A', # array, similar to Hash
1240                                                 array  => 'a', # array, similar to hash
1241                                                 DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dsn}
1242                                                 size   => 'z', # size with kMG suffix (powers of 2^10)
1243                                                 'time' => 'm', # time, with an optional suffix of s/h/m/d
1244                                              );
1245           7                          25      my @specs = ();
1246           7                          23      my @rules = ();
1247           7                          19      my $para;
1248           7                          21      my $option;
1249                                           
1250           7                          42      local $INPUT_RECORD_SEPARATOR = '';
1251           7                         238      while ( $para = <$fh> ) {
1252        2198    100                17083         next unless $para =~ m/^=head1 OPTIONS/;
1253           7                          26         last;
1254                                              }
1255                                           
1256           7                          51      while ( $para = <$fh> ) {
1257  ***      7     50                   43         last if $para =~ m/^=over/;
1258  ***      0                           0         chomp $para;
1259  ***      0                           0         $para =~ s/\s+/ /g;
1260  ***      0                           0         $para =~ s/$POD_link_re/$1/go;
1261  ***      0                           0         MKDEBUG && _d('First option rules: '. $para);
1262  ***      0                           0         push @rules, $para;
1263                                              }
1264                                           
1265           7                          31      do {
1266         161    100                 1089         if ( ($option) = $para =~ m/^=item --(.*)/ ) {
1267         154                         362            MKDEBUG && _d($para);
1268         154                         387            my %props;
1269         154                         562            $para = <$fh>;
1270         154    100                  747            if ( $para =~ m/: / ) {
1271         140                         625               $para =~ s/\s+\Z//g;
1272         140                         620               %props = map { split(/: /, $_) } split(/; /, $para);
             252                        1241   
1273         140    100                  767               if ( $props{'short form'} ) {
1274         119                         509                  $props{'short form'} =~ s/-//;
1275                                                       }
1276         140                         565               $para = <$fh>;
1277                                                    }
1278         154                         711            $para =~ s/\s+\Z//g;
1279         154                         654            $para =~ s/\s+/ /g;
1280         154                         656            $para =~ s/$POD_link_re/$1/go;
1281  ***    154     50                  937            if ( $para =~ m/^[^.]+\.$/ ) {
1282         154                         508               $para =~ s/\.$//;
1283                                                    }
1284                                           
1285         154    100                  824            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
1286          21                          63               $option = $base_option;
1287          21                          84               $props{'negatable'} = 1;
1288                                                    }
1289                                           
1290         154    100                 2689            push @specs, {
                    100                        
      ***            50                        
                    100                        
                    100                        
1291                                                       s => $option
1292                                                          . ( $props{'short form'} ? '|' . $props{'short form'} : '' )
1293                                                          . ( $props{'negatable'}  ? '!'                        : '' )
1294                                                          . ( $props{'cumulative'} ? '+'                        : '' )
1295                                                          . ( $props{type}         ? '=' . $types{$props{type}} : '' ),
1296                                                       d => $para
1297                                                          . (defined $props{default} ? " (default $props{default})" : ''),
1298                                                    };
1299                                                 }
1300         161                        1002         while ( $para = <$fh> ) {
1301  ***    280     50                 1196            last unless $para;
1302                                           
1303         280    100                 1202            if ( $option ) {
1304  ***    273     50                 3392               if ( my ($line)
1305                                                             = $para =~ m/(allowed with --$option[:]?.*?)\./ ) {
1306  ***      0                           0                  1 while ( $line =~ s/$POD_link_re/$1/go );
1307  ***      0                           0                  push @rules, $line;
1308                                                       }
1309                                                    }
1310                                           
1311         280    100                 1268            if ( $para =~ m/^=head1/ ) {
1312           7                          25               $para = undef; # Can't 'last' out of a do {} block.
1313           7                          39               last;
1314                                                    }
1315         273    100                 2030            last if $para =~ m/^=item --/;
1316                                                 }
1317                                              } while ( $para );
1318                                           
1319           7                         118      close $fh;
1320           7                         165      return @specs, @rules;
1321                                           }
1322                                           
1323                                           sub new {
1324           7                    7     43      my ( $class, @opts ) = @_;
1325           7                          20      my %key_seen;
1326           7                         216      my %long_seen;
1327           7                         925      my %key_for;
1328           7                         229      my %defaults;
1329           7                         253      my @mutex;
1330           7                          18      my @atleast1;
1331           7                          17      my %long_for;
1332           7                          18      my %disables;
1333           7                          18      my %copyfrom;
1334           7                          20      my @allowed_with;
1335                                           
1336           7                          62      unshift @opts,
1337                                                 { s => 'help',    d => 'Show this help message' },
1338                                                 { s => 'version', d => 'Output version information and exit' };
1339                                           
1340           7                          38      foreach my $opt ( @opts ) {
1341  ***    168     50                  672         if ( ref $opt ) { # It's an option spec, not a rule.
1342         168                         969            my ( $long, $short ) = $opt->{s} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
1343  ***    168            66          1112            $opt->{k} = $short || $long;
1344         168                         679            $key_for{$long} = $opt->{k};
1345         168                         649            $long_for{$opt->{k}} = $long;
1346         168                         531            $long_for{$long} = $long;
1347         168                         588            $opt->{l} = $long;
1348  ***    168     50                  877            die "Duplicate option $opt->{k}" if $key_seen{$opt->{k}}++;
1349  ***    168     50                  851            die "Duplicate long option $opt->{l}" if $long_seen{$opt->{l}}++;
1350         168                         553            $opt->{t} = $short;
1351         168                         711            $opt->{n} = $opt->{s} =~ m/!/;
1352         168                         665            $opt->{c} = $opt->{s} =~ m/\+/;
1353  ***    168            50           869            $opt->{g} ||= 'o';
1354         168    100                 1002            if ( (my ($y) = $opt->{s} =~ m/=([mdHhAaz])/) ) {
1355          42                         100               MKDEBUG && _d("Option $opt->{k} type: $y");
1356          42                         168               $opt->{y} = $y;
1357          42                         188               $opt->{s} =~ s/=./=s/;
1358                                                    }
1359  ***    168     50                  839            if ( $opt->{d} =~ m/required/ ) {
1360  ***      0                           0               $opt->{r} = 1;
1361  ***      0                           0               MKDEBUG && _d("Option $opt->{k} is required");
1362                                                    }
1363         168    100                  997            if ( (my ($def) = $opt->{d} =~ m/default\b(?: ([^)]+))?/) ) {
1364  ***     35     50                  186               $defaults{$opt->{k}} = defined $def ? $def : 1;
1365          35                          90               MKDEBUG && _d("Option $opt->{k} has a default");
1366                                                    }
1367  ***    168     50                 1078            if ( (my ($dis) = $opt->{d} =~ m/(disables .*)/) ) {
1368  ***      0                           0               $disables{$opt->{k}} = [ $class->get_participants($dis) ];
1369  ***      0                           0               MKDEBUG && _d("Option $opt->{k} $dis");
1370                                                    }
1371                                                 }
1372                                                 else { # It's an option rule, not a spec.
1373  ***      0      0                    0            if ( $opt =~ m/at least one|mutually exclusive|one and only one/ ) {
      ***             0                        
      ***             0                        
1374  ***      0      0                    0               my @participants = map {
1375  ***      0                           0                     die "No such option '$_' in $opt" unless $long_for{$_};
1376  ***      0                           0                     $long_for{$_};
1377                                                          } $class->get_participants($opt);
1378  ***      0      0                    0               if ( $opt =~ m/mutually exclusive|one and only one/ ) {
1379  ***      0                           0                  push @mutex, \@participants;
1380  ***      0                           0                  MKDEBUG && _d(@participants, ' are mutually exclusive');
1381                                                       }
1382  ***      0      0                    0               if ( $opt =~ m/at least one|one and only one/ ) {
1383  ***      0                           0                  push @atleast1, \@participants;
1384  ***      0                           0                  MKDEBUG && _d(@participants, ' require at least one');
1385                                                       }
1386                                                    }
1387                                                    elsif ( $opt =~ m/default to/ ) {
1388  ***      0      0                    0               my @participants = map {
1389  ***      0                           0                     die "No such option '$_' in $opt" unless $long_for{$_};
1390  ***      0                           0                     $key_for{$_};
1391                                                          } $class->get_participants($opt);
1392  ***      0                           0               $copyfrom{$participants[0]} = $participants[1];
1393  ***      0                           0               MKDEBUG && _d(@participants, ' copy from each other');
1394                                                    }
1395                                                    elsif ( $opt  =~ m/allowed with/ ) {
1396  ***      0      0                    0               my @participants = map {
1397  ***      0                           0                     die "No such option '$_' while processing $opt"
1398                                                                unless $long_for{$_};
1399  ***      0                           0                     $key_for{$_};
1400                                                          } $class->get_participants($opt);
1401  ***      0                           0               push @allowed_with, \@participants;
1402                                                    }
1403                                                 }
1404                                              }
1405                                           
1406           7                          39      foreach my $dis ( keys %disables ) {
1407                                                 $disables{$dis} = [
1408                                                       map {
1409  ***      0      0                    0                  if ( !defined $long_for{$_} ) {
      ***      0                           0   
1410  ***      0                           0                     die "No such option '$_' while processing $dis";
1411                                                          }
1412  ***      0                           0                  $long_for{$_};
1413  ***      0                           0               } @{$disables{$dis}}
1414                                                 ];
1415                                              }
1416                                           
1417         168                         535      my $self = {
1418         168                         704         specs        => [ grep { ref $_ } @opts ],
1419                                                 errors       => [],
1420           7                          35         instr        => [ grep { !ref $_ } @opts ],
1421                                                 mutex        => \@mutex,
1422                                                 defaults     => \%defaults,
1423                                                 long_for     => \%long_for,
1424                                                 atleast1     => \@atleast1,
1425                                                 disables     => \%disables,
1426                                                 key_for      => \%key_for,
1427                                                 copyfrom     => \%copyfrom,
1428                                                 strict       => 1,
1429                                                 groups       => [ { k => 'o', d => 'Options' } ],
1430                                                 allowed_with => \@allowed_with,
1431                                                 given        => {},
1432                                              };
1433                                           
1434           7                         106      return bless $self, $class;
1435                                           }
1436                                           
1437                                           sub get_participants {
1438  ***      0                    0      0      my ( $self, $str ) = @_;
1439  ***      0                           0      my @participants;
1440  ***      0                           0      foreach my $thing ( $str =~ m/(--?[\w-]+)/g ) {
1441  ***      0      0                    0         if ( (my ($long) = $thing =~ m/--(.+)/) ) {
1442  ***      0                           0            push @participants, $long;
1443                                                 }
1444                                                 else {
1445  ***      0                           0            foreach my $short ( $thing =~ m/([^-])/g ) {
1446  ***      0                           0               push @participants, $short;
1447                                                    }
1448                                                 }
1449                                              }
1450  ***      0                           0      MKDEBUG && _d("Participants for $str: ", @participants);
1451  ***      0                           0      return @participants;
1452                                           }
1453                                           
1454                                           sub parse {
1455           7                    7     34      my ( $self, %defaults ) = @_;
1456           7                          25      my @specs = @{$self->{specs}};
               7                          49   
1457           7                          37      my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
1458           7                          19      my %opt_seen;
1459           7                          21      my %vals = %{$self->{defaults}};
               7                          63   
1460           7                          40      @vals{keys %defaults} = values %defaults;
1461           7                          28      foreach my $spec ( @specs ) {
1462         168    100                  991         $vals{$spec->{k}} = undef unless defined $vals{$spec->{k}};
1463         168                         686         $opt_seen{$spec->{k}} = 1;
1464                                              }
1465                                           
1466           7                          35      foreach my $key ( keys %defaults ) {
1467  ***      0      0                    0         die "Cannot set default for non-existent option '$key'\n"
1468                                                    unless $opt_seen{$key};
1469                                              }
1470                                           
1471           7                          31      $self->{given} = {}; # in case options are re-parsed
1472                                           
1473           7                          59      Getopt::Long::Configure('no_ignore_case', 'bundling');
1474         168                         468      GetOptions(
1475                                                 map {
1476  ***      7     50                 1169            my $spec = $_;
1477                                                    $spec->{s} => sub {
1478          21                   21  44624                             my ( $opt, $val ) = @_;
1479  ***     21     50                  105                             if ( $spec->{c} ) {
1480  ***      0                           0                                $vals{$spec->{k}}++
1481                                                                     }
1482                                                                     else {
1483          21                         103                                $vals{$spec->{k}} = $val;
1484                                                                     }
1485          21                          60                             MKDEBUG && _d("Given option: $opt ($spec->{k}) "
1486                                                                        . " = $val");
1487          21                         138                             $self->{given}->{$spec->{k}} = $vals{$spec->{k}};
1488                                                                  }
1489         168                        2072         } @specs
1490                                              ) or $self->error('Error parsing options');
1491                                           
1492  ***      7     50                  809      if ( $vals{version} ) {
1493  ***      0                           0         my $prog = $self->prog;
1494  ***      0      0                    0         printf("%s  Ver %s Distrib %s Changeset %s\n",
1495                                                    $prog, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
1496                                                    or die "Cannot print: $OS_ERROR";
1497  ***      0                           0         exit(0);
1498                                              }
1499                                           
1500  ***      7     50     33            51      if ( @ARGV && $self->{strict} ) {
1501  ***      0                           0         $self->error("Unrecognized command-line options @ARGV");
1502                                              }
1503                                           
1504           7                          24      foreach my $dis ( grep { defined $vals{$_} } keys %{$self->{disables}} ) {
      ***      0                           0   
               7                          47   
1505  ***      0                           0         my @disses = map { $self->{key_for}->{$_} } @{$self->{disables}->{$dis}};
      ***      0                           0   
      ***      0                           0   
1506  ***      0                           0         MKDEBUG && _d("Unsetting options: ", @disses);
1507  ***      0                           0         @vals{@disses} = map { undef } @disses;
      ***      0                           0   
1508                                              }
1509                                           
1510           7                          28      foreach my $spec ( grep { $_->{r} } @specs ) {
             168                         580   
1511  ***      0      0                    0         if ( !defined $vals{$spec->{k}} ) {
1512  ***      0                           0            $self->error("Required option --$spec->{l} must be specified");
1513                                                 }
1514                                              }
1515                                           
1516           7                          29      foreach my $mutex ( @{$self->{mutex}} ) {
               7                          36   
1517  ***      0                           0         my @set = grep { defined $vals{$self->{key_for}->{$_}} } @$mutex;
      ***      0                           0   
1518  ***      0      0                    0         if ( @set > 1 ) {
1519  ***      0                           0            my $note = join(', ',
1520  ***      0                           0               map { "--$self->{long_for}->{$_}" }
1521  ***      0                           0                   @{$mutex}[ 0 .. scalar(@$mutex) - 2] );
1522  ***      0                           0            $note .= " and --$self->{long_for}->{$mutex->[-1]}"
1523                                                          . " are mutually exclusive.";
1524  ***      0                           0            $self->error($note);
1525                                                 }
1526                                              }
1527                                           
1528           7                          22      foreach my $required ( @{$self->{atleast1}} ) {
               7                          36   
1529  ***      0                           0         my @set = grep { defined $vals{$self->{key_for}->{$_}} } @$required;
      ***      0                           0   
1530  ***      0      0                    0         if ( !@set ) {
1531  ***      0                           0            my $note = join(', ',
1532  ***      0                           0               map { "--$self->{long_for}->{$_}" }
1533  ***      0                           0                   @{$required}[ 0 .. scalar(@$required) - 2] );
1534  ***      0                           0            $note .= " or --$self->{long_for}->{$required->[-1]}";
1535  ***      0                           0            $self->error("Specify at least one of $note");
1536                                                 }
1537                                              }
1538                                           
1539           7    100                   29      foreach my $spec ( grep { $_->{y} && defined $vals{$_->{k}} } @specs ) {
             168                        1071   
1540          10                          42         my $val = $vals{$spec->{k}};
1541  ***     10     50                  120         if ( $spec->{y} eq 'm' ) {
      ***            50                        
      ***            50                        
1542  ***      0                           0            my ( $num, $suffix ) = $val =~ m/(\d+)([a-z])?$/;
1543  ***      0      0                    0            if ( !$suffix ) {
1544  ***      0                           0               my ( $s ) = $spec->{d} =~ m/\(suffix (.)\)/;
1545  ***      0             0             0               $suffix = $s || 's';
1546  ***      0                           0               MKDEBUG && _d("No suffix given; using $suffix for $spec->{k} "
1547                                                          . "(value: '$val')");
1548                                                    }
1549  ***      0      0                    0            if ( $suffix =~ m/[smhd]/ ) {
1550  ***      0      0                    0               $val = $suffix eq 's' ? $num            # Seconds
      ***             0                        
      ***             0                        
1551                                                            : $suffix eq 'm' ? $num * 60       # Minutes
1552                                                            : $suffix eq 'h' ? $num * 3600     # Hours
1553                                                            :                  $num * 86400;   # Days
1554  ***      0                           0               $vals{$spec->{k}} = $val;
1555  ***      0                           0               MKDEBUG && _d("Setting option $spec->{k} to $val");
1556                                                    }
1557                                                    else {
1558  ***      0                           0               $self->error("Invalid --$spec->{l} argument");
1559                                                    }
1560                                                 }
1561                                                 elsif ( $spec->{y} eq 'd' ) {
1562  ***      0                           0            MKDEBUG && _d("Parsing option $spec->{y} as a DSN");
1563  ***      0                           0            my $from_key = $self->{copyfrom}->{$spec->{k}};
1564  ***      0                           0            my $default = {};
1565  ***      0      0                    0            if ( $from_key ) {
1566  ***      0                           0               MKDEBUG && _d("Option $spec->{y} DSN copies from option $from_key");
1567  ***      0                           0               $default = $self->{dsn}->parse($self->{dsn}->as_string($vals{$from_key}));
1568                                                    }
1569  ***      0                           0            $vals{$spec->{k}} = $self->{dsn}->parse($val, $default);
1570                                                 }
1571                                                 elsif ( $spec->{y} eq 'z' ) {
1572  ***      0                           0            my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
1573  ***      0      0                    0            if ( defined $num ) {
1574  ***      0      0                    0               if ( $factor ) {
1575  ***      0                           0                  $num *= $factor_for{$factor};
1576  ***      0                           0                  MKDEBUG && _d("Setting option $spec->{y} to num * factor");
1577                                                       }
1578  ***      0             0             0               $vals{$spec->{k}} = ($pre || '') . $num;
1579                                                    }
1580                                                    else {
1581  ***      0                           0               $self->error("Invalid --$spec->{l} argument");
1582                                                    }
1583                                                 }
1584                                              }
1585                                           
1586           7                          34      foreach my $spec ( grep { $_->{y} } @specs ) {
             168                         574   
1587          42                          98         MKDEBUG && _d("Treating option $spec->{k} as a list");
1588          42                         152         my $val = $vals{$spec->{k}};
1589  ***     42    100     66           574         if ( $spec->{y} eq 'H' || (defined $val && $spec->{y} eq 'h') ) {
      ***            50    100                 
      ***                   33                 
      ***                   33                 
1590          31           100           305            $vals{$spec->{k}} = { map { $_ => 1 } split(',', ($val || '')) };
              10                          88   
1591                                                 }
1592                                                 elsif ( $spec->{y} eq 'A' || (defined $val && $spec->{y} eq 'a') ) {
1593  ***      0             0             0            $vals{$spec->{k}} = [ split(',', ($val || '')) ];
1594                                                 }
1595                                              }
1596                                           
1597           7                          31      foreach my $allowed_opts ( @{ $self->{allowed_with} } ) {
               7                          37   
1598  ***      0                           0         my $opt = $allowed_opts->[0];
1599  ***      0      0                    0         next unless $vals{$opt};
1600  ***      0                           0         my %defined_opts = map { $_ => 1 } grep { defined $vals{$_} } keys %vals;
      ***      0                           0   
      ***      0                           0   
1601  ***      0                           0         delete @defined_opts{ @$allowed_opts };
1602  ***      0                           0         foreach my $defined_opt ( keys %defined_opts ) {
1603  ***      0                           0            MKDEBUG
1604                                                       && _d("Unsetting options: $defined_opt (not allowed with $opt)");
1605  ***      0                           0            $vals{$defined_opt} = undef;
1606                                                 }
1607                                              }
1608                                           
1609           7                         159      return %vals;
1610                                           }
1611                                           
1612                                           sub error {
1613  ***      0                    0      0      my ( $self, $note ) = @_;
1614  ***      0                           0      $self->{__error__} = 1;
1615  ***      0                           0      push @{$self->{errors}}, $note;
      ***      0                           0   
1616                                           }
1617                                           
1618                                           sub prog {
1619  ***      0                    0      0      (my $prog) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
1620  ***      0             0             0      return $prog || $PROGRAM_NAME;
1621                                           }
1622                                           
1623                                           sub prompt {
1624  ***      0                    0      0      my ( $self ) = @_;
1625  ***      0                           0      my $prog   = $self->prog;
1626  ***      0             0             0      my $prompt = $self->{prompt} || '<options>';
1627  ***      0                           0      return "Usage: $prog $prompt\n";
1628                                           }
1629                                           
1630                                           sub descr {
1631  ***      0                    0      0      my ( $self ) = @_;
1632  ***      0                           0      my $prog = $self->prog;
1633  ***      0             0             0      my $descr  = $prog . ' ' . ($self->{descr} || '')
1634                                                     . "  For more details, please use the --help option, "
1635                                                     . "or try 'perldoc $prog' for complete documentation.";
1636  ***      0                           0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g);
1637  ***      0                           0      $descr =~ s/ +$//mg;
1638  ***      0                           0      return $descr;
1639                                           }
1640                                           
1641                                           sub usage_or_errors {
1642           7                    7     62      my ( $self, %opts ) = @_;
1643  ***      7     50                   81      if ( $opts{help} ) {
      ***            50                        
1644  ***      0      0                    0         print $self->usage(%opts)
1645                                                    or die "Cannot print: $OS_ERROR";
1646  ***      0                           0         exit(0);
1647                                              }
1648                                              elsif ( $self->{__error__} ) {
1649  ***      0      0                    0         print $self->errors()
1650                                                    or die "Cannot print: $OS_ERROR";
1651  ***      0                           0         exit(0);
1652                                              }
1653                                           }
1654                                           
1655                                           sub errors {
1656  ***      0                    0      0      my ( $self ) = @_;
1657  ***      0                           0      my $usage = $self->prompt() . "\n";
1658  ***      0      0                    0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                           0   
1659  ***      0                           0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors) . "\n";
1660                                              }
1661  ***      0                           0      return $usage . "\n" . $self->descr();
1662                                           }
1663                                           
1664                                           sub usage {
1665  ***      0                    0      0      my ( $self, %vals ) = @_;
1666  ***      0                           0      my @specs = @{$self->{specs}};
      ***      0                           0   
1667                                           
1668  ***      0      0                    0      my $maxl = max(map { length($_->{l}) + ($_->{n} ? 4 : 0)} @specs);
      ***      0                           0   
1669                                           
1670  ***      0      0                    0      my $maxs = max(0,
1671  ***      0                           0         map { length($_->{l}) + ($_->{n} ? 4 : 0)}
1672  ***      0                           0         grep { $_->{t} } @specs);
1673                                           
1674  ***      0                           0      my $lcol = max($maxl, ($maxs + 3));
1675  ***      0                           0      my $rcol = 80 - $lcol - 6;
1676  ***      0                           0      my $rpad = ' ' x ( 80 - $rcol );
1677                                           
1678  ***      0                           0      $maxs = max($lcol - 3, $maxs);
1679                                           
1680  ***      0                           0      my $usage = $self->descr() . "\n" . $self->prompt();
1681  ***      0                           0      foreach my $g ( @{$self->{groups}} ) {
      ***      0                           0   
1682  ***      0                           0         $usage .= "\n$g->{d}:\n";
1683  ***      0                           0         foreach my $spec (
      ***      0                           0   
1684  ***      0                           0            sort { $a->{l} cmp $b->{l} } grep { $_->{g} eq $g->{k} } @specs )
1685                                                 {
1686  ***      0      0                    0            my $long  = $spec->{n} ? "[no]$spec->{l}" : $spec->{l};
1687  ***      0                           0            my $short = $spec->{t};
1688  ***      0                           0            my $desc  = $spec->{d};
1689  ***      0      0      0             0            if ( $spec->{y} && $spec->{y} eq 'm' ) {
1690  ***      0                           0               my ($s) = $desc =~ m/\(suffix (.)\)/;
1691  ***      0             0             0               $s    ||= 's';
1692  ***      0                           0               $desc =~ s/\s+\(suffix .\)//;
1693  ***      0                           0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
1694                                                              . "d=days; if no suffix, $s is used.";
1695                                                    }
1696  ***      0                           0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                           0   
1697  ***      0                           0            $desc =~ s/ +$//mg;
1698  ***      0      0                    0            if ( $short ) {
1699  ***      0                           0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
1700                                                    }
1701                                                    else {
1702  ***      0                           0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
1703                                                    }
1704                                                 }
1705                                              }
1706                                           
1707  ***      0      0                    0      if ( (my @instr = @{$self->{instr}}) ) {
      ***      0                           0   
1708  ***      0                           0         $usage .= join("\n", map { "  $_" } @instr) . "\n";
      ***      0                           0   
1709                                              }
1710  ***      0      0                    0      if ( $self->{dsn} ) {
1711  ***      0                           0         $usage .= "\n" . $self->{dsn}->usage();
1712                                              }
1713  ***      0                           0      $usage .= "\nOptions and values after processing arguments:\n";
1714  ***      0                           0      foreach my $spec ( sort { $a->{l} cmp $b->{l} } @specs ) {
      ***      0                           0   
1715  ***      0                           0         my $val   = $vals{$spec->{k}};
1716  ***      0             0             0         my $type  = $spec->{y} || '';
1717  ***      0                           0         my $bool  = $spec->{s} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
1718  ***      0      0                    0         $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                        
      ***             0                        
      ***             0                        
      ***             0                        
      ***             0                        
1719                                                           : !defined $val             ? '(No value)'
1720                                                           : $type eq 'd'              ? $self->{dsn}->as_string($val)
1721                                                           : $type =~ m/H|h/           ? join(',', sort keys %$val)
1722                                                           : $type =~ m/A|a/           ? join(',', @$val)
1723                                                           :                             $val;
1724  ***      0                           0         $usage .= sprintf("  --%-${lcol}s  %s\n", $spec->{l}, $val);
1725                                              }
1726  ***      0                           0      return $usage;
1727                                           }
1728                                           
1729                                           sub prompt_noecho {
1730  ***      0      0             0      0      shift @_ if ref $_[0] eq __PACKAGE__;
1731  ***      0                           0      my ( $prompt ) = @_;
1732  ***      0                           0      local $OUTPUT_AUTOFLUSH = 1;
1733  ***      0      0                    0      print $prompt
1734                                                 or die "Cannot print: $OS_ERROR";
1735  ***      0                           0      my $response;
1736  ***      0                           0      eval {
1737  ***      0                           0         require Term::ReadKey;
1738  ***      0                           0         Term::ReadKey::ReadMode('noecho');
1739  ***      0                           0         chomp($response = <STDIN>);
1740  ***      0                           0         Term::ReadKey::ReadMode('normal');
1741  ***      0      0                    0         print "\n"
1742                                                    or die "Cannot print: $OS_ERROR";
1743                                              };
1744  ***      0      0                    0      if ( $EVAL_ERROR ) {
1745  ***      0                           0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
1746                                              }
1747  ***      0                           0      return $response;
1748                                           }
1749                                           
1750                                           sub groups {
1751  ***      0                    0      0      my ( $self, @groups ) = @_;
1752  ***      0                           0      push @{$self->{groups}}, @groups;
      ***      0                           0   
1753                                           }
1754                                           
1755           7                          23   if ( MKDEBUG ) {
1756                                              print '# ', $^X, ' ', $], "\n";
1757                                              my $uname = `uname -a`;
1758                                              if ( $uname ) {
1759                                                 $uname =~ s/\s+/ /g;
1760                                                 print "# $uname\n";
1761                                              }
1762                                              printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
1763                                                 $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
1764                                                 ($main::SVN_REV || ''), __LINE__);
1765                                              print('# Arguments: ',
1766                                                 join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
1767                                           }
1768                                           
1769                                           sub _d {
1770  ***      0                    0      0      my ($package, undef, $line) = caller 0;
1771  ***      0      0                    0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                           0   
      ***      0                           0   
1772  ***      0                           0           map { defined $_ ? $_ : 'undef' }
1773                                                   @_;
1774  ***      0                           0      print "# $package:$line $$ ", @_, "\n";
1775                                           }
1776                                           
1777           7                          27   1;
1778                                           
1779                                           # ###########################################################################
1780                                           # End OptionParser package
1781                                           # ###########################################################################
1782                                           
1783                                           # ###########################################################################
1784                                           # KeySize package 2864
1785                                           # ###########################################################################
1786                                           package KeySize;
1787                                           
1788           7                    7     80   use strict;
               7                          18   
               7                          62   
1789           7                    7     55   use warnings FATAL => 'all';
               7                          19   
               7                          49   
1790           7                    7     45   use English qw(-no_match_vars);
               7                          18   
               7                          46   
1791                                           
1792           7                    7     56   use constant MKDEBUG => $ENV{MKDEBUG};
               7                          17   
               7                          62   
1793                                           
1794                                           sub new {
1795           5                    5     27      my ( $class, %args ) = @_;
1796           5                          21      my $self = {};
1797           5                          24      return bless $self, $class;
1798                                           }
1799                                           
1800                                           sub get_key_size {
1801           2                    2     11      my ( $self, %args ) = @_;
1802           2                          10      foreach my $arg ( qw(tbl key dbh) ) {
1803  ***      6     50                   43         die "I need a $arg argument" unless $args{$arg};
1804                                              }
1805           2                           8      my $key = $args{key};
1806           2                           8      foreach my $req_key ( qw(name cols) ) {
1807  ***      4     50                   24         die "The key hashref argument does not have a $req_key key"
1808                                                    unless exists $key->{$req_key};
1809                                              }
1810                                           
1811           2                           7      my $sql = 'EXPLAIN SELECT ' . join(', ', @{$key->{cols}})
               2                          22   
1812                                                      . ' FROM ' . $args{tbl}
1813                                                      . " FORCE INDEX (`$key->{name}`)"
1814                                                      . ' WHERE ';
1815           2                           6      my @where_cols;
1816           2                           8      foreach my $col ( @{$key->{cols}} ) {
               2                           9   
1817           2                          11         push @where_cols, "$col=1";
1818                                              }
1819  ***      2     50                    6      if ( scalar @{$key->{cols}} == 1 ) {
               2                          20   
1820           2                          13         push @where_cols, "$key->{cols}->[0]<>1";
1821                                              }
1822           2                           9      $sql .= join(' OR ', @where_cols);
1823           2                           4      MKDEBUG && _d("key size sql: $sql");
1824                                           
1825           2                           8      my $explain = $args{dbh}->selectall_hashref($sql, 'id');
1826           2                         530      my $key_len = $explain->{1}->{key_len};
1827           2                           9      my $rows    = $explain->{1}->{rows};
1828                                           
1829           2                           8      my $key_size = 0;
1830  ***      2     50     33            16      if ( defined $key_len && defined $rows ) {
1831  ***      0                           0         $key_size = $key_len * $rows;
1832                                              }
1833                                              elsif ( MKDEBUG ) {
1834                                                 _d("key_len or rows NULL in EXPLAIN:\n"
1835                                                    . join("\n",
1836                                                       map { "$_: ".($explain->{1}->{$_} ? $explain->{1}->{$_} : 'NULL') }
1837                                                       keys %{$explain->{1}}));
1838                                              }
1839                                           
1840           2                          18      return $key_size;
1841                                           }
1842                                           
1843                                           sub _d {
1844  ***      0                    0      0      my ($package, undef, $line) = caller 0;
1845  ***      0      0                    0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                           0   
      ***      0                           0   
1846  ***      0                           0           map { defined $_ ? $_ : 'undef' }
1847                                                   @_;
1848  ***      0                           0      print "# $package:$line $$ ", @_, "\n";
1849                                           }
1850                                           
1851           7                          21   1;
1852                                           
1853                                           # ###########################################################################
1854                                           # End KeySize package
1855                                           # ###########################################################################
1856                                           
1857                                           # ###########################################################################
1858                                           # DuplicateKeyFinder package 3097
1859                                           # ###########################################################################
1860                                           package DuplicateKeyFinder;
1861                                           
1862           7                    7     54   use strict;
               7                          18   
               7                          38   
1863           7                    7     46   use warnings FATAL => 'all';
               7                          19   
               7                          36   
1864           7                    7     47   use English qw(-no_match_vars);
               7                          17   
               7                          36   
1865                                           
1866           7                    7     53   use List::Util qw(min);
               7                          19   
               7                          71   
1867                                           
1868           7                    7     50   use constant MKDEBUG => $ENV{MKDEBUG};
               7                          18   
               7                          49   
1869                                           
1870                                           sub new {
1871           7                    7     32      my ( $class ) = @_;
1872           7                          52      my $self = {
1873                                                 keys        => undef,  # copy of last keys that we worked on
1874                                                 unique_cols => undef,  # unique cols for those last keys (hashref)
1875                                                 unique_sets => undef,  # unique sets for those last keys (arrayref) 
1876                                              };
1877           7                          34      return bless $self, $class;
1878                                           }
1879                                           
1880                                           sub get_duplicate_keys {
1881           5                    5     39      my ( $self, %args ) = @_;
1882  ***      5     50                   38      die "I need a keys argument" unless $args{keys};
1883           5                          18      my %all_keys  = %{$args{keys}}; # copy keys because we change stuff
               5                          36   
1884           5                          24      $self->{keys} = \%all_keys;
1885           5                          12      my $primary_key;
1886           5                          14      my @unique_keys;
1887           5                          11      my @normal_keys;
1888           5                          16      my @fulltext_keys;
1889           5                          31      my %pass_args = %args;
1890           5                          24      delete $pass_args{keys};
1891                                           
1892                                              ALL_KEYS:
1893           5                          22      foreach my $key ( values %all_keys ) {
1894           9                          42         $key->{real_cols} = $key->{colnames}; 
1895           9                          44         $key->{len_cols}  = length $key->{colnames};
1896                                           
1897           9    100                   50         if ( $key->{name} eq 'PRIMARY' ) {
1898           1                           3            $primary_key = $key;
1899           1                           4            next ALL_KEYS;
1900                                                 }
1901                                           
1902  ***      8     50                   43         my $is_fulltext = $key->{type} eq 'FULLTEXT' ? 1 : 0;
1903                                           
1904  ***      8     50     33            97         if ( $args{ignore_order} || $is_fulltext  ) {
1905  ***      0                           0            my $ordered_cols = join(',', sort(split(/,/, $key->{colnames})));
1906  ***      0                           0            MKDEBUG && _d("Reordered $key->{name} cols "
1907                                                       . "from ($key->{colnames}) to ($ordered_cols)"); 
1908  ***      0                           0            $key->{colnames} = $ordered_cols;
1909                                                 }
1910                                           
1911           8    100                   51         my $push_to = $key->{is_unique} ? \@unique_keys : \@normal_keys;
1912  ***      8     50                   45         if ( !$args{ignore_type} ) {
1913  ***      8     50                   37            $push_to = \@fulltext_keys if $is_fulltext;
1914                                                 }
1915           8                          35         push @$push_to, $key; 
1916                                              }
1917                                           
1918           5                          17      my @dupes;
1919                                           
1920           5                          14      MKDEBUG && _d('Start unconstraining redundantly unique keys');
1921           5                          13      my %unique_cols;
1922           5                          17      my @unique_sets;
1923           5                          15      my %unconstrain;   # unique keys to unconstrain
1924                                              UNIQUE_KEY:
1925           5                          22      foreach my $unique_key ( $primary_key, @unique_keys ) {
1926           7    100                   50         next unless $unique_key; # primary key may be undefined
1927           3                          12         my $cols = $unique_key->{cols};
1928           3    100                   16         if ( @$cols == 1 ) {
1929           1                           3            MKDEBUG && _d("$unique_key->{name} defines unique column: $cols->[0]");
1930  ***      1     50                    7            if ( !exists $unique_cols{$cols->[0]} ) {
1931           1                           4               $unique_cols{$cols->[0]}  = $unique_key;
1932           1                           5               $unique_key->{unique_col} = 1;
1933                                                    }
1934                                                 }
1935                                                 else {
1936           2                          10            local $LIST_SEPARATOR = '-';
1937           2                           9            MKDEBUG && _d("$unique_key->{name} defines unique set: @$cols");
1938           2                          16            push @unique_sets, { cols => $cols, key => $unique_key };
1939                                                 }
1940                                              }
1941                                           
1942                                              UNIQUE_SET:
1943           5                          22      foreach my $unique_set ( @unique_sets ) {
1944           2                           7         my $n_unique_cols = 0;
1945           2                          12         COL:
1946           2                           6         foreach my $col ( @{$unique_set->{cols}} ) {
1947           7    100                   39            if ( exists $unique_cols{$col} ) {
1948           1                           3               MKDEBUG && _d("Unique set $unique_set->{key}->{name} "
1949                                                          . "has unique col $col");
1950  ***      1     50                    6               last COL if ++$n_unique_cols > 1;
1951           1                           5               $unique_set->{constraining_key} = $unique_cols{$col};
1952                                                    }
1953                                                 }
1954  ***      2    100     66            28         if ( $n_unique_cols && $unique_set->{key}->{name} ne 'PRIMARY' ) {
1955           1                           3            MKDEBUG && _d("Will unconstrain unique set $unique_set->{key}->{name} "
1956                                                       . "because it is redundantly constrained by key "
1957                                                       . $unique_set->{constraining_key}->{name}
1958                                                       . " ($unique_set->{constraining_key}->{colnames})");
1959           1                          11            $unconstrain{$unique_set->{key}->{name}}
1960                                                       = $unique_set->{constraining_key};
1961                                                 }
1962                                              }
1963                                           
1964           5                          37      for my $i ( 0..$#unique_keys ) {
1965           2    100                   13         if ( exists $unconstrain{$unique_keys[$i]->{name}} ) {
1966           1                           2            MKDEBUG && _d("Normalizing $unique_keys[$i]->{name}");
1967           1                           8            $unique_keys[$i]->{unconstrained} = 1;
1968           1                           6            $unique_keys[$i]->{constraining_key}
1969                                                       = $unconstrain{$unique_keys[$i]->{name}};
1970           1                           3            push @normal_keys, $unique_keys[$i];
1971           1                           8            delete $unique_keys[$i];
1972                                                 }
1973                                              }
1974           5                          27      $self->{unique_cols} = \%unique_cols;
1975           5                          19      $self->{unique_sets} = \@unique_sets;
1976           5                          15      MKDEBUG && _d('No more keys');
1977                                           
1978           5    100                   31      if ( $primary_key ) {
1979           1                           3         MKDEBUG && _d('Start comparing PRIMARY KEY to UNIQUE keys');
1980           1                          10         $self->remove_prefix_duplicates(
1981                                                       keys           => [$primary_key],
1982                                                       remove_keys    => \@unique_keys,
1983                                                       duplicate_keys => \@dupes,
1984                                                       %pass_args);
1985                                           
1986           1                           3         MKDEBUG && _d('Start comparing PRIMARY KEY to normal keys');
1987           1                           8         $self->remove_prefix_duplicates(
1988                                                       keys           => [$primary_key],
1989                                                       remove_keys    => \@normal_keys,
1990                                                       duplicate_keys => \@dupes,
1991                                                       %pass_args);
1992                                              }
1993                                           
1994           5                          14      MKDEBUG && _d('Start comparing UNIQUE keys to normal keys');
1995           5                          46      $self->remove_prefix_duplicates(
1996                                                    keys           => \@unique_keys,
1997                                                    remove_keys    => \@normal_keys,
1998                                                    duplicate_keys => \@dupes,
1999                                                    %pass_args);
2000                                           
2001           5                          16      MKDEBUG && _d('Start comparing normal keys');
2002           5                          35      $self->remove_prefix_duplicates(
2003                                                    keys           => \@normal_keys,
2004                                                    duplicate_keys => \@dupes,
2005                                                    %pass_args);
2006                                           
2007           5                          16      MKDEBUG && _d('Start comparing FULLTEXT keys');
2008           5                          36      $self->remove_prefix_duplicates(
2009                                                    keys             => \@fulltext_keys,
2010                                                    exact_duplicates => 1,
2011                                                    %pass_args);
2012                                           
2013                                           
2014  ***      5     50     66            72      if ( $primary_key
      ***                   66                 
2015                                                   && $args{clustered}
2016                                                   && $args{tbl_info}->{engine} =~ m/^(?:InnoDB|solidDB)$/ ) {
2017                                           
2018  ***      0                           0         MKDEBUG && _d('Start removing UNIQUE dupes of clustered key');
2019  ***      0                           0         $self->remove_clustered_duplicates(
2020                                                       primary_key => $primary_key,
2021                                                       keys        => \@unique_keys,
2022                                                       %pass_args);
2023                                           
2024  ***      0                           0         MKDEBUG && _d('Start removing ordinary dupes of clustered key');
2025  ***      0                           0         $self->remove_clustered_duplicates(
2026                                                       primary_key => $primary_key,
2027                                                       keys        => \@normal_keys,
2028                                                       %pass_args);
2029                                              }
2030                                           
2031           5                          36      return \@dupes;
2032                                           }
2033                                           
2034                                           sub get_duplicate_fks {
2035           5                    5     32      my ( $self, %args ) = @_;
2036  ***      5     50                   28      die "I need a keys argument" unless $args{keys};
2037           5                          17      my @fks = values %{$args{keys}};
               5                          22   
2038           5                          16      my @dupes;
2039           5                          32      foreach my $i ( 0..$#fks - 1 ) {
2040  ***      0      0                    0         next unless $fks[$i];
2041  ***      0                           0         foreach my $j ( $i+1..$#fks ) {
2042  ***      0      0                    0            next unless $fks[$j];
2043  ***      0                           0            my $i_cols = join(', ',
2044  ***      0                           0               map { "`$_`" } sort($fks[$i]->{cols} =~ m/`([^`]+)`/g));
2045  ***      0                           0            my $j_cols = join(', ',
2046  ***      0                           0               map { "`$_`" } sort($fks[$j]->{cols} =~ m/`([^`]+)`/g));
2047  ***      0                           0            my $i_fkcols = join(', ',
2048  ***      0                           0               map { "`$_`" } sort($fks[$i]->{fkcols} =~ m/`([^`]+)`/g));
2049  ***      0                           0            my $j_fkcols = join(', ',
2050  ***      0                           0               map { "`$_`" } sort($fks[$j]->{fkcols} =~ m/`([^`]+)`/g));
2051                                           
2052  ***      0      0      0             0            if ( $fks[$i]->{parent} eq $fks[$j]->{parent}
      ***                    0                 
2053                                                         && $i_cols   eq $j_cols
2054                                                         && $i_fkcols eq $j_fkcols ) {
2055  ***      0                           0               my $dupe = {
2056                                                          key               => $fks[$j]->{name},
2057                                                          cols              => $fks[$j]->{cols},
2058                                                          duplicate_of      => $fks[$i]->{name},
2059                                                          duplicate_of_cols => $fks[$i]->{cols},
2060                                                          reason       =>
2061                                                               "FOREIGN KEY $fks[$j]->{name} ($fks[$j]->{cols}) "
2062                                                             . "REFERENCES $fks[$j]->{parent} ($fks[$j]->{fkcols}) "                     .  'is a duplicate of '
2063                                                             . "FOREIGN KEY $fks[$i]->{name} ($fks[$i]->{cols}) "
2064                                                             . "REFERENCES $fks[$i]->{parent} ($fks[$i]->{fkcols})"
2065                                                       };
2066  ***      0                           0               push @dupes, $dupe;
2067  ***      0                           0               delete $fks[$j];
2068  ***      0      0                    0               $args{callback}->($dupe, %args) if $args{callback};
2069                                                    }
2070                                                 }
2071                                              }
2072           5                          27      return \@dupes;
2073                                           }
2074                                           
2075                                           sub remove_prefix_duplicates {
2076          17                   17    118      my ( $self, %args ) = @_;
2077          17                          41      my $keys;
2078          17                          43      my $remove_keys;
2079          17                          58      my @dupes;
2080          17                          40      my $keep_index;
2081          17                          45      my $remove_index;
2082          17                          41      my $last_key;
2083          17                          42      my $remove_key_offset;
2084                                           
2085          17                          55      $keys  = $args{keys};
2086           3                          13      @$keys = sort { $a->{colnames} cmp $b->{colnames} }
              10                          47   
2087          17                          80               grep { defined $_; }
2088                                                       @$keys;
2089                                           
2090          17    100                   89      if ( $args{remove_keys} ) {
2091           7                          24         $remove_keys  = $args{remove_keys};
2092           3                          20         @$remove_keys = sort { $a->{colnames} cmp $b->{colnames} }
               7                          31   
2093           7                          35                         grep { defined $_; }
2094                                                                 @$remove_keys;
2095                                           
2096           7                          32         $remove_index      = 1;
2097           7                          28         $keep_index        = 0;
2098           7                          27         $last_key          = scalar(@$keys) - 1;
2099           7                          22         $remove_key_offset = 0;
2100                                              }
2101                                              else {
2102          10                          30         $remove_keys       = $keys;
2103          10                          29         $remove_index      = 0;
2104          10                          26         $keep_index        = 1;
2105          10                          33         $last_key          = scalar(@$keys) - 2;
2106          10                          35         $remove_key_offset = 1;
2107                                              }
2108          17                          58      my $last_remove_key = scalar(@$remove_keys) - 1;
2109                                           
2110                                              I_KEY:
2111          17                          75      foreach my $i ( 0..$last_key ) {
2112  ***      6     50                   46         next I_KEY unless defined $keys->[$i];
2113                                           
2114                                                 J_KEY:
2115           6                          30         foreach my $j ( $i+$remove_key_offset..$last_remove_key ) {
2116  ***      4     50                   26            next J_KEY unless defined $remove_keys->[$j];
2117                                           
2118           4                          17            my $keep = ($i, $j)[$keep_index];
2119           4                          16            my $rm   = ($i, $j)[$remove_index];
2120                                           
2121           4                          17            my $keep_name     = $keys->[$keep]->{name};
2122           4                          19            my $keep_cols     = $keys->[$keep]->{colnames};
2123           4                          18            my $keep_len_cols = $keys->[$keep]->{len_cols};
2124           4                          17            my $rm_name       = $remove_keys->[$rm]->{name};
2125           4                          18            my $rm_cols       = $remove_keys->[$rm]->{colnames};
2126           4                          17            my $rm_len_cols   = $remove_keys->[$rm]->{len_cols};
2127                                           
2128           4                          14            MKDEBUG && _d("Comparing [keep] $keep_name ($keep_cols) "
2129                                                       . "to [remove if dupe] $rm_name ($rm_cols)");
2130                                           
2131           4    100                   36            if (    substr($rm_cols, 0, $rm_len_cols)
2132                                                         eq substr($keep_cols, 0, $rm_len_cols) ) {
2133                                           
2134  ***      3     50     33            26               if ( $args{exact_duplicates} && ($rm_len_cols < $keep_len_cols) ) {
2135  ***      0                           0                  MKDEBUG && _d("$rm_name not exact duplicate of $keep_name");
2136  ***      0                           0                  next J_KEY;
2137                                                       }
2138                                           
2139  ***      3     50                   19               if ( exists $remove_keys->[$rm]->{unique_col} ) {
2140  ***      0                           0                  MKDEBUG && _d("Cannot remove $rm_name because is constrains col "
2141                                                             . $remove_keys->[$rm]->{cols}->[0]);
2142  ***      0                           0                  next J_KEY;
2143                                                       }
2144                                           
2145           3                           8               MKDEBUG && _d("Remove $remove_keys->[$rm]->{name}");
2146           3                           9               my $reason;
2147  ***      3     50                   17               if ( $remove_keys->[$rm]->{unconstrained} ) {
2148  ***      0                           0                  $reason .= "Uniqueness of $rm_name ignored because "
2149                                                                   . $remove_keys->[$rm]->{constraining_key}->{name}
2150                                                                   . " is a stronger constraint\n"; 
2151                                                       }
2152  ***      3     50                   22               $reason .= $rm_name
2153                                                                . ($rm_len_cols < $keep_len_cols ? ' is a left-prefix of '
2154                                                                                                 : ' is a duplicate of ')
2155                                                                . $keep_name;
2156           3                          32               my $dupe = {
2157                                                          key               => $rm_name,
2158                                                          cols              => $remove_keys->[$rm]->{real_cols},
2159                                                          duplicate_of      => $keep_name,
2160                                                          duplicate_of_cols => $keys->[$keep]->{real_cols},
2161                                                          reason            => $reason,
2162                                                       };
2163           3                           9               push @dupes, $dupe;
2164           3                          16               delete $remove_keys->[$rm];
2165                                           
2166  ***      3     50                   35               $args{callback}->($dupe, %args) if $args{callback};
2167                                           
2168  ***      3     50                   29               next I_KEY if $remove_index == 0;
2169  ***      0      0                    0               next J_KEY if $remove_index == 1;
2170                                                    }
2171                                                    else {
2172           1                           6               MKDEBUG && _d("$rm_name not left-prefix of $keep_name");
2173           1                           5               next I_KEY;
2174                                                    }
2175                                                 }
2176                                              }
2177          17                          42      MKDEBUG && _d('No more keys');
2178                                           
2179          17                          65      @$keys        = grep { defined $_; } @$keys;
              10                          42   
2180          17    100                  100      @$remove_keys = grep { defined $_; } @$remove_keys if $args{remove_keys};
               7                          30   
2181  ***     17     50                   89      push @{$args{duplicate_keys}}, @dupes if $args{duplice_keys};
      ***      0                           0   
2182                                           
2183          17                          75      return;
2184                                           }
2185                                           
2186                                           sub remove_clustered_duplicates {
2187  ***      0                    0      0      my ( $self, %args ) = @_;
2188  ***      0      0                    0      die "I need a primary_key argument" unless $args{primary_key};
2189  ***      0      0                    0      die "I need a keys argument"        unless $args{keys};
2190  ***      0                           0      my $pkcols = $args{primary_key}->{colnames};
2191  ***      0                           0      my $keys   = $args{keys};
2192  ***      0                           0      my @dupes;
2193                                              KEY:
2194  ***      0                           0      for my $i ( 0 .. @$keys - 1 ) {
2195  ***      0                           0         my $suffix = $keys->[$i]->{colnames};
2196                                                 SUFFIX:
2197  ***      0                           0         while ( $suffix =~ s/`[^`]+`,// ) {
2198  ***      0                           0            my $len = min(length($pkcols), length($suffix));
2199  ***      0      0                    0            if ( substr($suffix, 0, $len) eq substr($pkcols, 0, $len) ) {
2200  ***      0                           0               my $dupe = {
2201                                                          key               => $keys->[$i]->{name},
2202                                                          cols              => $keys->[$i]->{real_cols},
2203                                                          duplicate_of      => $args{primary_key}->{name},
2204                                                          duplicate_of_cols => $args{primary_key}->{real_cols},
2205                                                          reason            => "Key $keys->[$i]->{name} "
2206                                                                               . "ends with a prefix of the clustered "
2207                                                                               . "index",
2208                                                       };
2209  ***      0                           0               push @dupes, $dupe;
2210  ***      0                           0               delete $keys->[$i];
2211  ***      0      0                    0               $args{callback}->($dupe, %args) if $args{callback};
2212  ***      0                           0               last SUFFIX;
2213                                                    }
2214                                                 }
2215                                              }
2216  ***      0                           0      MKDEBUG && _d('No more keys');
2217                                           
2218  ***      0                           0      @$keys = grep { defined $_; } @$keys;
      ***      0                           0   
2219  ***      0      0                    0      push @{$args{duplicate_keys}}, @dupes if $args{duplice_keys};
      ***      0                           0   
2220                                           
2221  ***      0                           0      return;
2222                                           }
2223                                           
2224                                           sub _d {
2225  ***      0                    0      0      my ($package, undef, $line) = caller 0;
2226  ***      0      0                    0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                           0   
      ***      0                           0   
2227  ***      0                           0           map { defined $_ ? $_ : 'undef' }
2228                                                   @_;
2229  ***      0                           0      print "# $package:$line $$ ", @_, "\n";
2230                                           }
2231                                           
2232           7                          21   1;
2233                                           # ###########################################################################
2234                                           # End DuplicateKeyFinder package
2235                                           # ###########################################################################
2236                                           
2237                                           # ###########################################################################
2238                                           # Transformers package 2999
2239                                           # ###########################################################################
2240                                           
2241                                           package Transformers;
2242                                           
2243           7                    7     55   use strict;
               7                          20   
               7                          50   
2244           7                    7     48   use warnings FATAL => 'all';
               7                          21   
               7                          40   
2245           7                    7     48   use English qw(-no_match_vars);
               7                          16   
               7                          36   
2246           7                    7    106   use Time::Local qw(timelocal);
               7                          22   
               7                          71   
2247           7                    7     55   use Digest::MD5 qw(md5_hex);
               7                          17   
               7                          52   
2248                                           
2249           7                    7     49   use constant MKDEBUG => $ENV{MKDEBUG};
               7                          18   
               7                          81   
2250                                           
2251           7                          53   require Exporter;
2252           7                          48   our @ISA         = qw(Exporter);
2253           7                          28   our %EXPORT_TAGS = ();
2254           7                          30   our @EXPORT      = ();
2255           7                          48   our @EXPORT_OK   = qw(
2256                                              micro_t
2257                                              percentage_of
2258                                              secs_to_time
2259                                              shorten
2260                                              ts
2261                                              parse_timestamp
2262                                              unix_timestamp
2263                                              make_checksum
2264                                           );
2265                                           
2266                                           sub micro_t {
2267  ***      0                    0      0      my ( $t, %args ) = @_;
2268  ***      0      0                    0      my $p_ms = defined $args{p_ms} ? $args{p_ms} : 0;  # precision for ms vals
2269  ***      0      0                    0      my $p_s  = defined $args{p_s}  ? $args{p_s}  : 0;  # precision for s vals
2270  ***      0                           0      my $f;
2271                                           
2272  ***      0      0                    0      $t = 0 if $t < 0;
2273                                           
2274  ***      0      0                    0      $t = sprintf('%.17f', $t) if $t =~ /e/;
2275                                           
2276  ***      0                           0      $t =~ s/\.(\d{1,6})\d*/\.$1/;
2277                                           
2278  ***      0      0      0             0      if ($t > 0 && $t <= 0.000999) {
      ***             0      0                 
      ***             0                        
2279  ***      0                           0         $f = ($t * 1000000) . 'us';
2280                                              }
2281                                              elsif ($t >= 0.001000 && $t <= 0.999999) {
2282  ***      0                           0         $f = sprintf("%.${p_ms}f", $t * 1000);
2283  ***      0                           0         $f = ($f * 1) . 'ms'; # * 1 to remove insignificant zeros
2284                                              }
2285                                              elsif ($t >= 1) {
2286  ***      0                           0         $f = sprintf("%.${p_s}f", $t);
2287  ***      0                           0         $f = ($f * 1) . 's'; # * 1 to remove insignificant zeros
2288                                              }
2289                                              else {
2290  ***      0                           0         $f = 0;  # $t should = 0 at this point
2291                                              }
2292                                           
2293  ***      0                           0      return $f;
2294                                           }
2295                                           
2296                                           sub percentage_of {
2297  ***      0                    0      0      my ( $is, $of, %args ) = @_;
2298  ***      0             0             0      my $p   = $args{p} || 0; # float precision
2299  ***      0      0                    0      my $fmt = $p ? "%.${p}f" : "%d";
2300  ***      0             0             0      return sprintf $fmt, ($is * 100) / ($of ||= 1);
2301                                           }
2302                                           
2303                                           sub secs_to_time {
2304  ***      0                    0      0      my ( $secs, $fmt ) = @_;
2305  ***      0             0             0      $secs ||= 0;
2306  ***      0      0                    0      return '00:00' unless $secs;
2307                                           
2308  ***      0      0      0             0      $fmt ||= $secs >= 86_400 ? 'd'
      ***             0                        
2309                                                     : $secs >= 3_600  ? 'h'
2310                                                     :                   'm';
2311                                           
2312                                              return
2313  ***      0      0                    0         $fmt eq 'd' ? sprintf(
      ***             0                        
2314                                                    "%d+%02d:%02d:%02d",
2315                                                    int($secs / 86_400),
2316                                                    int(($secs % 86_400) / 3_600),
2317                                                    int(($secs % 3_600) / 60),
2318                                                    $secs % 60)
2319                                                 : $fmt eq 'h' ? sprintf(
2320                                                    "%02d:%02d:%02d",
2321                                                    int(($secs % 86_400) / 3_600),
2322                                                    int(($secs % 3_600) / 60),
2323                                                    $secs % 60)
2324                                                 : sprintf(
2325                                                    "%02d:%02d",
2326                                                    int(($secs % 3_600) / 60),
2327                                                    $secs % 60);
2328                                           }
2329                                           
2330                                           sub shorten {
2331  ***      0                    0      0      my ( $num, %args ) = @_;
2332  ***      0      0                    0      my $p = defined $args{p} ? $args{p} : 2;     # float precision
2333  ***      0      0                    0      my $d = defined $args{d} ? $args{d} : 1_024; # divisor
2334  ***      0                           0      my $n = 0;
2335  ***      0                           0      my @units = ('', qw(k M G T P E Z Y));
2336  ***      0             0             0      while ( $num >= $d && $n < @units - 1 ) {
2337  ***      0                           0         $num /= $d;
2338  ***      0                           0         ++$n;
2339                                              }
2340  ***      0      0      0             0      return sprintf(
2341                                                 $num =~ m/\./ || $n
2342                                                    ? "%.${p}f%s"
2343                                                    : '%d',
2344                                                 $num, $units[$n]);
2345                                           }
2346                                           
2347                                           sub ts {
2348  ***      0                    0      0      my ( $time ) = @_;
2349  ***      0                           0      my ( $sec, $min, $hour, $mday, $mon, $year )
2350                                                 = localtime($time);
2351  ***      0                           0      $mon  += 1;
2352  ***      0                           0      $year += 1900;
2353  ***      0                           0      return sprintf("%d-%02d-%02dT%02d:%02d:%02d",
2354                                                 $year, $mon, $mday, $hour, $min, $sec);
2355                                           }
2356                                           
2357                                           sub parse_timestamp {
2358  ***      0                    0      0      my ( $val ) = @_;
2359  ***      0      0                    0      if ( my($y, $m, $d, $h, $i, $s)
2360                                                    = $val =~ m/^(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)$/ )
2361                                              {
2362  ***      0                           0         return sprintf "%d-%02d-%02d %02d:%02d:%02d",
2363                                                                $y + 2000, $m, $d, $h, $i, $s;
2364                                              }
2365  ***      0                           0      return $val;
2366                                           }
2367                                           
2368                                           sub unix_timestamp {
2369  ***      0                    0      0      my ( $val ) = @_;
2370  ***      0      0                    0      if ( my($y, $m, $d, $h, $i, $s)
2371                                                    = $val =~ m/^(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)$/ )
2372                                              {
2373  ***      0                           0         return timelocal($s, $i, $h, $d, $m - 1, $y);
2374                                              }
2375  ***      0                           0      return $val;
2376                                           }
2377                                           
2378                                           sub make_checksum {
2379  ***      0                    0      0      my ( $val ) = @_;
2380  ***      0                           0      my $checksum = uc substr(md5_hex($val), -16);
2381  ***      0                           0      MKDEBUG && _d("$checksum checksum for $val");
2382  ***      0                           0      return $checksum;
2383                                           }
2384                                           
2385                                           sub _d {
2386  ***      0                    0      0      my ($package, undef, $line) = caller 0;
2387  ***      0      0                    0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                           0   
      ***      0                           0   
2388  ***      0                           0           map { defined $_ ? $_ : 'undef' }
2389                                                   @_;
2390  ***      0                           0      print "# $package:$line $$ ", @_, "\n";
2391                                           }
2392                                           
2393           7                          21   1;
2394                                           
2395                                           # ###########################################################################
2396                                           # End Transformers package
2397                                           # ###########################################################################
2398                                           
2399                                           # #############################################################################
2400                                           # And now for the "program".
2401                                           # #############################################################################
2402                                           package main;
2403                                           
2404           7                    7     54   use English qw(-no_match_vars);
               7                          20   
               7                          41   
2405           7                    7     50   use Getopt::Long;
               7                          34   
               7                          56   
2406           7                    7     50   use List::Util qw(max);
               7                          16   
               7                          55   
2407                                           
2408           7                         102   Transformers->import(qw(shorten));
2409                                           
2410           7                    7     53   use constant MKDEBUG => $ENV{MKDEBUG};
               7                          17   
               7                          47   
2411                                           
2412           7                        1593   $OUTPUT_AUTOFLUSH = 1;
2413                                           
2414                                           # ##########################################################################
2415                                           # Get configuration information.
2416                                           # ##########################################################################
2417                                           
2418           7                          34   my @opt_spec   = OptionParser::pod_to_spec(); 
2419           7                          81   my $opt_parser = OptionParser->new(@opt_spec);
2420           7                          32   $opt_parser->{prompt} = '<options>';
2421           7                          35   $opt_parser->{descr}  = q{examines MySQL tables for duplicate or redundant }
2422                                                                 . q{indexes and foreign keys.  Connection options }
2423                                                                 . q{are read from MySQL option files.};
2424           7                          41   my %opts = $opt_parser->parse();
2425           7                          89   $opt_parser->usage_or_errors(%opts);
2426                                           
2427                                           # ##########################################################################
2428                                           # Get ready to do the main work.
2429                                           # ##########################################################################
2430                                           
2431                                           # Connect to the database
2432  ***      7     50     33           108   if ( !defined $opts{p} && $opts{askpass} ) {
2433  ***      0                           0      $opts{p} = OptionParser::prompt_noecho("Enter password: ");
2434                                           }
2435                                           
2436           7                          64   my $vp = new VersionParser();
2437           7                          56   my $dp = new DSNParser;
2438           7                          43   $dp->prop('setvars', $opts{setvars});
2439           7                          44   my $dbh = $dp->get_dbh( $dp->get_cxn_params(\%opts), { AutoCommit => 1 } );
2440                                           
2441           7                          43   my $version = $vp->parse($dbh->selectrow_array('SELECT VERSION()'));
2442                                           
2443           7                         296   my $max_width = 74;
2444           7                          34   my $hdr_width = $max_width - 2;  # for '# '
2445           7                          37   my $hdr_fmt   = "# %-${hdr_width}s\n";
2446                                           
2447           7                          21   my %summary;
2448           7                          22   my %seen_tbl;
2449           7    100                  161   my $ks = $opts{summary} ? new KeySize() : undef;
2450           7                          70   my $dk = new DuplicateKeyFinder();
2451           7                          60   my $q  = new Quoter();
2452           7                          56   my $tp = new TableParser();
2453           7                          69   my $du = new MySQLDump();
2454           7                          63   my %tp_opts = (
2455                                              ignore_type  => $opts{a},
2456                                              ignore_order => $opts{ignoreorder},
2457                                              clustered    => $opts{c},
2458                                           );
2459                                           
2460           7                         157   my $finder = new MySQLFind(
2461                                              quoter    => $q,
2462                                              useddl    => 1,
2463                                              parser    => $tp,
2464                                              dumper    => $du,
2465                                              databases => {
2466                                                 permit => $opts{d},
2467                                                 reject => $opts{g},
2468                                              },
2469                                              tables => {
2470                                                 permit => $opts{t},
2471                                                 reject => $opts{n},
2472                                              },
2473                                              engines => {
2474                                                 views  => 0,
2475                                                 permit => $opts{e},
2476                                                 reject => $opts{E},
2477                                              },
2478                                           );
2479                                           
2480                                           DATABASE:
2481           7                          49   foreach my $database ( $finder->find_databases($dbh) ) {
2482                                              TABLE:
2483           6                          41      foreach my $table ( $finder->find_tables($dbh, database => $database) ) {
2484           6                          40         my $ddl      = $du->get_create_table($dbh, $q, $database, $table)->[1];
2485  ***      6            33            25         my $engine   = $tp->get_engine($ddl) || next TABLE;
2486           6                          53         my $tbl_info = {
2487                                                    db     => $database,
2488                                                    tbl    => $table,
2489                                                    engine => $engine,
2490                                                    ddl    => $ddl,
2491                                                 };
2492                                           
2493  ***      6     50                   69         my $keys = $tp->get_keys($ddl,{version => $version }) if $opts{f} =~ m/k/;
2494  ***      6     50                   69         my $fks  = $tp->get_fks($ddl,{database => $database}) if $opts{f} =~ m/f/;
2495                                           
2496  ***      6     50     33            72         next TABLE unless %$keys || %$fks;
2497                                           
2498           6    100                   35         if ( $opts{v} ) {
2499  ***      1     50                    7            print_all_keys($keys, $tbl_info) if $keys;
2500  ***      1     50                    6            print_all_keys($fks,  $tbl_info) if $fks;
2501                                                 }
2502                                                 else {
2503  ***      5     50                   73            $dk->get_duplicate_keys(
2504                                                       keys     => $keys,
2505                                                       callback => \&print_duplicate_key,
2506                                                       tbl_info => $tbl_info,
2507                                                       %tp_opts,
2508                                                    ) if $keys;
2509                                           
2510  ***      5     50                   68            $dk->get_duplicate_fks(
2511                                                       keys     => $fks,
2512                                                       callback => \&print_duplicate_key,
2513                                                       tbl_info => $tbl_info,
2514                                                       %tp_opts,
2515                                                    ) if $fks;
2516                                                 }
2517           6    100                   88         $summary{'Total Keys'} += (scalar keys %$keys) + (scalar keys %$fks)
2518                                                    if $opts{summary};
2519                                              }
2520                                           }
2521                                           
2522           7    100                   72   print_key_summary(%summary) if $opts{summary};
2523                                           
2524           7                          38   exit;
2525                                           
2526                                           # ##########################################################################
2527                                           # Subroutines
2528                                           # ##########################################################################
2529                                           
2530                                           sub print_all_keys {
2531           2                    2      8      my ( $keys, $tbl_info ) = @_;
2532  ***      2     50                    9      return unless $keys;
2533           2                           8      my $db  = $tbl_info->{db};
2534           2                           7      my $tbl = $tbl_info->{tbl};
2535           2    100                   13      if ( !$seen_tbl{"$db$tbl"}++ ) {
2536           1                          43         printf $hdr_fmt, ('#' x $hdr_width);
2537           1                          15         printf $hdr_fmt, "$db.$tbl";
2538           1                          13         printf $hdr_fmt, ('#' x $hdr_width);
2539                                              }
2540           2                          10      foreach my $key ( values %$keys ) {
2541           1                          18         print "\n# $key->{name} ($key->{colnames})";
2542                                              }
2543           2                          19      print "\n";
2544           2                           8      return;
2545                                           }
2546                                           
2547                                           sub print_duplicate_key {
2548           3                    3     27      my ( $dupe, %args ) = @_;
2549  ***      3     50                   15      return unless $dupe;
2550           3                          14      my $db     = $args{tbl_info}->{db};
2551           3                          16      my $tbl    = $args{tbl_info}->{tbl};
2552           3                          19      my $struct = $tp->parse($args{tbl_info}->{ddl});
2553                                           
2554  ***      3     50                   31      if ( !$seen_tbl{"$db$tbl"}++ ) {
2555           3                         116         printf $hdr_fmt, ('#' x $hdr_width);
2556           3                          41         printf $hdr_fmt, "$db.$tbl";
2557           3                          33         printf $hdr_fmt, ('#' x $hdr_width);
2558           3                          26         print "\n";
2559                                              }
2560                                           
2561           3                          15      $dupe->{reason} =~ s/\n/\n# /g;
2562           3                          30      print "# $dupe->{reason}\n";
2563                                           
2564           3                          22      print "# Column types:\n";
2565           3                           9      my %seen_col;
2566           6    100                   25      my @cols = map { s/`//g; $_; }
               6                          33   
               9                          99   
2567           3                          27                 grep { $_ if !$seen_col{$_}++; }
2568                                                         split(',', "$dupe->{cols},$dupe->{duplicate_of_cols}");
2569           3                          15      foreach my $col ( @cols ) {
2570           6                          75         print "#\t" . $struct->{defs}->{$col} . "\n";
2571                                              }
2572                                           
2573           3    100                   32      print "# To remove this duplicate key, execute:\n"
2574                                                 . 'ALTER TABLE '.$q->quote($db, $tbl)." DROP KEY `$dupe->{key}`;\n"
2575                                                    if $opts{sql};
2576           3                          26      print "\n";
2577                                           
2578           3    100                   19      if ( $opts{summary} ) {
2579           2                          14         $summary{'Total Duplicate Keys'} += 1;
2580           2                          18         my $key_info = {
2581                                                    name => $dupe->{key},
2582                                                    cols => [ split(',', $dupe->{cols}) ],
2583                                                 };
2584           2                          13         $summary{'Size Duplicate Keys'} += $ks->get_key_size(
2585                                                    dbh => $dbh,
2586                                                    tbl => $q->quote($db, $tbl),
2587                                                    key => $key_info,
2588                                                 )
2589                                              }
2590           3                          52      return;
2591                                           }
2592                                           
2593                                           # TODO: would be nice to shorten/format some of these values.
2594                                           sub print_key_summary {
2595           5                    5     26      my ( %summary ) = @_;
2596           5                         149      printf $hdr_fmt, ('#' x $hdr_width);
2597           5                          60      printf $hdr_fmt, 'Summary of keys';
2598           5                          58      printf $hdr_fmt, ('#' x $hdr_width);
2599           5                          42      print "\n";
2600           5                          25      my $max_item = max(map { length($_) } keys %summary);
               9                          89   
2601           5                          31      my $line_fmt = "# %-${max_item}s  %-s\n";
2602           5                          41      foreach my $item ( sort keys %summary ) {
2603           9                         119         printf $line_fmt, $item, $summary{$item};
2604                                              }
2605           5                          22      return;
2606                                           }
2607                                           
2608                                           sub _d {
2609  ***      0                    0             my ($package, undef, $line) = caller 0;
2610  ***      0      0                           @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                               
      ***      0                               
2611  ***      0                                       map { defined $_ ? $_ : 'undef' }
2612                                                   @_;
2613                                              # Use $$ instead of $PID in case the package
2614                                              # does not use English.
2615  ***      0                                  print "# $package:$line $$ ", @_, "\n";
2616                                           }
2617                                           
2618                                           # ############################################################################
2619                                           # Documentation
2620                                           # ############################################################################
2621                                           
2622                                           =pod
2623                                           
2624                                           =head1 NAME
2625                                           
2626                                           mk-duplicate-key-checker - Find duplicate keys and foreign keys on MySQL tables.
2627                                           
2628                                           =head1 SYNOPSIS
2629                                           
2630                                              mk-duplicate-key-checker --host host1
2631                                           
2632                                           =head1 DESCRIPTION
2633                                           
2634                                           This program examines the output of SHOW CREATE TABLE on MySQL tables, and if
2635                                           it finds indexes that cover the same columns as another index in the same
2636                                           order, or cover an exact leftmost prefix of another index, it prints out
2637                                           the suspicious indexes.  By default, indexes must be of the same type, so a
2638                                           BTREE index is not a duplicate of a FULLTEXT index, even if they have the same
2639                                           colums.  You can override this.
2640                                           
2641                                           It also looks for duplicate foreign keys.  A duplicate foreign key covers the
2642                                           same columns as another in the same table, and references the same parent
2643                                           table.
2644                                           
2645                                           =head1 DOWNLOADING
2646                                           
2647                                           You can download Maatkit from Google Code at
2648                                           L<http://code.google.com/p/maatkit/>, or you can get any of the tools
2649                                           easily with a command like the following:
2650                                           
2651                                              wget http://www.maatkit.org/get/toolname
2652                                              or
2653                                              wget http://www.maatkit.org/trunk/toolname
2654                                           
2655                                           Where C<toolname> can be replaced with the name (or fragment of a name) of any
2656                                           of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
2657                                           needed.  The first URL gets the latest released version of the tool, and the
2658                                           second gets the latest trunk code from Subversion.
2659                                           
2660                                           =head1 OPTIONS
2661                                           
2662                                           =over
2663                                           
2664                                           =item --allstruct
2665                                           
2666                                           short form: -a
2667                                           
2668                                           Compare indexes with different structs (BTREE, HASH, etc).
2669                                           
2670                                           By default this is disabled, because a BTREE index that covers the same columns
2671                                           as a FULLTEXT index is not really a duplicate, for example.
2672                                           
2673                                           =item --askpass
2674                                           
2675                                           Prompt for a password when connecting to MySQL.
2676                                           
2677                                           =item --charset
2678                                           
2679                                           short form: -A; type: string
2680                                           
2681                                           Default character set.
2682                                           
2683                                           Enables character set settings in Perl and MySQL. If the value is C<utf8>,
2684                                           sets Perl's binmode on STDOUT to utf8, passes the C<mysql_enable_utf8> option
2685                                           to DBD::mysql, and runs C<SET NAMES UTF8> after connecting to MySQL. Any other
2686                                           value sets binmode on STDOUT without the utf8 layer, and runs C<SET NAMES>
2687                                           after connecting to MySQL.
2688                                           
2689                                           =item --[no]clustered
2690                                           
2691                                           short form: -c; default: yes
2692                                           
2693                                           PK columns appended to secondary key is duplicate.
2694                                           
2695                                           Detects when a suffix of a secondary key is a leftmost prefix of the primary
2696                                           key, and treats it as a duplicate key.  Only detects this condition on storage
2697                                           engines whose primary keys are clustered (currently InnoDB and solidDB).
2698                                           
2699                                           Clustered storage engines append the primary key columns to the leaf nodes of
2700                                           all secondary keys anyway, so you might consider it redundant to have them
2701                                           appear in the internal nodes as well.  Of course, you may also want them in the
2702                                           internal nodes, because just having them at the leaf nodes won't help for some
2703                                           queries.  It does help for covering index queries, however.
2704                                           
2705                                           Here's an example of a key that is considered redundant with this option:
2706                                           
2707                                             PRIMARY KEY  (`a`)
2708                                             KEY `b` (`b`,`a`)
2709                                           
2710                                           The use of such indexes is rather subtle.  For example, suppose you have the
2711                                           following query:
2712                                           
2713                                             SELECT ... WHERE b=1 ORDER BY a;
2714                                           
2715                                           This query will do a filesort if we remove the index on C<b,a>.  But if we
2716                                           shorten the index on C<b,a> to just C<a> and also remove the ORDER BY, the query
2717                                           should return the same results.
2718                                           
2719                                           Currently, the tool suggests removing these indexes, but it should suggest
2720                                           shortening them instead.  This is filed as a feature request (issue 295).
2721                                           
2722                                           =item --databases
2723                                           
2724                                           short form: -d; type: hash
2725                                           
2726                                           Check only this comma-separated list of databases.
2727                                           
2728                                           =item --defaults-file
2729                                           
2730                                           short form: -F; type: string
2731                                           
2732                                           Only read mysql options from the given file.
2733                                           
2734                                           You must give an absolute pathname.
2735                                           
2736                                           =item --engine
2737                                           
2738                                           short form: -e; type: hash
2739                                           
2740                                           Do only tables whose storage engine is in this comma-separated list.
2741                                           
2742                                           =item --function
2743                                           
2744                                           short form: -f; type: string; default: fk
2745                                           
2746                                           Do f=foreign keys, k=keys or fk=check both.
2747                                           
2748                                           =item --host
2749                                           
2750                                           short form: -h; type: string
2751                                           
2752                                           Connect to host.
2753                                           
2754                                           =item --ignoredb
2755                                           
2756                                           short form: -g; type: Hash
2757                                           
2758                                           Ignore this comma-separated list of databases.
2759                                           
2760                                           =item --ignoreengine
2761                                           
2762                                           short form: -E; type: Hash
2763                                           
2764                                           Ignore this comma-separated list of storage engines.
2765                                           
2766                                           =item --ignoreorder
2767                                           
2768                                           Ignore index order so KEY(a,b) duplicates KEY(b,a).
2769                                           
2770                                           =item --ignoretbl
2771                                           
2772                                           short form: -n; type: Hash
2773                                           
2774                                           Ignore this comma-separated list of tables.
2775                                           
2776                                           Table names may be qualified with the database name.
2777                                           
2778                                           =item --password
2779                                           
2780                                           short form: -p; type: string
2781                                           
2782                                           Password to use when connecting.
2783                                           
2784                                           =item --port
2785                                           
2786                                           short form: -P; type: int
2787                                           
2788                                           Port number to use for connection.
2789                                           
2790                                           =item --setvars
2791                                           
2792                                           type: string
2793                                           
2794                                           Set these MySQL variables (default wait_timeout=10000).
2795                                           
2796                                           Specify any variables you want to be set immediately after connecting to MySQL.
2797                                           These will be included in a C<SET> command.
2798                                           
2799                                           =item --socket
2800                                           
2801                                           short form: -S; type: string
2802                                           
2803                                           Socket file to use for connection.
2804                                           
2805                                           =item --[no]summary
2806                                           
2807                                           default: yes
2808                                           
2809                                           Print summary of indexes at end of output.
2810                                           
2811                                           =item --[no]sql
2812                                           
2813                                           default: yes
2814                                           
2815                                           Print DROP KEY statement for each duplicate key.
2816                                           
2817                                           By default an ALTER TABLE  DROP KEY statement is printed below each duplicate
2818                                           key so that, if you want to remove the duplicate key, you can copy-paste the
2819                                           statement into MySQL.
2820                                           
2821                                           To disable printing these statements, specify --nosql.
2822                                           
2823                                           =item --tables
2824                                           
2825                                           short form: -t; type: hash
2826                                           
2827                                           Check only this comma-separated list of tables.
2828                                           
2829                                           Table names may be qualified with the database name.
2830                                           
2831                                           =item --user
2832                                           
2833                                           short form: -u; type: string
2834                                           
2835                                           User for login if not current user.
2836                                           
2837                                           =item --verbose
2838                                           
2839                                           short form: -v
2840                                           
2841                                           Output all keys and/or foreign keys found, not just redundant ones.
2842                                           
2843                                           =back
2844                                           
2845                                           =head1 ENVIRONMENT
2846                                           
2847                                           The environment variable C<MKDEBUG> enables verbose debugging output in all of
2848                                           the Maatkit tools:
2849                                           
2850                                              MKDEBUG=1 mk-....
2851                                           
2852                                           =head1 SYSTEM REQUIREMENTS
2853                                           
2854                                           You need the following Perl modules: DBI and DBD::mysql.
2855                                           
2856                                           =head1 BUGS
2857                                           
2858                                           Please use Google Code Issues and Groups to report bugs or request support:
2859                                           L<http://code.google.com/p/maatkit/>.
2860                                           
2861                                           Please include the complete command-line used to reproduce the problem you are
2862                                           seeing, the version of all MySQL servers involved, the complete output of the
2863                                           tool when run with L<"--version">, and if possible, debugging output produced by
2864                                           running with the C<MKDEBUG=1> environment variable.
2865                                           
2866                                           =head1 LICENSE
2867                                           
2868                                           This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
2869                                           Feedback and improvements are welcome.
2870                                           
2871                                           THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
2872                                           WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
2873                                           MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
2874                                           
2875                                           This program is free software; you can redistribute it and/or modify it under
2876                                           the terms of the GNU General Public License as published by the Free Software
2877                                           Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
2878                                           systems, you can issue `man perlgpl' or `man perlartistic' to read these
2879                                           licenses.
2880                                           
2881                                           You should have received a copy of the GNU General Public License along with
2882                                           this program; if not, write to the Free Software Foundation, Inc., 59 Temple
2883                                           Place, Suite 330, Boston, MA  02111-1307  USA.
2884                                           
2885                                           =head1 AUTHOR
2886                                           
2887                                           Baron Schwartz, Daniel Nichter
2888                                           
2889                                           =head1 VERSION
2890                                           
2891                                           This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 3098 $.
2892                                           
2893                                           =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
56    ***      0      0      0   if (not $$self{$dbh})
60    ***      0      0      0   $$self{$dbh} ge $self->parse($target) ? :
67    ***      0      0      0   defined $_ ? :
108   ***      0      0      0   if (defined $_) { }
110   ***      0      0      0   $_ eq '' || $_ =~ /^0|\D/ ? :
123   ***      0      0      0   if (not $tbl)
156          100      6      3   if (ref $ddl eq 'ARRAY')
157   ***     50      6      0   if (lc $$ddl[0] eq 'table') { }
167   ***     50      0      9   if (not $ddl =~ /CREATE (?:TEMPORARY )?TABLE `/)
188   ***     50      0     34   unless $type
190          100     19     15   if ($type =~ /(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/)
194          100     20     14   if (not $def =~ /NOT NULL/)
198   ***     50      0     34   $def =~ /AUTO_INCREMENT/i ? :
227   ***      0      0      0   unless ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
241   ***      0      0      0   if ($index)
244   ***      0      0      0   if (not $best)
245   ***      0      0      0   if ($index) { }
258   ***      0      0      0   unless $where
264   ***      0      0      0   if ($$expl{'possible_keys'}) { }
268   ***      0      0      0   if ($$expl{'key'})
287   ***      0      0      0   $can_insert ? :
292   ***      0      0      0   if $EVAL_ERROR
311   ***     50      0     26   if $key =~ /FOREIGN/
315   ***     50     26      0   if (not $engine =~ /MEMORY|HEAP/)
322   ***     50      0     26   if ($$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i)
329          100      8     18   $key =~ /PRIMARY|UNIQUE/ ? :
368   ***      0      0      0   if (not $parent =~ /\./ and $$opts{'database'})
385   ***      0      0      0   defined $_ ? :
435   ***     50      7      0   unless defined $args{'cache'}
443   ***      0      0      0   if ($what eq 'table') { }
      ***      0      0      0   elsif ($what eq 'triggers') { }
      ***      0      0      0   elsif ($what eq 'view') { }
445   ***      0      0      0   if ($$ddl[0] eq 'table') { }
459   ***      0      0      0   if ($trgs and @$trgs) { }
462   ***      0      0      0   if ($$trg{'sql_mode'})
466   ***      0      0      0   if ($$trg{'definer'})
498   ***     50      0     12   if (not $new)
505   ***     50     12      0   if ($curr and $new and $curr eq $new)
517          100      6      6   if (not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl})
535   ***     50      6      0   if ($key) { }
551   ***      0      0      0   if (not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl})
581   ***      0      0      0   if (not $$self{'cache'} or not $$self{'triggers'}{$db})
594   ***      0      0      0   if ($sth->rows)
607   ***      0      0      0   if ($tbl)
615   ***     50      7      0   if (not $$self{'cache'} or not $$self{'databases'} or $like)
618   ***     50      0      7   if ($like)
626   ***     50      7      0   unless $like
634   ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_status'}{$db} or $like)
637   ***      0      0      0   if ($like)
652   ***      0      0      0   unless $like
660   ***     50      6      0   if (not $$self{'cache'} or not $$self{'table_list'}{$db} or $like)
663   ***     50      0      6   if ($like)
671   ***     50      0     39   ($$_[1] || '') eq 'VIEW' ? :
678   ***     50      6      0   unless $like
686   ***      0      0      0   defined $_ ? :
717   ***     50      0     14   unless $args{$arg}
719   ***     50      0      7   if $args{'dbh'}
721   ***     50      7      0   $$self{'engines'}{'permit'} || $$self{'engines'}{'reject'} || $$self{'engines'}{'regexp'} ? :
725   ***     50      0      7   if $$self{'need_engine'} and not defined $args{'parser'}
728   ***     50      0      7   unless defined $$self{'engines'}{'views'}
729   ***     50      7      0   unless defined $$self{'tables'}{'status'}
730   ***     50      7      0   if ($args{'useddl'})
738   ***      0      0      0   if $$self{'timestamp'}{$dbh}{'now'}
763   ***     50      6      0   if ($$self{'need_engine'})
765   ***     50      0      6   if $$tbl{'engine'}
798          100      6      6   if (not $new)
805   ***     50      0      6   if ($curr and $new and $curr eq $new)
817   ***     50      0      6   unless $args{'database'}
822   ***     50      0      6   if (scalar @{$$self{'tables'}{'status'};}) { }
838   ***     50     39      0   unless $$self{'engines'}{'views'}
859   ***     50      0     64   unless defined $val
860          100     39     25   if ($thing eq 'tables') { }
862          100      6     33   if !$reject || !$$reject{$val} && !$$reject{$tbl} and !$permit || $$permit{$val} || $$permit{$tbl}
867          100     12     13   if !$reject || !$$reject{$val} and !$permit || $$permit{$val}
877   ***      0      0      0   if (not defined $$table{$prop})
882   ***      0      0      0   unless defined $num
897   ***      0      0      0   defined $_ ? :
980          100      7     14   if (@_ > 2)
989   ***      0      0      0   if (not $dsn)
1002  ***      0      0      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
      ***      0      0      0   elsif ($prop_autokey) { }
1017  ***      0      0      0   if (not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'})
1023  ***      0      0      0   if (not defined $final_props{$key})
1030  ***      0      0      0   unless exists $opts{$key}
1033  ***      0      0      0   if (my $required = $self->prop('required'))
1035  ***      0      0      0   unless $final_props{$key}
1044  ***      0      0      0   unless ref $dsn
1045  ***      0      0      0   $_ eq 'p' ? :
1046  ***      0      0      0   if defined $$dsn{$_}
1059  ***      0      0      0   $opts{$key}{'copy'} ? :
1064  ***      0      0      0   if (my $key = $self->prop('autokey'))
1075  ***     50      0      7   if ($driver eq 'Pg') { }
1107  ***     50      0      7   $cxn_string =~ /charset=utf8/ ? :
1121  ***     50      0      7   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
1126  ***      0      0      0   if ($charset eq 'utf8') { }
1127  ***      0      0      0   unless binmode STDOUT, ':utf8'
1131  ***      0      0      0   unless binmode STDOUT
1135  ***     50      0      7   if (not $dbh and $EVAL_ERROR)
1137  ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/)
1141  ***      0      0      0   if (not $tries)
1147  ***     50      7      0   if ($cxn_string =~ /mysql/i and $setvars)
1153  ***     50      0      7   if ($EVAL_ERROR)
1173  ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
1190  ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
1200  ***      0      0      0   defined $_ ? :
1231  ***     50      0      7   unless open my $fh, '<', $file
1252         100   2191      7   unless $para =~ /^=head1 OPTIONS/
1257  ***     50      7      0   if $para =~ /^=over/
1266         100    154      7   if (($option) = $para =~ /^=item --(.*)/)
1270         100    140     14   if ($para =~ /: /)
1273         100    119     21   if ($props{'short form'})
1281  ***     50    154      0   if ($para =~ /^[^.]+\.$/)
1285         100     21    133   if (my($base_option) = $option =~ /^\[no\](.*)/)
1290         100    119     35   $props{'short form'} ? :
             100     21    133   $props{'negatable'} ? :
      ***     50      0    154   $props{'cumulative'} ? :
             100    105     49   $props{'type'} ? :
             100     28    126   defined $props{'default'} ? :
1301  ***     50      0    280   unless $para
1303         100    273      7   if ($option)
1304  ***     50      0    273   if (my($line) = $para =~ /(allowed with --${option}[:]?.*?)\./)
1311         100      7    273   if ($para =~ /^=head1/)
1315         100    154    119   if $para =~ /^=item --/
1341  ***     50    168      0   if (ref $opt) { }
1348  ***     50      0    168   if $key_seen{$$opt{'k'}}++
1349  ***     50      0    168   if $long_seen{$$opt{'l'}}++
1354         100     42    126   if (my($y) = $$opt{'s'} =~ /=([mdHhAaz])/)
1359  ***     50      0    168   if ($$opt{'d'} =~ /required/)
1363         100     35    133   if (my($def) = $$opt{'d'} =~ /default\b(?: ([^)]+))?/)
1364  ***     50     35      0   defined $def ? :
1367  ***     50      0    168   if (my($dis) = $$opt{'d'} =~ /(disables .*)/)
1373  ***      0      0      0   if ($opt =~ /at least one|mutually exclusive|one and only one/) { }
      ***      0      0      0   elsif ($opt =~ /default to/) { }
      ***      0      0      0   elsif ($opt =~ /allowed with/) { }
1374  ***      0      0      0   unless $long_for{$_}
1378  ***      0      0      0   if ($opt =~ /mutually exclusive|one and only one/)
1382  ***      0      0      0   if ($opt =~ /at least one|one and only one/)
1388  ***      0      0      0   unless $long_for{$_}
1396  ***      0      0      0   unless $long_for{$_}
1409  ***      0      0      0   if (not defined $long_for{$_})
1441  ***      0      0      0   if (my($long) = $thing =~ /--(.+)/) { }
1462         100    133     35   unless defined $vals{$$spec{'k'}}
1467  ***      0      0      0   unless $opt_seen{$key}
1476  ***     50      0      7   unless GetOptions map({my $spec = $_;
$$spec{'s'}, sub {
	my($opt, $val) = @_;
if ($$spec{'c'}) {
	++$vals{$$spec{'k'}};
}
else {
	$vals{$$spec{'k'}} = $val;
};
'???';
$$self{'given'}{$$spec{'k'}} = $vals{$$spec{'k'}};
}
;} @specs)
1479  ***     50      0     21   if ($$spec{'c'}) { }
1492  ***     50      0      7   if ($vals{'version'})
1494  ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $prog, $main::VERSION, $main::DISTRIB, $main::SVN_REV
1500  ***     50      0      7   if (@ARGV and $$self{'strict'})
1511  ***      0      0      0   if (not defined $vals{$$spec{'k'}})
1518  ***      0      0      0   if (@set > 1)
1530  ***      0      0      0   if (not @set)
1539         100     42    126   if $$_{'y'}
1541  ***     50      0     10   if ($$spec{'y'} eq 'm') { }
      ***     50      0     10   elsif ($$spec{'y'} eq 'd') { }
      ***     50      0     10   elsif ($$spec{'y'} eq 'z') { }
1543  ***      0      0      0   if (not $suffix)
1549  ***      0      0      0   if ($suffix =~ /[smhd]/) { }
1550  ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
1565  ***      0      0      0   if ($from_key)
1573  ***      0      0      0   if (defined $num) { }
1574  ***      0      0      0   if ($factor)
1589         100     31     11   if ($$spec{'y'} eq 'H' or defined $val and $$spec{'y'} eq 'h') { }
      ***     50      0     11   elsif ($$spec{'y'} eq 'A' or defined $val and $$spec{'y'} eq 'a') { }
1599  ***      0      0      0   unless $vals{$opt}
1643  ***     50      0      7   if ($opts{'help'}) { }
      ***     50      0      7   elsif ($$self{'__error__'}) { }
1644  ***      0      0      0   unless print $self->usage(%opts)
1649  ***      0      0      0   unless print $self->errors
1658  ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
1668  ***      0      0      0   $$_{'n'} ? :
1670  ***      0      0      0   $$_{'n'} ? :
1686  ***      0      0      0   $$spec{'n'} ? :
1689  ***      0      0      0   if ($$spec{'y'} and $$spec{'y'} eq 'm')
1698  ***      0      0      0   if ($short) { }
1707  ***      0      0      0   if (my(@instr) = @{$$self{'instr'};})
1710  ***      0      0      0   if ($$self{'dsn'})
1718  ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
1730  ***      0      0      0   if ref $_[0] eq 'OptionParser'
1733  ***      0      0      0   unless print $prompt
1741  ***      0      0      0   unless print "\n"
1744  ***      0      0      0   if ($EVAL_ERROR)
1771  ***      0      0      0   defined $_ ? :
1803  ***     50      0      6   unless $args{$arg}
1807  ***     50      0      4   unless exists $$key{$req_key}
1819  ***     50      2      0   if (scalar @{$$key{'cols'};} == 1)
1830  ***     50      0      2   defined $key_len && defined $rows ? :
1845  ***      0      0      0   defined $_ ? :
1882  ***     50      0      5   unless $args{'keys'}
1897         100      1      8   if ($$key{'name'} eq 'PRIMARY')
1902  ***     50      0      8   $$key{'type'} eq 'FULLTEXT' ? :
1904  ***     50      0      8   if ($args{'ignore_order'} or $is_fulltext)
1911         100      2      6   $$key{'is_unique'} ? :
1912  ***     50      8      0   if (not $args{'ignore_type'})
1913  ***     50      0      8   if $is_fulltext
1926         100      4      3   unless $unique_key
1928         100      1      2   if (@$cols == 1) { }
1930  ***     50      1      0   if (not exists $unique_cols{$$cols[0]})
1947         100      1      6   if (exists $unique_cols{$col})
1950  ***     50      0      1   if ++$n_unique_cols > 1
1954         100      1      1   if ($n_unique_cols and $$unique_set{'key'}{'name'} ne 'PRIMARY')
1965         100      1      1   if (exists $unconstrain{$unique_keys[$i]{'name'}})
1978         100      1      4   if ($primary_key)
2014  ***     50      0      5   if ($primary_key and $args{'clustered'} and $args{'tbl_info'}{'engine'} =~ /^(?:InnoDB|solidDB)$/)
2036  ***     50      0      5   unless $args{'keys'}
2040  ***      0      0      0   unless $fks[$i]
2042  ***      0      0      0   unless $fks[$j]
2052  ***      0      0      0   if ($fks[$i]{'parent'} eq $fks[$j]{'parent'} and $i_cols eq $j_cols and $i_fkcols eq $j_fkcols)
2068  ***      0      0      0   if $args{'callback'}
2090         100      7     10   if ($args{'remove_keys'}) { }
2112  ***     50      0      6   unless defined $$keys[$i]
2116  ***     50      0      4   unless defined $$remove_keys[$j]
2131         100      3      1   if (substr($rm_cols, 0, $rm_len_cols) eq substr($keep_cols, 0, $rm_len_cols)) { }
2134  ***     50      0      3   if ($args{'exact_duplicates'} and $rm_len_cols < $keep_len_cols)
2139  ***     50      0      3   if (exists $$remove_keys[$rm]{'unique_col'})
2147  ***     50      0      3   if ($$remove_keys[$rm]{'unconstrained'})
2152  ***     50      3      0   $rm_len_cols < $keep_len_cols ? :
2166  ***     50      3      0   if $args{'callback'}
2168  ***     50      3      0   if $remove_index == 0
2169  ***      0      0      0   if $remove_index == 1
2180         100      7     10   if $args{'remove_keys'}
2181  ***     50      0     17   if $args{'duplice_keys'}
2188  ***      0      0      0   unless $args{'primary_key'}
2189  ***      0      0      0   unless $args{'keys'}
2199  ***      0      0      0   if (substr($suffix, 0, $len) eq substr($pkcols, 0, $len))
2211  ***      0      0      0   if $args{'callback'}
2219  ***      0      0      0   if $args{'duplice_keys'}
2226  ***      0      0      0   defined $_ ? :
2268  ***      0      0      0   defined $args{'p_ms'} ? :
2269  ***      0      0      0   defined $args{'p_s'} ? :
2272  ***      0      0      0   if $t < 0
2274  ***      0      0      0   if $t =~ /e/
2278  ***      0      0      0   if ($t > 0 and $t <= 0.000999) { }
      ***      0      0      0   elsif ($t >= 0.001 and $t <= 0.999999) { }
      ***      0      0      0   elsif ($t >= 1) { }
2299  ***      0      0      0   $p ? :
2306  ***      0      0      0   unless $secs
2308  ***      0      0      0   $secs >= 3600 ? :
      ***      0      0      0   $secs >= 86400 ? :
2313  ***      0      0      0   $fmt eq 'h' ? :
      ***      0      0      0   $fmt eq 'd' ? :
2332  ***      0      0      0   defined $args{'p'} ? :
2333  ***      0      0      0   defined $args{'d'} ? :
2340  ***      0      0      0   $num =~ /\./ || $n ? :
2359  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s) = $val =~ /^(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)$/)
2370  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s) = $val =~ /^(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)$/)
2387  ***      0      0      0   defined $_ ? :
2432  ***     50      0      7   if (not defined $opts{'p'} and $opts{'askpass'})
2449         100      5      2   $opts{'summary'} ? :
2493  ***     50      6      0   if $opts{'f'} =~ /k/
2494  ***     50      6      0   if $opts{'f'} =~ /f/
2496  ***     50      0      6   unless %$keys or %$fks
2498         100      1      5   if ($opts{'v'}) { }
2499  ***     50      1      0   if $keys
2500  ***     50      1      0   if $fks
2503  ***     50      5      0   if $keys
2510  ***     50      5      0   if $fks
2517         100      5      1   if $opts{'summary'}
2522         100      5      2   if $opts{'summary'}
2532  ***     50      0      2   unless $keys
2535         100      1      1   if (not $seen_tbl{"$db$tbl"}++)
2549  ***     50      0      3   unless $dupe
2554  ***     50      3      0   if (not $seen_tbl{"$db$tbl"}++)
2566         100      6      3   if not $seen_col{$_}++
2573         100      2      1   if $opts{'sql'}
2578         100      2      1   if ($opts{'summary'})
2610  ***      0      0      0   defined $_ ? :


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
322   ***     33     26      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000'
      ***     33     26      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i
368   ***      0      0      0      0   not $parent =~ /\./ and $$opts{'database'}
459   ***      0      0      0      0   $trgs and @$trgs
505   ***     33      0      0     12   $curr and $new
      ***     33      0      0     12   $curr and $new and $curr eq $new
725   ***     33      0      7      0   $$self{'need_engine'} and not defined $args{'parser'}
805   ***     33      6      0      0   $curr and $new
      ***     33      6      0      0   $curr and $new and $curr eq $new
862   ***     33      0      0     39   !$$reject{$val} && !$$reject{$tbl}
      ***     66      0     33      6   !$reject || !$$reject{$val} && !$$reject{$tbl} and !$permit || $$permit{$val} || $$permit{$tbl}
867   ***     66      0     13     12   !$reject || !$$reject{$val} and !$permit || $$permit{$val}
890   ***      0      0      0      0   $equality eq '-' && $$table{$prop} gt $time
      ***      0      0      0      0   $equality eq '+' && $$table{$prop} lt $time
1017  ***      0      0      0      0   not defined $final_props{$key} and defined $$prev{$key}
      ***      0      0      0      0   not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'}
1116  ***     66      7      0      7   not $dbh and $tries--
1135  ***     33      7      0      0   not $dbh and $EVAL_ERROR
1147  ***     33      0      0      7   $cxn_string =~ /mysql/i and $setvars
1500  ***     33      7      0      0   @ARGV and $$self{'strict'}
1589  ***     66     11      0     10   defined $val and $$spec{'y'} eq 'h'
      ***     33     11      0      0   defined $val and $$spec{'y'} eq 'a'
1689  ***      0      0      0      0   $$spec{'y'} and $$spec{'y'} eq 'm'
1830  ***     33      2      0      0   defined $key_len && defined $rows
1954  ***     66      1      0      1   $n_unique_cols and $$unique_set{'key'}{'name'} ne 'PRIMARY'
2014  ***     66      4      0      1   $primary_key and $args{'clustered'}
      ***     66      4      1      0   $primary_key and $args{'clustered'} and $args{'tbl_info'}{'engine'} =~ /^(?:InnoDB|solidDB)$/
2052  ***      0      0      0      0   $fks[$i]{'parent'} eq $fks[$j]{'parent'} and $i_cols eq $j_cols
      ***      0      0      0      0   $fks[$i]{'parent'} eq $fks[$j]{'parent'} and $i_cols eq $j_cols and $i_fkcols eq $j_fkcols
2134  ***     33      3      0      0   $args{'exact_duplicates'} and $rm_len_cols < $keep_len_cols
2278  ***      0      0      0      0   $t > 0 and $t <= 0.000999
      ***      0      0      0      0   $t >= 0.001 and $t <= 0.999999
2336  ***      0      0      0      0   $num >= $d and $n < @units - 1
2432  ***     33      0      7      0   not defined $opts{'p'} and $opts{'askpass'}

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
300   ***     50     30      0   $engine || undef
321   ***     50      0     26   $type || $special || 'BTREE'
671   ***     50     39      0   $$_[1] || ''
994   ***      0      0      0   $prev ||= {}
995   ***      0      0      0   $defaults ||= {}
1059  ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
1074  ***     50      0      7   $self->prop('dbidriver') || ''
1078  ***      0      0      0   $$info{'D'} || ''
1084  ***     50      0      7   $$info{'D'} || ''
1106  ***     50      7      0   $opts ||= {}
1173  ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
1189  ***      0      0      0   $level ||= 0
1190  ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
1230  ***     50      0      7   $file ||= '../mk-duplicate-key-checker'
1353  ***     50      0    168   $$opt{'g'} ||= 'o'
1545  ***      0      0      0   $s || 's'
1578  ***      0      0      0   $pre || ''
1590         100     10     21   $val || ''
1593  ***      0      0      0   $val || ''
1626  ***      0      0      0   $$self{'prompt'} || '<options>'
1633  ***      0      0      0   $$self{'descr'} || ''
1691  ***      0      0      0   $s ||= 's'
1716  ***      0      0      0   $$spec{'y'} || ''
2298  ***      0      0      0   $args{'p'} || 0
2300  ***      0      0      0   $of ||= 1
2305  ***      0      0      0   $secs ||= 0

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
110   ***      0      0      0      0   $_ eq '' || $_ =~ /^0|\D/
227   ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'}
      ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
321   ***     33      0      0     26   $type || $special
517   ***     66      0      6      6   not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl}
551   ***      0      0      0      0   not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl}
581   ***      0      0      0      0   not $$self{'cache'} or not $$self{'triggers'}{$db}
615   ***     33      0      7      0   not $$self{'cache'} or not $$self{'databases'}
      ***     33      7      0      0   not $$self{'cache'} or not $$self{'databases'} or $like
634   ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db} or $like
648   ***      0      0      0      0   $tbl{'type'} || $tbl{'comment'}
      ***      0      0      0      0   $tbl{'engine'} ||= $tbl{'type'} || $tbl{'comment'}
660   ***     33      0      6      0   not $$self{'cache'} or not $$self{'table_list'}{$db}
      ***     33      6      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db} or $like
721   ***     33      0      7      0   $$self{'engines'}{'permit'} || $$self{'engines'}{'reject'}
      ***     33      7      0      0   $$self{'engines'}{'permit'} || $$self{'engines'}{'reject'} || $$self{'engines'}{'regexp'}
862   ***     33      6      0      0   not $regexp or $val =~ /$regexp/
      ***     33      0     39      0   !$reject || !$$reject{$val} && !$$reject{$tbl}
      ***     66      3      0     36   !$permit || $$permit{$val}
             100      3      3     33   !$permit || $$permit{$val} || $$permit{$tbl}
867   ***     33     12      0      0   not $regexp or $val =~ /$regexp/
      ***     33      0     25      0   !$reject || !$$reject{$val}
             100      6      6     13   !$permit || $$permit{$val}
887   ***      0      0      0      0   $$self{'timestamp'}{$dbh}{$num} ||= $dbh->selectrow_array($sql)
890   ***      0      0      0      0   $equality eq '-' && $$table{$prop} gt $time || $equality eq '+' && $$table{$prop} lt $time
      ***      0      0      0      0   $equality eq '-' && $$table{$prop} gt $time || $equality eq '+' && $$table{$prop} lt $time || $$table{$prop} eq $time
1097  ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
1098  ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
1099  ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
1100  ***      0      0      0      0   $$dsn{'u'} ||= $user
1101  ***      0      0      0      0   $$dsn{'D'} ||= $db
1343  ***     66    119     49      0   $short || $long
1589         100     21     10     11   $$spec{'y'} eq 'H' or defined $val and $$spec{'y'} eq 'h'
      ***     33      0      0     11   $$spec{'y'} eq 'A' or defined $val and $$spec{'y'} eq 'a'
1620  ***      0      0      0      0   $prog || $PROGRAM_NAME
1904  ***     33      0      0      8   $args{'ignore_order'} or $is_fulltext
2308  ***      0      0      0      0   $fmt ||= $secs >= 86400 ? 'd' : ($secs >= 3600 ? 'h' : 'm')
2340  ***      0      0      0      0   $num =~ /\./ || $n
2485  ***     33      6      0      0   $tp->get_engine($ddl) || next TABLE
2496  ***     33      6      0      0   %$keys or %$fks


Covered Subroutines
-------------------

Subroutine                  Count Location                                                                       
--------------------------- ----- -------------------------------------------------------------------------------
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1217
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1218
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1220
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1221
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1222
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1224
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:141 
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:142 
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:143 
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:145 
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1788
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1789
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1790
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1792
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1862
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1863
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1864
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1866
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1868
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2243
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2244
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2245
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2246
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2247
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2249
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:23  
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:24  
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2404
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2405
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2406
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2410
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:33  
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:34  
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:38  
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:40  
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:402 
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:403 
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:405 
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:407 
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:703 
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:704 
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:706 
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:707 
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:711 
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:82  
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:83  
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:87  
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:89  
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:912 
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:913 
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:917 
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:918 
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:921 
BEGIN                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:923 
__ANON__                       21 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1478
__ANON__                       19 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:749 
__ANON__                       39 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:760 
__ANON__                        6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:772 
_fetch_tbl_list                 6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:816 
_filter                        19 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:852 
_use_db                        12 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:497 
_use_db                        12 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:797 
find_databases                  7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:746 
find_tables                     6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:757 
get_create_table               12 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:516 
get_cxn_params                  7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1071
get_databases                   7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:614 
get_dbh                         7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1105
get_duplicate_fks               5 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2035
get_duplicate_keys              5 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1881
get_engine                     30 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:297 
get_fks                         6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:357 
get_key_size                    2 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1801
get_keys                       15 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:304 
get_table_list                  6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:659 
new                             7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1324
new                             7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:148 
new                             5 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1795
new                             7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1871
new                             7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:43  
new                             7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:434 
new                             7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:715 
new                             7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:92  
new                             7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:926 
parse                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1455
parse                           9 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:154 
parse                           7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:48  
pod_to_spec                     7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1229
print_all_keys                  2 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2531
print_duplicate_key             3 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2548
print_key_summary               5 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2595
prop                           21 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:979 
quote                          22 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:97  
remove_prefix_duplicates       17 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2076
usage_or_errors                 7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1642

Uncovered Subroutines
---------------------

Subroutine                  Count Location                                                                       
--------------------------- ----- -------------------------------------------------------------------------------
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1199
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1770
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1844
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2225
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2386
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2609
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:384 
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:66  
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:685 
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:896 
_test_date                      0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:875 
as_string                       0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1043
descr                           0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1631
disconnect                      0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1182
dump                            0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:441 
error                           0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1613
errors                          0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1656
fill_in_dsn                     0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1093
find_best_index                 0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:239 
find_possible_keys              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:257 
find_views                      0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:789 
get_columns                     0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:549 
get_hostname                    0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1172
get_participants                0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1438
get_table_status                0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:633 
get_tmp_table                   0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:569 
get_triggers                    0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:580 
groups                          0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1751
init_timestamp                  0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:737 
make_checksum                   0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2379
micro_t                         0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2267
parse                           0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:988 
parse_timestamp                 0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2358
percentage_of                   0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2297
print_active_handles            0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1188
prog                            0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1619
prompt                          0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1624
prompt_noecho                   0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1730
quote_val                       0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:105 
remove_clustered_duplicates     0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2187
secs_to_time                    0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2304
shorten                         0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2331
sort_indexes                    0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:220 
split_unquote                   0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:120 
table_exists                    0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:285 
ts                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2348
unix_timestamp                  0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2369
usage                           0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1052
usage                           0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1665
version_ge                      0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:55  


